{
	// Place your snippets for javascriptreact here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"re-helloworld": {
		"prefix": "re-helloworld",
		"body": [
			"<!DOCTYPE html>",
			"<html>",
			"<head>",
			"<meta charset=\"UTF-8\" />",
			"<title>Hello React!</title>",
			"<script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\"></script>",
			"<script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\"></script>",
			"<script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\"></script>",
			"</head>",
			"<body>",
			"",
			"<div id=\"example\"></div>",
			"<script type=\"text/babel\">",
			"ReactDOM.render(",
			"<h1>Hello, world!</h1>,",
			"document.getElementById('example')",
			");",
			"</script>",
			"",
			"</body>",
			"</html>",
		],
	},
	"re-React 安装": {
		"prefix": "re-React 安装",
		"body": [
			"React 可以直接下载使用，下载包中也提供了很多学习的实例。",
			"",
			"本教程使用了 React 的版本为 16.4.0，你可以在官网 https://reactjs.org/ 下载最新版。",
			"",
			"你也可以直接使用 Staticfile CDN 的 React CDN 库，地址如下：",
			"",
			"<script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\"></script>",
			"<script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\"></script>",
			"<!-- 生产环境中不建议使用 -->",
			"<script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\"></script>",
			"官方提供的 CDN 地址：",
			"",
			"<script src=\"https://unpkg.com/react@16/umd/react.development.js\"></script>",
			"<script src=\"https://unpkg.com/react-dom@16/umd/react-dom.development.js\"></script>",
			"<!-- 生产环境中不建议使用 -->",
			"<script src=\"https://unpkg.com/babel-standalone@6.15.0/babel.min.js\"></script>",
			"注意: 在浏览器中使用 Babel 来编译 JSX 效率是非常低的。",
			"",
			"使用实例",
			"以下实例输出了 Hello, world!",
			"",
			"React 实例",
			"<!DOCTYPE html>",
			"<html>",
			"<head>",
			"<meta charset=\"UTF-8\" />",
			"<title>Hello React!</title>",
			"<script src=\"https://cdn.staticfile.org/react/16.4.0/umd/react.development.js\"></script>",
			"<script src=\"https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js\"></script>",
			"<script src=\"https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js\"></script>",
			"</head>",
			"<body>",
			" ",
			"<div id=\"example\"></div>",
			"<script type=\"text/babel\">",
			"ReactDOM.render(",
			"    <h1>Hello, world!</h1>,",
			"    document.getElementById('example')",
			");",
			"</script>",
			" ",
			"</body>",
			"</html>",
			"",
			"尝试一下 »",
			"实例解析：",
			"",
			"实例中我们引入了三个库： react.min.js 、react-dom.min.js 和 babel.min.js：",
			"",
			"react.min.js - React 的核心库",
			"react-dom.min.js - 提供与 DOM 相关的功能",
			"babel.min.js - Babel 可以将 ES6 代码转为 ES5 代码，这样我们就能在目前不支持 ES6 浏览器上执行 React 代码。Babel 内嵌了对 JSX 的支持。通过将 Babel 和 babel-sublime 包（package）一同使用可以让源码的语法渲染上升到一个全新的水平。",
			"ReactDOM.render(",
			"    <h1>Hello, world!</h1>,",
			"    document.getElementById('example')",
			");",
			"以上代码将一个 h1 标题，插入 id=\"example\" 节点中。",
			"",
			"注意：",
			"",
			"如果我们需要使用 JSX，则 <script> 标签的 type 属性需要设置为 text/babel。",
			"",
			"通过 npm 使用 React",
			"如果你的系统还不支持 Node.js 及 NPM 可以参考我们的 Node.js 教程。",
			"",
			"我们建议在 React 中使用 CommonJS 模块系统，比如 browserify 或 webpack，本教程使用 webpack。",
			"",
			"国内使用 npm 速度很慢，你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:",
			"",
			"$ npm install -g cnpm --registry=https://registry.npm.taobao.org",
			"$ npm config set registry https://registry.npm.taobao.org",
			"这样就可以使用 cnpm 命令来安装模块了：",
			"",
			"$ cnpm install [name]",
			"更多信息可以查阅：http://npm.taobao.org/。",
			"",
			"使用 create-react-app 快速构建 React 开发环境",
			"create-react-app 是来自于 Facebook，通过该命令我们无需配置就能快速构建 React 开发环境。",
			"",
			"create-react-app 自动创建的项目是基于 Webpack + ES6 。",
			"",
			"执行以下命令创建项目：",
			"",
			"$ cnpm install -g create-react-app",
			"$ create-react-app my-app",
			"$ cd my-app/",
			"$ npm start",
			"在浏览器中打开 http://localhost:3000/ ，结果如下图所示：",
			"",
			"",
			"",
			"项目的目录结构如下：",
			"",
			"my-app/",
			"  README.md",
			"  node_modules/",
			"  package.json",
			"  .gitignore",
			"  public/",
			"    favicon.ico",
			"    index.html",
			"    manifest.json",
			"  src/",
			"    App.css",
			"    App.js",
			"    App.test.js",
			"    index.css",
			"    index.js",
			"    logo.svg",
			"manifest.json 指定了开始页面 index.html，一切的开始都从这里开始，所以这个是代码执行的源头。",
			"",
			"尝试修改 src/App.js 文件代码：",
			"",
			"src/App.js",
			"import React, { Component } from 'react';",
			"import logo from './logo.svg';",
			"import './App.css';",
			" ",
			"class App extends Component {",
			"  render() {",
			"    return (",
			"      <div className=\"App\">",
			"        <div className=\"App-header\">",
			"          <img src={logo} className=\"App-logo\" alt=\"logo\" />",
			"          <h2>欢迎来到菜鸟教程</h2>",
			"        </div>",
			"        <p className=\"App-intro\">",
			"          你可以在 <code>src/App.js</code> 文件中修改。",
			"        </p>",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"export default App;",
			"修改后，打开 http://localhost:3000/ （一般自动刷新），输出结果如下：",
		],
	},
	"re-React 元素渲染": {
		"prefix": "re-React 元素渲染",
		"body": [
			"元素是构成 React 应用的最小单位，它用于描述屏幕上输出的内容。",
			"",
			"const element = <h1>Hello, world!</h1>;",
			"与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。",
			"",
			"将元素渲染到 DOM 中",
			"首先我们在一个 HTML 页面中添加一个 id=\"example\" 的 <div>:",
			"",
			"<div id=\"example\"></div>",
			"在此 div 中的所有内容都将由 React DOM 来管理，所以我们将其称为 \"根\" DOM 节点。",
			"",
			"我们用 React 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React 的话，你可能会需要在不同的部分单独定义 React 根节点。",
			"",
			"要将React元素渲染到根DOM节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上：",
			"",
			"实例",
			"const element = <h1>Hello, world!</h1>;",
			"ReactDOM.render(",
			"    element,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"更新元素渲染",
			"React 元素都是不可变的。当元素被创建之后，你是无法改变其内容或属性的。",
			"",
			"目前更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法：",
			"",
			"来看一下这个计时器的例子:",
			"",
			"实例",
			"function tick() {",
			"  const element = (",
			"    <div>",
			"      <h1>Hello, world!</h1>",
			"      <h2>现在是 {new Date().toLocaleTimeString()}.</h2>",
			"    </div>",
			"  );",
			"  ReactDOM.render(",
			"    element,",
			"    document.getElementById('example')",
			"  );",
			"}",
			" ",
			"setInterval(tick, 1000);",
			"",
			"尝试一下 »",
			"以上实例通过 setInterval() 方法，每秒钟调用一次 ReactDOM.render()。",
			"",
			"我们可以将要展示的部分封装起来，以下实例用一个函数来表示：",
			"",
			"实例",
			"function Clock(props) {",
			"  return (",
			"    <div>",
			"      <h1>Hello, world!</h1>",
			"      <h2>现在是 {props.date.toLocaleTimeString()}.</h2>",
			"    </div>",
			"  );",
			"}",
			" ",
			"function tick() {",
			"  ReactDOM.render(",
			"    <Clock date={new Date()} />,",
			"    document.getElementById('example')",
			"  );",
			"}",
			" ",
			"setInterval(tick, 1000);",
			"",
			"尝试一下 »",
			"除了函数外我们还可以创建一个 React.Component 的 ES6 类，该类封装了要展示的元素，需要注意的是在 render() 方法中，需要使用 this.props 替换 props：",
			"",
			"实例",
			"class Clock extends React.Component {",
			"  render() {",
			"    return (",
			"      <div>",
			"        <h1>Hello, world!</h1>",
			"        <h2>现在是 {this.props.date.toLocaleTimeString()}.</h2>",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"function tick() {",
			"  ReactDOM.render(",
			"    <Clock date={new Date()} />,",
			"    document.getElementById('example')",
			"  );",
			"}",
			" ",
			"setInterval(tick, 1000);",
			"",
			"尝试一下 »",
			"React 只会更新必要的部分",
			"",
			"值得注意的是 React DOM 首先会比较元素内容先后的不同，而在渲染过程中只会更新改变了的部分。",
		],
	},
	"re-React JSX": {
		"prefix": "re-React JSX",
		"body": [
			"React 使用 JSX 来替代常规的 JavaScript。",
			"",
			"JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。",
			"",
			"我们不需要一定使用 JSX，但它有以下优点：",
			"",
			"JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。",
			"它是类型安全的，在编译过程中就能发现错误。",
			"使用 JSX 编写模板更加简单快速。",
			"我们先看下以下代码：",
			"",
			"const element = <h1>Hello, world!</h1>;",
			"这种看起来可能有些奇怪的标签语法既不是字符串也不是 HTML。",
			"",
			"它被称为 JSX， 一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 JSX 来描述用户界面。",
			"",
			"JSX 是在 JavaScript 内部实现的。",
			"",
			"我们知道元素是构成 React 应用的最小单位，JSX 就是用来声明 React 当中的元素。",
			"",
			"与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。",
			"",
			"要将 React 元素渲染到根 DOM 节点中，我们通过把它们都传递给 ReactDOM.render() 的方法来将其渲染到页面上：",
			"",
			"React 实例",
			"var myDivElement = <div className=\"foo\" />;",
			"ReactDOM.render(myDivElement, document.getElementById('example'));",
			"",
			"尝试一下 »",
			"注意:",
			"",
			"由于 JSX 就是 JavaScript，一些标识符像 class 和 for 不建议作为 XML 属性名。作为替代，React DOM 使用 className 和 htmlFor 来做对应的属性。",
			"",
			"使用 JSX",
			"JSX 看起来类似 HTML ，我们可以看下实例:",
			"",
			"ReactDOM.render(",
			"    <h1>Hello, world!</h1>,",
			"    document.getElementById('example')",
			");",
			"我们可以在以上代码中嵌套多个 HTML 标签，需要使用一个 div 元素包裹它，实例中的 p 元素添加了自定义属性 data-myattribute，添加自定义属性需要使用 data- 前缀。",
			"",
			"React 实例",
			"ReactDOM.render(",
			"    <div>",
			"    <h1>菜鸟教程</h1>",
			"    <h2>欢迎学习 React</h2>",
			"    <p data-myattribute = \"somevalue\">这是一个很不错的 JavaScript 库!</p>",
			"    </div>",
			"    ,",
			"    document.getElementById('example')",
			");",
		],
	},
	"re-jsx独立文件": {
		"prefix": "re-jsx独立文件",
		"body": [
			"独立文件",
			"你的 React JSX 代码可以放在一个独立文件上，例如我们创建一个 helloworld_react.js 文件，代码如下：",
			"",
			"ReactDOM.render(",
			"  <h1>Hello, world!</h1>,",
			"  document.getElementById('example')",
			");",
			"然后在 HTML 文件中引入该 JS 文件：",
			"",
			"React 实例",
			"<body>",
			"  <div id=\"example\"></div>",
			"<script type=\"text/babel\" src=\"helloworld_react.js\"></script>",
			"</body>",
		],
	},
	"re-jsx表达式": {
		"prefix": "re-jsx表达式",
		"body": [
			"我们可以在 JSX 中使用 JavaScript 表达式。表达式写在花括号 {} 中。实例如下：",
			"",
			"React 实例",
			"ReactDOM.render(",
			"    <div>",
			"      <h1>{1+1}</h1>",
			"    </div>",
			"    ,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"在 JSX 中不能使用 if else 语句，但可以使用 conditional (三元运算) 表达式来替代。以下实例中如果变量 i 等于 1 浏览器将输出 true, 如果修改 i 的值，则会输出 false.",
			"",
			"React 实例",
			"ReactDOM.render(",
			"    <div>",
			"      <h1>{i == 1 ? 'True!' : 'False'}</h1>",
			"    </div>",
			"    ,",
			"    document.getElementById('example')",
			");",
		],
	},
	"re-jsx样式": {
		"prefix": "re-jsx样式",
		"body": [
			"React 推荐使用内联样式。我们可以使用 camelCase 语法来设置内联样式. React 会在指定元素数字后自动添加 px 。以下实例演示了为 h1 元素添加 myStyle 内联样式：",
			"",
			"React 实例",
			"var myStyle = {",
			"    fontSize: 100,",
			"    color: '#FF0000'",
			"};",
			"ReactDOM.render(",
			"    <h1 style = {myStyle}>菜鸟教程</h1>,",
			"    document.getElementById('example')",
			");",
		],
	},
	"re-注释": {
		"prefix": "re-注释",
		"body": [
			"注释需要写在花括号中，实例如下：",
			"",
			"React 实例",
			"ReactDOM.render(",
			"    <div>",
			"    <h1>菜鸟教程</h1>",
			"    {/*注释...*/}",
			"     </div>,",
			"    document.getElementById('example')",
			");",
		],
	},
	"re-jsx数组": {
		"prefix": "re-jsx数组",
		"body": [
			"JSX 允许在模板中插入数组，数组会自动展开所有成员：",
			"",
			"React 实例",
			"var arr = [",
			"  <h1>菜鸟教程</h1>,",
			"  <h2>学的不仅是技术，更是梦想！</h2>,",
			"];",
			"ReactDOM.render(",
			"  <div>{arr}</div>,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-组件": {
		"prefix": "re-组件",
		"body": [
			"本章节我们将讨论如何使用组件使得我们的应用更容易来管理。",
			"",
			"接下来我们封装一个输出 \"Hello World！\" 的组件，组件名为 HelloMessage：",
			"",
			"React 实例",
			"function HelloMessage(props) {",
			"    return <h1>Hello World!</h1>;",
			"}",
			" ",
			"const element = <HelloMessage />;",
			" ",
			"ReactDOM.render(",
			"    element,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"实例解析：",
			"1、我们可以使用函数定义了一个组件：",
			"",
			"function HelloMessage(props) {",
			"    return <h1>Hello World!</h1>;",
			"}",
			"你也可以使用 ES6 class 来定义一个组件:",
			"",
			"class Welcome extends React.Component {",
			"  render() {",
			"    return <h1>Hello World!</h1>;",
			"  }",
			"}",
			"2、const element = <HelloMessage /> 为用户自定义的组件。",
			"",
			"注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。",
			"",
			"如果我们需要向组件传递参数，可以使用 this.props 对象,实例如下：",
			"",
			"React 实例",
			"function HelloMessage(props) {",
			"    return <h1>Hello {props.name}!</h1>;",
			"}",
			" ",
			"const element = <HelloMessage name=\"Runoob\"/>;",
			" ",
			"ReactDOM.render(",
			"    element,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"以上实例中 name 属性通过 props.name 来获取。",
			"",
			"注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。",
			"",
			"复合组件",
			"我们可以通过创建多个组件来合成一个组件，即把组件的不同功能点进行分离。",
			"",
			"以下实例我们实现了输出网站名字和网址的组件：",
			"",
			"React 实例",
			"function Name(props) {",
			"    return <h1>网站名称：{props.name}</h1>;",
			"}",
			"function Url(props) {",
			"    return <h1>网站地址：{props.url}</h1>;",
			"}",
			"function Nickname(props) {",
			"    return <h1>网站小名：{props.nickname}</h1>;",
			"}",
			"function App() {",
			"    return (",
			"    <div>",
			"        <Name name=\"菜鸟教程\" />",
			"        <Url url=\"http://www.runoob.com\" />",
			"        <Nickname nickname=\"Runoob\" />",
			"    </div>",
			"    );",
			"}",
			" ",
			"ReactDOM.render(",
			"     <App />,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"实例中 App 组件使用了 Name、Url 和 Nickname 组件来输出对应的信息。",
		],
	},
	"re-state": {
		"prefix": "re-state",
		"body": [
			"React 把组件看成是一个状态机（State Machines）。通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致。",
			"",
			"React 里，只需更新组件的 state，然后根据新的 state 重新渲染用户界面（不要操作 DOM）。",
			"",
			"以下实例创建一个名称扩展为 React.Component 的 ES6 类，在 render() 方法中使用 this.state 来修改当前的时间。",
			"",
			"添加一个类构造函数来初始化状态 this.state，类组件应始终使用 props 调用基础构造函数。",
			"",
			"React 实例",
			"class Clock extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {date: new Date()};",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <div>",
			"        <h1>Hello, world!</h1>",
			"        <h2>现在是 {this.state.date.toLocaleTimeString()}.</h2>",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <Clock />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"接下来，我们将使Clock设置自己的计时器并每秒更新一次。",
			"",
			"将生命周期方法添加到类中",
			"在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。",
			"",
			"每当 Clock 组件第一次加载到 DOM 中的时候，我们都想生成定时器，这在 React 中被称为挂载。",
			"",
			"同样，每当 Clock 生成的这个 DOM 被移除的时候，我们也会想要清除定时器，这在 React 中被称为卸载。",
			"",
			"我们可以在组件类上声明特殊的方法，当组件挂载或卸载时，来运行一些代码：",
			"",
			"React 实例",
			"class Clock extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {date: new Date()};",
			"  }",
			" ",
			"  componentDidMount() {",
			"    this.timerID = setInterval(",
			"      () => this.tick(),",
			"      1000",
			"    );",
			"  }",
			" ",
			"  componentWillUnmount() {",
			"    clearInterval(this.timerID);",
			"  }",
			" ",
			"  tick() {",
			"    this.setState({",
			"      date: new Date()",
			"    });",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <div>",
			"        <h1>Hello, world!</h1>",
			"        <h2>现在是 {this.state.date.toLocaleTimeString()}.</h2>",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <Clock />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"实例解析：",
			"",
			"componentDidMount() 与 componentWillUnmount() 方法被称作生命周期钩子。",
			"",
			"在组件输出到 DOM 后会执行 componentDidMount() 钩子，我们就可以在这个钩子上设置一个定时器。",
			"",
			"this.timerID 为定时器的 ID，我们可以在 componentWillUnmount() 钩子中卸载定时器。",
			"",
			"代码执行顺序：",
			"",
			"当 <Clock /> 被传递给 ReactDOM.render() 时，React 调用 Clock 组件的构造函数。 由于 Clock 需要显示当前时间，所以使用包含当前时间的对象来初始化 this.state 。 我们稍后会更新此状态。",
			"",
			"React 然后调用 Clock 组件的 render() 方法。这是 React 了解屏幕上应该显示什么内容，然后 React 更新 DOM 以匹配 Clock 的渲染输出。",
			"",
			"当 Clock 的输出插入到 DOM 中时，React 调用 componentDidMount() 生命周期钩子。 在其中，Clock 组件要求浏览器设置一个定时器，每秒钟调用一次 tick()。",
			"",
			"浏览器每秒钟调用 tick() 方法。 在其中，Clock 组件通过使用包含当前时间的对象调用 setState() 来调度UI更新。 通过调用 setState() ，React 知道状态已经改变，并再次调用 render() 方法来确定屏幕上应当显示什么。 这一次，render() 方法中的 this.state.date 将不同，所以渲染输出将包含更新的时间，并相应地更新 DOM。",
			"",
			"一旦 Clock 组件被从 DOM 中移除，React 会调用 componentWillUnmount() 这个钩子函数，定时器也就会被清除。",
			"",
			"数据自顶向下流动",
			"父组件或子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心某组件是被定义为一个函数还是一个类。",
			"",
			"这就是为什么状态通常被称为局部或封装。 除了拥有并设置它的组件外，其它组件不可访问。",
			"",
			"以下实例中 FormattedDate 组件将在其属性中接收到 date 值，并且不知道它是来自 Clock 状态、还是来自 Clock 的属性、亦或手工输入：",
			"",
			"React 实例",
			"function FormattedDate(props) {",
			"  return <h2>现在是 {props.date.toLocaleTimeString()}.</h2>;",
			"}",
			" ",
			"class Clock extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {date: new Date()};",
			"  }",
			" ",
			"  componentDidMount() {",
			"    this.timerID = setInterval(",
			"      () => this.tick(),",
			"      1000",
			"    );",
			"  }",
			" ",
			"  componentWillUnmount() {",
			"    clearInterval(this.timerID);",
			"  }",
			" ",
			"  tick() {",
			"    this.setState({",
			"      date: new Date()",
			"    });",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <div>",
			"        <h1>Hello, world!</h1>",
			"        <FormattedDate date={this.state.date} />",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <Clock />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"这通常被称为自顶向下或单向数据流。 任何状态始终由某些特定组件所有，并且从该状态导出的任何数据或 UI 只能影响树中下方的组件。",
			"",
			"如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。",
			"",
			"为了表明所有组件都是真正隔离的，我们可以创建一个 App 组件，它渲染三个Clock：",
			"",
			"React 实例",
			"function FormattedDate(props) {",
			"  return <h2>现在是 {props.date.toLocaleTimeString()}.</h2>;",
			"}",
			" ",
			"class Clock extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {date: new Date()};",
			"  }",
			" ",
			"  componentDidMount() {",
			"    this.timerID = setInterval(",
			"      () => this.tick(),",
			"      1000",
			"    );",
			"  }",
			" ",
			"  componentWillUnmount() {",
			"    clearInterval(this.timerID);",
			"  }",
			" ",
			"  tick() {",
			"    this.setState({",
			"      date: new Date()",
			"    });",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <div>",
			"        <h1>Hello, world!</h1>",
			"        <FormattedDate date={this.state.date} />",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"function App() {",
			"  return (",
			"    <div>",
			"      <Clock />",
			"      <Clock />",
			"      <Clock />",
			"    </div>",
			"  );",
			"}",
			" ",
			"ReactDOM.render(<App />, document.getElementById('example'));",
			"",
			"尝试一下 »",
			"以上实例中每个 Clock 组件都建立了自己的定时器并且独立更新。",
			"",
			"在 React 应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。",
			"",
			"我们可以在有状态组件中使用无状态组件，也可以在无状态组件中使用有状态组件。",
		],
	},
	"re-Props": {
		"prefix": "re-Props",
		"body": [
			"state 和 props 主要的区别在于 props 是不可变的，而 state 可以根据与用户交互来改变。这就是为什么有些容器组件需要定义 state 来更新和修改数据。 而子组件只能通过 props 来传递数据。",
			"",
			"使用 Props",
			"以下实例演示了如何在组件中使用 props：",
			"",
			"React 实例",
			"function HelloMessage(props) {",
			"    return <h1>Hello {props.name}!</h1>;",
			"}",
			" ",
			"const element = <HelloMessage name=\"Runoob\"/>;",
			" ",
			"ReactDOM.render(",
			"    element,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"实例中 name 属性通过 props.name 来获取。",
		],
	},
	"re-默认 Props": {
		"prefix": "re-默认 Props",
		"body": [
			"你可以通过组件类的 defaultProps 属性为 props 设置默认值，实例如下：",
			"",
			"React 实例",
			"class HelloMessage extends React.Component {",
			"  render() {",
			"    return (",
			"      <h1>Hello, {this.props.name}</h1>",
			"    );",
			"  }",
			"}",
			" ",
			"HelloMessage.defaultProps = {",
			"  name: 'Runoob'",
			"};",
			" ",
			"const element = <HelloMessage/>;",
			" ",
			"ReactDOM.render(",
			"  element,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-State 和 Props": {
		"prefix": "re-State 和 Props",
		"body": [
			"State 和 Props",
			"以下实例演示了如何在应用中组合使用 state 和 props 。我们可以在父组件中设置 state， 并通过在子组件上使用 props 将其传递到子组件上。在 render 函数中, 我们设置 name 和 site 来获取父组件传递过来的数据。",
			"",
			"React 实例",
			"class WebSite extends React.Component {",
			"  constructor() {",
			"      super();",
			" ",
			"      this.state = {",
			"        name: \"菜鸟教程\",",
			"        site: \"https://www.runoob.com\"",
			"      }",
			"    }",
			"  render() {",
			"    return (",
			"      <div>",
			"        <Name name={this.state.name} />",
			"        <Link site={this.state.site} />",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			" ",
			" ",
			"class Name extends React.Component {",
			"  render() {",
			"    return (",
			"      <h1>{this.props.name}</h1>",
			"    );",
			"  }",
			"}",
			" ",
			"class Link extends React.Component {",
			"  render() {",
			"    return (",
			"      <a href={this.props.site}>",
			"        {this.props.site}",
			"      </a>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <WebSite />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-Props 验证": {
		"prefix": "re-Props 验证",
		"body": [
			"React.PropTypes 在 React v15.5 版本后已经移到了 prop-types 库。",
			"",
			"<script src=\"https://cdn.bootcss.com/prop-types/15.6.1/prop-types.js\"></script>",
			"Props 验证使用 propTypes，它可以保证我们的应用组件被正确使用，React.PropTypes 提供很多验证器 (validator) 来验证传入数据是否有效。当向 props 传入无效数据时，JavaScript 控制台会抛出警告。",
			"",
			"以下实例创建一个 Mytitle 组件，属性 title 是必须的且是字符串，非字符串类型会自动转换为字符串 ：",
			"",
			"React 16.4 实例",
			"var title = \"菜鸟教程\";",
			"// var title = 123;",
			"class MyTitle extends React.Component {",
			"  render() {",
			"    return (",
			"      <h1>Hello, {this.props.title}</h1>",
			"    );",
			"  }",
			"}",
			" ",
			"MyTitle.propTypes = {",
			"  title: PropTypes.string",
			"};",
			"ReactDOM.render(",
			"    <MyTitle title={title} />,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"React 15.4 实例",
			"var title = \"菜鸟教程\";",
			"// var title = 123;",
			"var MyTitle = React.createClass({",
			"  propTypes: {",
			"    title: React.PropTypes.string.isRequired,",
			"  },",
			" ",
			"  render: function() {",
			"     return <h1> {this.props.title} </h1>;",
			"   }",
			"});",
			"ReactDOM.render(",
			"    <MyTitle title={title} />,",
			"    document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"更多验证器说明如下：",
			"",
			"MyComponent.propTypes = {",
			"    // 可以声明 prop 为指定的 JS 基本数据类型，默认情况，这些数据是可选的",
			"   optionalArray: React.PropTypes.array,",
			"    optionalBool: React.PropTypes.bool,",
			"    optionalFunc: React.PropTypes.func,",
			"    optionalNumber: React.PropTypes.number,",
			"    optionalObject: React.PropTypes.object,",
			"    optionalString: React.PropTypes.string,",
			" ",
			"    // 可以被渲染的对象 numbers, strings, elements 或 array",
			"    optionalNode: React.PropTypes.node,",
			" ",
			"    //  React 元素",
			"    optionalElement: React.PropTypes.element,",
			" ",
			"    // 用 JS 的 instanceof 操作符声明 prop 为类的实例。",
			"    optionalMessage: React.PropTypes.instanceOf(Message),",
			" ",
			"    // 用 enum 来限制 prop 只接受指定的值。",
			"    optionalEnum: React.PropTypes.oneOf(['News', 'Photos']),",
			" ",
			"    // 可以是多个对象类型中的一个",
			"    optionalUnion: React.PropTypes.oneOfType([",
			"      React.PropTypes.string,",
			"      React.PropTypes.number,",
			"      React.PropTypes.instanceOf(Message)",
			"    ]),",
			" ",
			"    // 指定类型组成的数组",
			"    optionalArrayOf: React.PropTypes.arrayOf(React.PropTypes.number),",
			" ",
			"    // 指定类型的属性构成的对象",
			"    optionalObjectOf: React.PropTypes.objectOf(React.PropTypes.number),",
			" ",
			"    // 特定 shape 参数的对象",
			"    optionalObjectWithShape: React.PropTypes.shape({",
			"      color: React.PropTypes.string,",
			"      fontSize: React.PropTypes.number",
			"    }),",
			" ",
			"    // 任意类型加上 `isRequired` 来使 prop 不可空。",
			"    requiredFunc: React.PropTypes.func.isRequired,",
			" ",
			"    // 不可空的任意类型",
			"    requiredAny: React.PropTypes.any.isRequired,",
			" ",
			"    // 自定义验证器。如果验证失败需要返回一个 Error 对象。不要直接使用 `console.warn` 或抛异常，因为这样 `oneOfType` 会失效。",
			"    customProp: function(props, propName, componentName) {",
			"      if (!/matchme/.test(props[propName])) {",
			"        return new Error('Validation failed!');",
			"      }",
			"    }",
			"  }",
			"}",
		],
	},
	"re-React 事件处理": {
		"prefix": "re-React 事件处理",
		"body": [
			"React 元素的事件处理和 DOM 元素类似。但是有一点语法上的不同:",
			"",
			"React 事件绑定属性的命名采用驼峰式写法，而不是小写。",
			"如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM 元素的写法)",
			"HTML 通常写法是：",
			"",
			"<button onclick=\"activateLasers()\">",
			"  激活按钮",
			"</button>",
			"React 中写法为：",
			"",
			"<button onClick={activateLasers}>",
			"  激活按钮",
			"</button>",
			"在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为， 你必须明确的使用 preventDefault。",
			"",
			"例如，通常我们在 HTML 中阻止链接默认打开一个新页面，可以这样写：",
			"<a href=\"#\" onclick=\"console.log('点击链接'); return false\">",
			"  点我",
			"</a>",
			"在 React 的写法为：",
			"",
			"function ActionLink() {",
			"  function handleClick(e) {",
			"    e.preventDefault();",
			"    console.log('链接被点击');",
			"  }",
			" ",
			"  return (",
			"    <a href=\"#\" onClick={handleClick}>",
			"      点我",
			"    </a>",
			"  );",
			"}",
			"实例中 e 是一个合成事件。",
			"",
			"使用 React 的时候通常你不需要使用 addEventListener 为一个已创建的 DOM 元素添加监听器。你仅仅需要在这个元素初始渲染的时候提供一个监听器。",
			"",
			"当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。例如，下面的 Toggle 组件渲染一个让用户切换开关状态的按钮：",
		],
	},
	"re-绑定this": {
		"prefix": "re-绑定this",
		"body": [
			"class Toggle extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {isToggleOn: true};",
			" ",
			"    // 这边绑定是必要的，这样 `this` 才能在回调函数中使用",
			"    this.handleClick = this.handleClick.bind(this);",
			"  }",
			" ",
			"  handleClick() {",
			"    this.setState(prevState => ({",
			"      isToggleOn: !prevState.isToggleOn",
			"    }));",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <button onClick={this.handleClick}>",
			"        {this.state.isToggleOn ? 'ON' : 'OFF'}",
			"      </button>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <Toggle />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。",
			"",
			"这并不是 React 的特殊行为；它是函数如何在 JavaScript 中运行的一部分。通常情况下，如果你没有在方法后面添加 () ，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。",
			"",
			"如果使用 bind 让你很烦，这里有两种方式可以解决。如果你正在使用实验性的属性初始化器语法，你可以使用属性初始化器来正确的绑定回调函数：",
			"",
			"class LoggingButton extends React.Component {",
			"  // 这个语法确保了 `this` 绑定在  handleClick 中",
			"  // 这里只是一个测试",
			"  handleClick = () => {",
			"    console.log('this is:', this);",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <button onClick={this.handleClick}>",
			"        Click me",
			"      </button>",
			"    );",
			"  }",
			"}",
			"如果你没有使用属性初始化器语法，你可以在回调函数中使用 箭头函数：",
			"",
			"class LoggingButton extends React.Component {",
			"  handleClick() {",
			"    console.log('this is:', this);",
			"  }",
			" ",
			"  render() {",
			"    //  这个语法确保了 `this` 绑定在  handleClick 中",
			"    return (",
			"      <button onClick={(e) => this.handleClick(e)}>",
			"        Click me",
			"      </button>",
			"    );",
			"  }",
			"}",
			"使用这个语法有个问题就是每次 LoggingButton 渲染的时候都会创建一个不同的回调函数。在大多数情况下，这没有问题。然而如果这个回调函数作为一个属性值传入低阶组件，这些组件可能会进行额外的重新渲染。我们通常建议在构造函数中绑定或使用属性初始化器语法来避免这类性能问题。",
		],
	},
	"re-向事件处理程序传递参数": {
		"prefix": "re-向事件处理程序传递参数",
		"body": [
			"通常我们会为事件处理程序传递额外的参数。例如，若是 id 是你要删除那一行的 id，以下两种方式都可以向事件处理程序传递参数：",
			"",
			"<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>",
			"<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>上述两种方式是等价的。",
			"上面两个例子中，参数 e 作为 React 事件对象将会被作为第二个参数进行传递。通过箭头函数的方式，事件对象必须显式的进行传递，但是通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。",
			"",
			"值得注意的是，通过 bind 方式向监听函数传参，在类组件中定义的监听函数，事件对象 e 要排在所传递参数的后面，例如:",
			"",
			"class Popper extends React.Component{",
			"    constructor(){",
			"        super();",
			"        this.state = {name:'Hello world!'};",
			"    }",
			"    ",
			"    preventPop(name, e){    //事件对象e要放在最后",
			"        e.preventDefault();",
			"        alert(name);",
			"    }",
			"    ",
			"    render(){",
			"        return (",
			"            <div>",
			"                <p>hello</p>",
			"                {/* 通过 bind() 方法传递参数。 */}",
			"                <a href=\"https://reactjs.org\" onClick={this.preventPop.bind(this,this.state.name)}>Click</a>",
			"            </div>",
			"        );",
			"    }",
			"}",
		],
	},
	"re-React 条件渲染": {
		"prefix": "re-React 条件渲染",
		"body": [
			"在 React 中，你可以创建不同的组件来封装各种你需要的行为。然后还可以根据应用的状态变化只渲染其中的一部分。",
			"",
			"React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或条件运算符来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。",
			"",
			"先来看两个组件:",
			"",
			"function UserGreeting(props) {",
			"  return <h1>欢迎回来!</h1>;",
			"}",
			"",
			"function GuestGreeting(props) {",
			"  return <h1>请先注册。</h1>;",
			"}",
			"我们将创建一个 Greeting 组件，它会根据用户是否登录来显示其中之一：",
			"",
			"React 实例",
			"function Greeting(props) {",
			"  const isLoggedIn = props.isLoggedIn;",
			"  if (isLoggedIn) {",
			"    return <UserGreeting />;",
			"  }",
			"  return <GuestGreeting />;",
			"}",
			" ",
			"ReactDOM.render(",
			"  // 尝试修改 isLoggedIn={true}:",
			"  <Greeting isLoggedIn={false} />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-元素变量": {
		"prefix": "re-元素变量",
		"body": [
			"你可以使用变量来储存元素。它可以帮助你有条件的渲染组件的一部分，而输出的其他部分不会更改。",
			"",
			"在下面的例子中，我们将要创建一个名为 LoginControl 的有状态的组件。",
			"",
			"它会根据当前的状态来渲染 <LoginButton /> 或 <LogoutButton />，它也将渲染前面例子中的 <Greeting />。",
			"",
			"React 实例",
			"class LoginControl extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.handleLoginClick = this.handleLoginClick.bind(this);",
			"    this.handleLogoutClick = this.handleLogoutClick.bind(this);",
			"    this.state = {isLoggedIn: false};",
			"  }",
			" ",
			"  handleLoginClick() {",
			"    this.setState({isLoggedIn: true});",
			"  }",
			" ",
			"  handleLogoutClick() {",
			"    this.setState({isLoggedIn: false});",
			"  }",
			" ",
			"  render() {",
			"    const isLoggedIn = this.state.isLoggedIn;",
			" ",
			"    let button = null;",
			"    if (isLoggedIn) {",
			"      button = <LogoutButton onClick={this.handleLogoutClick} />;",
			"    } else {",
			"      button = <LoginButton onClick={this.handleLoginClick} />;",
			"    }",
			" ",
			"    return (",
			"      <div>",
			"        <Greeting isLoggedIn={isLoggedIn} />",
			"        {button}",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <LoginControl />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-与运算符 &&": {
		"prefix": "re-与运算符 &&",
		"body": [
			"与运算符 &&",
			"你可以通过用花括号包裹代码在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &&，它可以方便地条件渲染一个元素。",
			"",
			"React 实例",
			"function Mailbox(props) {",
			"  const unreadMessages = props.unreadMessages;",
			"  return (",
			"    <div>",
			"      <h1>Hello!</h1>",
			"      {unreadMessages.length > 0 &&",
			"        <h2>",
			"          您有 {unreadMessages.length} 条未读信息。",
			"        </h2>",
			"      }",
			"    </div>",
			"  );",
			"}",
			" ",
			"const messages = ['React', 'Re: React', 'Re:Re: React'];",
			"ReactDOM.render(",
			"  <Mailbox unreadMessages={messages} />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"在 JavaScript 中，true && expression 总是返回 expression，而 false && expression 总是返回 false。",
			"",
			"因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。",
		],
	},
	"re-三目运算符": {
		"prefix": "re-三目运算符",
		"body": [
			"条件渲染的另一种方法是使用 JavaScript 的条件运算符:",
			"",
			"condition ? true : false。",
			"在下面的例子中，我们用它来有条件的渲染一小段文本。",
			"",
			"render() { const isLoggedIn = this.state.isLoggedIn; return (",
			"The user is {isLoggedIn ? 'currently' : 'not'} logged in.",
			"); } 同样它也可以用在较大的表达式中，虽然不太直观：",
			"render() {",
			"  const isLoggedIn = this.state.isLoggedIn;",
			"  return (",
			"    <div>",
			"      {isLoggedIn ? (",
			"        <LogoutButton onClick={this.handleLogoutClick} />",
			"      ) : (",
			"        <LoginButton onClick={this.handleLoginClick} />",
			"      )}",
			"    </div>",
			"  );",
			"}",
		],
	},
	"re-阻止组件渲染": {
		"prefix": "re-阻止组件渲染",
		"body": [
			"在极少数情况下，你可能希望隐藏组件，即使它被其他组件渲染。让 render 方法返回 null 而不是它的渲染结果即可实现。",
			"",
			"在下面的例子中，<WarningBanner /> 根据属性 warn 的值条件渲染。如果 warn 的值是 false，则组件不会渲染：",
			"",
			"React 实例",
			"function WarningBanner(props) {",
			"  if (!props.warn) {",
			"    return null;",
			"  }",
			" ",
			"  return (",
			"    <div className=\"warning\">",
			"      警告!",
			"    </div>",
			"  );",
			"}",
			" ",
			"class Page extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {showWarning: true}",
			"    this.handleToggleClick = this.handleToggleClick.bind(this);",
			"  }",
			" ",
			"  handleToggleClick() {",
			"    this.setState(prevState => ({",
			"      showWarning: !prevState.showWarning",
			"    }));",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <div>",
			"        <WarningBanner warn={this.state.showWarning} />",
			"        <button onClick={this.handleToggleClick}>",
			"          {this.state.showWarning ? '隐藏' : '显示'}",
			"        </button>",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <Page />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"组件的 render 方法返回 null 并不会影响该组件生命周期方法的回调。例如，componentWillUpdate 和 componentDidUpdate 依然可以被调用。",
		],
	},
	"re-React 列表 & Keys": {
		"prefix": "re-React 列表 & Keys",
		"body": [
			"我们可以使用 JavaScript 的 map() 方法来创建列表。",
			"",
			"React 实例",
			"使用 map() 方法遍历数组生成了一个 1 到 5 的数字列表:",
			"",
			"const numbers = [1, 2, 3, 4, 5];",
			"const listItems = numbers.map((numbers) =>",
			"  <li>{numbers}</li>",
			");",
			" ",
			"ReactDOM.render(",
			"  <ul>{listItems}</ul>,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"我们可以将以上实例重构成一个组件，组件接收数组参数，每个列表元素分配一个 key，不然会出现警告 a key should be provided for list items，意思就是需要包含 key：",
			"",
			"React 实例",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    <li key={number.toString()}>",
			"      {number}",
			"    </li>",
			"  );",
			"  return (",
			"    <ul>{listItems}</ul>",
			"  );",
			"}",
			" ",
			"const numbers = [1, 2, 3, 4, 5];",
			"ReactDOM.render(",
			"  <NumberList numbers={numbers} />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-Keys": {
		"prefix": "re-Keys",
		"body": [
			"Keys 可以在 DOM 中的某些元素被增加或删除的时候帮助 React 识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。",
			"",
			"const numbers = [1, 2, 3, 4, 5];",
			"const listItems = numbers.map((number) =>",
			"  <li key={number.toString()}>",
			"    {number}",
			"  </li>",
			");",
			"一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的 id 作为元素的 key:",
			"",
			"const todoItems = todos.map((todo) =>",
			"  <li key={todo.id}>",
			"    {todo.text}",
			"  </li>",
			");",
			"当元素没有确定的 id 时，你可以使用他的序列号索引 index 作为 key：",
			"",
			"const todoItems = todos.map((todo, index) =>",
			"  // 只有在没有确定的 id 时使用",
			"  <li key={index}>",
			"    {todo.text}",
			"  </li>",
			");",
			"如果列表可以重新排序，我们不建议使用索引来进行排序，因为这会导致渲染变得很慢。",
		],
	},
	"re-用keys提取组件": {
		"prefix": "re-用keys提取组件",
		"body": [
			"元素的 key 只有在它和它的兄弟节点对比时才有意义。",
			"",
			"比方说，如果你提取出一个 ListItem 组件，你应该把 key 保存在数组中的这个 <ListItem /> 元素上，而不是放在 ListItem 组件中的 <li> 元素上。",
			"",
			"错误的示范",
			"function ListItem(props) {",
			"  const value = props.value;",
			"  return (",
			"    // 错啦！你不需要在这里指定key:",
			"    <li key={value.toString()}>",
			"      {value}",
			"    </li>",
			"  );",
			"}",
			"",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    //错啦！元素的key应该在这里指定：",
			"    <ListItem value={number} />",
			"  );",
			"  return (",
			"    <ul>",
			"      {listItems}",
			"    </ul>",
			"  );",
			"}",
			"",
			"const numbers = [1, 2, 3, 4, 5];",
			"ReactDOM.render(",
			"  <NumberList numbers={numbers} />,",
			"  document.getElementById('example')",
			");",
			"key的正确使用方式",
			"React 实例",
			"function ListItem(props) {",
			"  // 对啦！这里不需要指定key:",
			"  return <li>{props.value}</li>;",
			"}",
			" ",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    // 又对啦！key应该在数组的上下文中被指定",
			"    <ListItem key={number.toString()}",
			"              value={number} />",
			" ",
			"  );",
			"  return (",
			"    <ul>",
			"      {listItems}",
			"    </ul>",
			"  );",
			"}",
			" ",
			"const numbers = [1, 2, 3, 4, 5];",
			"ReactDOM.render(",
			"  <NumberList numbers={numbers} />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"当你在 map() 方法的内部调用元素时，你最好随时记得为每一个元素加上一个独一无二的 key。",
		],
	},
	"re-元素的 key 在他的兄弟元素之间应该唯一": {
		"prefix": "re-元素的 key 在他的兄弟元素之间应该唯一",
		"body": [
			"元素的 key 在他的兄弟元素之间应该唯一",
			"数组元素中使用的 key 在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键。",
			"",
			"React 实例",
			"function Blog(props) {",
			"  const sidebar = (",
			"    <ul>",
			"      {props.posts.map((post) =>",
			"        <li key={post.id}>",
			"          {post.title}",
			"        </li>",
			"      )}",
			"    </ul>",
			"  );",
			"  const content = props.posts.map((post) =>",
			"    <div key={post.id}>",
			"      <h3>{post.title}</h3>",
			"      <p>{post.content}</p>",
			"    </div>",
			"  );",
			"  return (",
			"    <div>",
			"      {sidebar}",
			"      <hr />",
			"      {content}",
			"    </div>",
			"  );",
			"}",
			" ",
			"const posts = [",
			"  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},",
			"  {id: 2, title: 'Installation', content: 'You can install React from npm.'}",
			"];",
			"ReactDOM.render(",
			"  <Blog posts={posts} />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"key 会作为给 React 的提示，但不会传递给你的组件。如果您的组件中需要使用和 key 相同的值，请将其作为属性传递：",
			"",
			"const content = posts.map((post) =>",
			"  <Post",
			"    key={post.id}",
			"    id={post.id}",
			"    title={post.title} />",
			");",
			"上面例子中，Post 组件可以读出 props.id，但是不能读出 props.key。",
		],
	},
	"re-在 jsx 中嵌入 map()": {
		"prefix": "re-在 jsx 中嵌入 map()",
		"body": [
			"在上面的例子中，我们声明了一个单独的 listItems 变量并将其包含在 JSX 中:",
			"",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    <ListItem key={number.toString()}",
			"              value={number} />",
			"",
			"  );",
			"  return (",
			"    <ul>",
			"      {listItems}",
			"    </ul>",
			"  );",
			"}",
			"JSX 允许在大括号中嵌入任何表达式，所以我们可以在 map() 中这样使用：",
			"",
			"React 实例",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  return (",
			"    <ul>",
			"      {numbers.map((number) =>",
			"        <ListItem key={number.toString()}",
			"                  value={number} />",
			" ",
			"      )}",
			"    </ul>",
			"  );",
			"}",
			"",
			"尝试一下 »",
			"这么做有时可以使你的代码更清晰，但有时这种风格也会被滥用。就像在 JavaScript 中一样，何时需要为了可读性提取出一个变量，这完全取决于你。但请记住，如果一个 map() 嵌套了太多层级，那你就可以提取出组件。",
		],
	},
	"re-设置状态:setState": {
		"prefix": "re-设置状态:setState",
		"body": [
			"setState(object nextState[, function callback])",
			"参数说明",
			"nextState，将要设置的新状态，该状态会和当前的state合并",
			"callback，可选参数，回调函数。该函数会在setState设置成功，且组件重新渲染后调用。",
			"合并nextState和当前state，并重新渲染组件。setState是React事件处理函数中和请求回调函数中触发UI更新的主要方法。",
			"",
			"关于setState",
			"不能在组件内部通过this.state修改状态，因为该状态会在调用setState()后被替换。",
			"",
			"setState()并不会立即改变this.state，而是创建一个即将处理的state。setState()并不一定是同步的，为了提升性能React会批量执行state和DOM渲染。",
			"",
			"setState()总是会触发一次组件重绘，除非在shouldComponentUpdate()中实现了一些条件渲染逻辑。",
			"",
			"实例",
			"React 实例",
			"class Counter extends React.Component{",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {clickCount: 0};",
			"      this.handleClick = this.handleClick.bind(this);",
			"  }",
			"  ",
			"  handleClick() {",
			"    this.setState(function(state) {",
			"      return {clickCount: state.clickCount + 1};",
			"    });",
			"  }",
			"  render () {",
			"    return (<h2 onClick={this.handleClick}>点我！点击次数为: {this.state.clickCount}</h2>);",
			"  }",
			"}",
			"ReactDOM.render(",
			"  <Counter />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"实例中通过点击 h2 标签来使得点击计数器加 1。",
		],
	},
	"re-替换状态：replaceState": {
		"prefix": "re-替换状态：replaceState",
		"body": [
			"replaceState(object nextState[, function callback])",
			"nextState，将要设置的新状态，该状态会替换当前的state。",
			"callback，可选参数，回调函数。该函数会在replaceState设置成功，且组件重新渲染后调用。",
			"replaceState()方法与setState()类似，但是方法只会保留nextState中状态，原state不在nextState中的状态都会被删除。",
		],
	},
	"re-设置属性：setProps": {
		"prefix": "re-设置属性：setProps",
		"body": [
			"setProps(object nextProps[, function callback])",
			"nextProps，将要设置的新属性，该状态会和当前的props合并",
			"callback，可选参数，回调函数。该函数会在setProps设置成功，且组件重新渲染后调用。",
			"设置组件属性，并重新渲染组件。",
			"",
			"props相当于组件的数据流，它总是会从父组件向下传递至所有的子组件中。当和一个外部的JavaScript应用集成时，我们可能会需要向组件传递数据或通知React.render()组件需要重新渲染，可以使用setProps()。",
			"",
			"更新组件，我可以在节点上再次调用React.render()，也可以通过setProps()方法改变组件属性，触发组件重新渲染。",
		],
	},
	"re-替换属性：replaceProps": {
		"prefix": "re-替换属性：replaceProps",
		"body": [
			"replaceProps(object nextProps[, function callback])",
			"nextProps，将要设置的新属性，该属性会替换当前的props。",
			"callback，可选参数，回调函数。该函数会在replaceProps设置成功，且组件重新渲染后调用。",
			"replaceProps()方法与setProps类似，但它会删除原有 props。",
		],
	},
	"re-强制更新：forceUpdate": {
		"prefix": "re-强制更新：forceUpdate",
		"body": [
			"forceUpdate([function callback])",
			"参数说明",
			"callback，可选参数，回调函数。该函数会在组件render()方法调用后调用。",
			"forceUpdate()方法会使组件调用自身的render()方法重新渲染组件，组件的子组件也会调用自己的render()。但是，组件重新渲染时，依然会读取this.props和this.state，如果状态没有改变，那么React只会更新DOM。",
			"",
			"forceUpdate()方法适用于this.props和this.state之外的组件重绘（如：修改了this.state后），通过该方法通知React需要调用render()",
			"",
			"一般来说，应该尽量避免使用forceUpdate()，而仅从this.props和this.state中读取状态并由React触发render()调用。",
		],
	},
	"re-获取DOM节点：findDOMNode": {
		"prefix": "re-获取DOM节点：findDOMNode",
		"body": [
			"DOMElement findDOMNode()",
			"返回值：DOM元素DOMElement",
			"如果组件已经挂载到DOM中，该方法返回对应的本地浏览器 DOM 元素。当render返回null 或 false时，this.findDOMNode()也会返回null。从DOM 中读取值的时候，该方法很有用，如：获取表单字段的值和做一些 DOM 操作。",
		],
	},
	"re-判断组件挂载状态：isMounted": {
		"prefix": "re-判断组件挂载状态：isMounted",
		"body": [
			"bool isMounted()",
			"返回值：true或false，表示组件是否已挂载到DOM中",
			"isMounted()方法用于判断组件是否已挂载到DOM中。可以使用该方法保证了setState()和forceUpdate()在异步场景下的调用不会出错。",
			"",
			"本文参考：http://itbilu.com/javascript/react/EkACBdqKe.html",
		],
	},
	"re-React 组件生命周期": {
		"prefix": "re-React 组件生命周期",
		"body": [
			"在本章节中我们将讨论 React 组件的生命周期。",
			"",
			"组件的生命周期可分成三个状态：",
			"",
			"Mounting：已插入真实 DOM",
			"Updating：正在被重新渲染",
			"Unmounting：已移出真实 DOM",
			"生命周期的方法有：",
			"",
			"componentWillMount 在渲染前调用,在客户端也在服务端。",
			"",
			"componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送AJAX请求等操作(防止异步操作阻塞UI)。",
			"",
			"componentWillReceiveProps 在组件接收到一个新的 prop (更新后)时被调用。这个方法在初始化render时不会被调用。",
			"",
			"shouldComponentUpdate 返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用。",
			"可以在你确认不需要更新组件时使用。",
			"",
			"componentWillUpdate在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用。",
			"",
			"componentDidUpdate 在组件完成更新后立即调用。在初始化时不会被调用。",
			"",
			"componentWillUnmount在组件从 DOM 中移除之前立刻被调用。",
			"",
			"这些方法的详细说明，可以参考官方文档。",
			"",
			"以下实例在 Hello 组件加载以后，通过 componentDidMount 方法设置一个定时器，每隔100毫秒重新设置组件的透明度，并重新渲染：",
			"",
			"React 实例",
			"class Hello extends React.Component {",
			" ",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {opacity: 1.0};",
			"  }",
			" ",
			"  componentDidMount() {",
			"    this.timer = setInterval(function () {",
			"      var opacity = this.state.opacity;",
			"      opacity -= .05;",
			"      if (opacity < 0.1) {",
			"        opacity = 1.0;",
			"      }",
			"      this.setState({",
			"        opacity: opacity",
			"      });",
			"    }.bind(this), 100);",
			"  }",
			" ",
			"  render () {",
			"    return (",
			"      <div style={{opacity: this.state.opacity}}>",
			"        Hello {this.props.name}",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <Hello name=\"world\"/>,",
			"  document.body",
			");",
			"",
			"尝试一下 »",
			"以下实例初始化 state ， setNewnumber 用于更新 state。所有生命周期在 Content 组件中。",
			"",
			"React 实例",
			"class Button extends React.Component {",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {data: 0};",
			"      this.setNewNumber = this.setNewNumber.bind(this);",
			"  }",
			"  ",
			"  setNewNumber() {",
			"    this.setState({data: this.state.data + 1})",
			"  }",
			"  render() {",
			"      return (",
			"         <div>",
			"            <button onClick = {this.setNewNumber}>INCREMENT</button>",
			"            <Content myNumber = {this.state.data}></Content>",
			"         </div>",
			"      );",
			"    }",
			"}",
			" ",
			" ",
			"class Content extends React.Component {",
			"  componentWillMount() {",
			"      console.log('Component WILL MOUNT!')",
			"  }",
			"  componentDidMount() {",
			"       console.log('Component DID MOUNT!')",
			"  }",
			"  componentWillReceiveProps(newProps) {",
			"        console.log('Component WILL RECEIVE PROPS!')",
			"  }",
			"  shouldComponentUpdate(newProps, newState) {",
			"        return true;",
			"  }",
			"  componentWillUpdate(nextProps, nextState) {",
			"        console.log('Component WILL UPDATE!');",
			"  }",
			"  componentDidUpdate(prevProps, prevState) {",
			"        console.log('Component DID UPDATE!')",
			"  }",
			"  componentWillUnmount() {",
			"         console.log('Component WILL UNMOUNT!')",
			"  }",
			" ",
			"    render() {",
			"      return (",
			"        <div>",
			"          <h3>{this.props.myNumber}</h3>",
			"        </div>",
			"      );",
			"    }",
			"}",
			"ReactDOM.render(",
			"   <div>",
			"      <Button />",
			"   </div>,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-React AJAX": {
		"prefix": "re-React AJAX",
		"body": [
			"React 组件的数据可以通过 componentDidMount 方法中的 Ajax 来获取，当从服务端获取数据时可以将数据存储在 state 中，再用 this.setState 方法重新渲染 UI。",
			"",
			"当使用异步加载数据时，在组件卸载前使用 componentWillUnmount 来取消未完成的请求。",
			"",
			"以下实例演示了获取 Github 用户最新 gist 共享描述:",
			"",
			"React 实例",
			"class UserGist extends React.Component {",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {username: '', lastGistUrl: ''};",
			"  }",
			" ",
			" ",
			"  componentDidMount() {",
			"    this.serverRequest = $.get(this.props.source, function (result) {",
			"      var lastGist = result[0];",
			"      this.setState({",
			"        username: lastGist.owner.login,",
			"        lastGistUrl: lastGist.html_url",
			"      });",
			"    }.bind(this));",
			"  }",
			" ",
			"  componentWillUnmount() {",
			"    this.serverRequest.abort();",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <div>",
			"        {this.state.username} 用户最新的 Gist 共享地址：",
			"        <a href={this.state.lastGistUrl}>{this.state.lastGistUrl}</a>",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <UserGist source=\"https://api.github.com/users/octocat/gists\" />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"以上代码使用 jQuery 完成 Ajax 请求。",
		],
	},
	"re-input表单": {
		"prefix": "re-input表单",
		"body": [
			"本章节我们将讨论如何在 React 中使用表单。",
			"",
			"HTML 表单元素与 React 中的其他 DOM 元素有所不同,因为表单元素生来就保留一些内部状态。",
			"",
			"在 HTML 当中，像 <input>, <textarea>, 和 <select> 这类表单元素会维持自身状态，并根据用户输入进行更新。但在React中，可变的状态通常保存在组件的状态属性中，并且只能用 setState() 方法进行更新。",
			"",
			"一个简单的实例",
			"在实例中我们设置了输入框 input 值 value = {this.state.data}。在输入框值发生变化时我们可以更新 state。我们可以使用 onChange 事件来监听 input 的变化，并修改 state。",
			"",
			"React 实例",
			"class HelloMessage extends React.Component {",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {value: 'Hello Runoob!'};",
			"      this.handleChange = this.handleChange.bind(this);",
			"  }",
			" ",
			"  handleChange(event) {",
			"    this.setState({value: event.target.value});",
			"  }",
			"  render() {",
			"    var value = this.state.value;",
			"    return <div>",
			"            <input type=\"text\" value={value} onChange={this.handleChange} /> ",
			"            <h4>{value}</h4>",
			"           </div>;",
			"  }",
			"}",
			"ReactDOM.render(",
			"  <HelloMessage />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"上面的代码将渲染出一个值为 Hello Runoob! 的 input 元素，并通过 onChange 事件响应更新用户输入的值。",
			"",
			"实例 2",
			"在以下实例中我们将为大家演示如何在子组件上使用表单。 onChange 方法将触发 state 的更新并将更新的值传递到子组件的输入框的 value 上来重新渲染界面。",
			"",
			"你需要在父组件通过创建事件句柄 (handleChange) ，并作为 prop (updateStateProp) 传递到你的子组件上。",
			"",
			"React 实例",
			"class Content extends React.Component {",
			"  render() {",
			"    return  <div>",
			"            <input type=\"text\" value={this.props.myDataProp} onChange={this.props.updateStateProp} /> ",
			"            <h4>{this.props.myDataProp}</h4>",
			"            </div>;",
			"  }",
			"}",
			"class HelloMessage extends React.Component {",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {value: 'Hello Runoob!'};",
			"      this.handleChange = this.handleChange.bind(this);",
			"  }",
			" ",
			"  handleChange(event) {",
			"    this.setState({value: event.target.value});",
			"  }",
			"  render() {",
			"    var value = this.state.value;",
			"    return <div>",
			"            <Content myDataProp = {value} ",
			"              updateStateProp = {this.handleChange}></Content>",
			"           </div>;",
			"  }",
			"}",
			"ReactDOM.render(",
			"  <HelloMessage />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-Select 下拉菜单": {
		"prefix": "re-Select 下拉菜单",
		"body": [
			"Select 下拉菜单",
			"在 React 中，不使用 selected 属性，而在根 select 标签上用 value 属性来表示选中项。",
			"",
			"React 实例",
			"class FlavorForm extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {value: 'coconut'};",
			" ",
			"    this.handleChange = this.handleChange.bind(this);",
			"    this.handleSubmit = this.handleSubmit.bind(this);",
			"  }",
			" ",
			"  handleChange(event) {",
			"    this.setState({value: event.target.value});",
			"  }",
			" ",
			"  handleSubmit(event) {",
			"    alert('Your favorite flavor is: ' + this.state.value);",
			"    event.preventDefault();",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <form onSubmit={this.handleSubmit}>",
			"        <label>",
			"          选择您最喜欢的网站",
			"          <select value={this.state.value} onChange={this.handleChange}>",
			"            <option value=\"gg\">Google</option>",
			"            <option value=\"rn\">Runoob</option>",
			"            <option value=\"tb\">Taobao</option>",
			"            <option value=\"fb\">Facebook</option>",
			"          </select>",
			"        </label>",
			"        <input type=\"submit\" value=\"提交\" />",
			"      </form>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <FlavorForm />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-多个表单": {
		"prefix": "re-多个表单",
		"body": [
			"当你有处理多个 input 元素时，你可以通过给每个元素添加一个 name 属性，来让处理函数根据 event.target.name 的值来选择做什么。",
			"",
			"React 实例",
			"class Reservation extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {",
			"      isGoing: true,",
			"      numberOfGuests: 2",
			"    };",
			" ",
			"    this.handleInputChange = this.handleInputChange.bind(this);",
			"  }",
			" ",
			"  handleInputChange(event) {",
			"    const target = event.target;",
			"    const value = target.type === 'checkbox' ? target.checked : target.value;",
			"    const name = target.name;",
			" ",
			"    this.setState({",
			"      [name]: value",
			"    });",
			"  }",
			" ",
			"  render() {",
			"    return (",
			"      <form>",
			"        <label>",
			"          是否离开:",
			"          <input",
			"            name=\"isGoing\"",
			"            type=\"checkbox\"",
			"            checked={this.state.isGoing}",
			"            onChange={this.handleInputChange} />",
			"        </label>",
			"        <br />",
			"        <label>",
			"          访客数:",
			"          <input",
			"            name=\"numberOfGuests\"",
			"            type=\"number\"",
			"            value={this.state.numberOfGuests}",
			"            onChange={this.handleInputChange} />",
			"        </label>",
			"      </form>",
			"    );",
			"  }",
			"}",
		],
	},
	"re-子组件中更新父组件的 state ": {
		"prefix": "re-子组件中更新父组件的 state ",
		"body": [
			"以下实例演示通过 onClick 事件来修改数据：",
			"",
			"React 实例",
			"class HelloMessage extends React.Component {",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {value: 'Hello Runoob!'};",
			"      this.handleChange = this.handleChange.bind(this);",
			"  }",
			"  ",
			"  handleChange(event) {",
			"    this.setState({value: '菜鸟教程'})",
			"  }",
			"  render() {",
			"    var value = this.state.value;",
			"    return <div>",
			"            <button onClick={this.handleChange}>点我</button>",
			"            <h4>{value}</h4>",
			"           </div>;",
			"  }",
			"}",
			"ReactDOM.render(",
			"  <HelloMessage />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"当你需要从子组件中更新父组件的 state 时，你需要在父组件通过创建事件句柄 (handleChange) ，并作为 prop (updateStateProp) 传递到你的子组件上。实例如下：",
			"",
			"React 实例",
			"class Content extends React.Component {",
			"  render() {",
			"    return  <div>",
			"              <button onClick = {this.props.updateStateProp}>点我</button>",
			"              <h4>{this.props.myDataProp}</h4>",
			"           </div>",
			"  }",
			"}",
			"class HelloMessage extends React.Component {",
			"  constructor(props) {",
			"      super(props);",
			"      this.state = {value: 'Hello Runoob!'};",
			"      this.handleChange = this.handleChange.bind(this);",
			"  }",
			"  handleChange(event) {",
			"    this.setState({value: '菜鸟教程'})",
			"  }",
			"  render() {",
			"    var value = this.state.value;",
			"    return <div>",
			"            <Content myDataProp = {value} ",
			"              updateStateProp = {this.handleChange}></Content>",
			"           </div>;",
			"  }",
			"}",
			"ReactDOM.render(",
			"  <HelloMessage />,",
			"  document.getElementById('example')",
			");",
		],
	},
	"re-React Refs": {
		"prefix": "re-React Refs",
		"body": [
			"React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。",
			"",
			"这个特殊的属性允许你引用 render() 返回的相应的支撑实例（ backing instance ）。这样就可以确保在任何时间总是拿到正确的实例。",
			"",
			"使用方法",
			"绑定一个 ref 属性到 render 的返回值上：",
			"",
			"<input ref=\"myInput\" />",
			"在其它代码中，通过 this.refs 获取支撑实例:",
			"",
			"var input = this.refs.myInput;",
			"var inputValue = input.value;",
			"var inputRect = input.getBoundingClientRect();",
			"完整实例",
			"你可以通过使用 this 来获取当前 React 组件，或使用 ref 来获取组件的引用，实例如下：",
			"",
			"React 实例",
			"class MyComponent extends React.Component {",
			"  handleClick() {",
			"    // 使用原生的 DOM API 获取焦点",
			"    this.refs.myInput.focus();",
			"  }",
			"  render() {",
			"    //  当组件插入到 DOM 后，ref 属性添加一个组件的引用于到 this.refs",
			"    return (",
			"      <div>",
			"        <input type=\"text\" ref=\"myInput\" />",
			"        <input",
			"          type=\"button\"",
			"          value=\"点我输入框获取焦点\"",
			"          onClick={this.handleClick.bind(this)}",
			"        />",
			"      </div>",
			"    );",
			"  }",
			"}",
			" ",
			"ReactDOM.render(",
			"  <MyComponent />,",
			"  document.getElementById('example')",
			");",
			"",
			"尝试一下 »",
			"实例中，我们获取了输入框的支撑实例的引用，子点击按钮后输入框获取焦点。",
			"",
			"我们也可以使用 getDOMNode()方法获取DOM元素",
		],
	},
	"re-JSX 简介": {
		"prefix": "re-JSX 简介",
		"body": [
			"考虑如下变量声明：",
			"",
			"const element = <h1>Hello, world!</h1>;",
			"这个有趣的标签语法既不是字符串也不是 HTML。",
			"",
			"它被称为 JSX，是一个 JavaScript 的语法扩展。我们建议在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式。JSX 可能会使人联想到模版语言，但它具有 JavaScript 的全部功能。",
			"",
			"JSX 可以生成 React “元素”。我们将在下一章节中探讨如何将这些元素渲染为 DOM。下面我们看下学习 JSX 所需的基础知识。",
		],
	},
	"re-在 JSX 中嵌入表达式": {
		"prefix": "re-在 JSX 中嵌入表达式",
		"body": [
			"在下面的例子中，我们声明了一个名为 name 的变量，然后在 JSX 中使用它，并将它包裹在大括号中：",
			"",
			"const name = 'Josh Perez';",
			"const element = <h1>Hello, {name}</h1>;",
			"",
			"ReactDOM.render(",
			"  element,",
			"  document.getElementById('root')",
			");",
			"在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式。例如，2 + 2，user.firstName 或 formatName(user) 都是有效的 JavaScript 表达式。",
			"",
			"在下面的示例中，我们将调用 JavaScript 函数 formatName(user) 的结果，并将结果嵌入到 <h1> 元素中。",
			"",
			"function formatName(user) {",
			"  return user.firstName + ' ' + user.lastName;",
			"}",
			"",
			"const user = {",
			"  firstName: 'Harper',",
			"  lastName: 'Perez'",
			"};",
			"",
			"const element = (",
			"  <h1>",
			"    Hello, {formatName(user)}!",
			"  </h1>",
			");",
			"",
			"ReactDOM.render(",
			"  element,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"为了便于阅读，我们会将 JSX 拆分为多行。同时，我们建议将内容包裹在括号中，虽然这样做不是强制要求的，但是这可以避免遇到自动插入分号陷阱。",
		],
	},
	"re-JSX 也是一个表达式": {
		"prefix": "re-JSX 也是一个表达式",
		"body": [
			"在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。",
			"",
			"也就是说，你可以在 if 语句和 for 循环的代码块中使用 JSX，将 JSX 赋值给变量，把 JSX 当作参数传入，以及从函数中返回 JSX：",
			"",
			"function getGreeting(user) {",
			"  if (user) {",
			"    return <h1>Hello, {formatName(user)}!</h1>;",
			"  }",
			"  return <h1>Hello, Stranger.</h1>;",
			"}",
		],
	},
	"re-JSX 特定属性": {
		"prefix": "re-JSX 特定属性",
		"body": [
			"你可以通过使用引号，来将属性值指定为字符串字面量：",
			"",
			"const element = <div tabIndex=\"0\"></div>;",
			"也可以使用大括号，来在属性值中插入一个 JavaScript 表达式：",
			"",
			"const element = <img src={user.avatarUrl}></img>;",
			"在属性中嵌入 JavaScript 表达式时，不要在大括号外面加上引号。你应该仅使用引号（对于字符串值）或大括号（对于表达式）中的一个，对于同一属性不能同时使用这两种符号。",
			"",
			"警告：",
			"",
			"因为 JSX 语法上更接近 JavaScript 而不是 HTML，所以 React DOM 使用 camelCase（小驼峰命名）来定义属性的名称，而不使用 HTML 属性名称的命名约定。",
			"",
			"例如，JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex。",
		],
	},
	"re-使用 JSX 指定子元素": {
		"prefix": "re-使用 JSX 指定子元素",
		"body": [
			"假如一个标签里面没有内容，你可以使用 /> 来闭合标签，就像 XML 语法一样：",
			"",
			"const element = <img src={user.avatarUrl} />;",
			"JSX 标签里能够包含很多子元素:",
			"",
			"const element = (",
			"  <div>",
			"    <h1>Hello!</h1>",
			"    <h2>Good to see you here.</h2>",
			"  </div>",
			");",
		],
	},
	"re-JSX 防止注入攻击": {
		"prefix": "re-JSX 防止注入攻击",
		"body": [
			"你可以安全地在 JSX 当中插入用户输入内容：",
			"",
			"const title = response.potentiallyMaliciousInput;",
			"// 直接使用是安全的：",
			"const element = <h1>{title}</h1>;",
			"React DOM 在渲染所有输入内容之前，默认会进行转义。它可以确保在你的应用中，永远不会注入那些并非自己明确编写的内容。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止 XSS（cross-site-scripting, 跨站脚本）攻击。",
		],
	},
	"re-JSX 表示对象": {
		"prefix": "re-JSX 表示对象",
		"body": [
			"Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。",
			"",
			"以下两种示例代码完全等效：",
			"",
			"const element = (",
			"  <h1 className=\"greeting\">",
			"    Hello, world!",
			"  </h1>",
			");",
			"const element = React.createElement(",
			"  'h1',",
			"  {className: 'greeting'},",
			"  'Hello, world!'",
			");",
			"React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：",
			"",
			"// 注意：这是简化过的结构",
			"const element = {",
			"  type: 'h1',",
			"  props: {",
			"    className: 'greeting',",
			"    children: 'Hello, world!'",
			"  }",
			"};",
			"这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。",
			"",
			"我们将在下一章节中探讨如何将 React 元素渲染为 DOM。",
			"",
			"提示：",
			"",
			"我们推荐在你使用的编辑器中，使用 “Babel” 提供的语言定义，来正确地高亮显示 ES6 和 JSX 代码。本网站使用与其兼容的 Oceanic Next 配色方案。",
		],
	},
	"re-函数组件与 class 组件": {
		"prefix": "re-函数组件与 class 组件",
		"body": [
			"定义组件最简单的方式就是编写 JavaScript 函数：",
			"",
			"function Welcome(props) {",
			"  return <h1>Hello, {props.name}</h1>;",
			"}",
			"该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。",
			"",
			"你同时还可以使用 ES6 的 class 来定义组件：",
			"",
			"class Welcome extends React.Component {",
			"  render() {",
			"    return <h1>Hello, {this.props.name}</h1>;",
			"  }",
			"}",
			"上述两个组件在 React 里是等效的。",
			"",
			"我们将在下一章节中讨论关于函数组件和 class 组件的额外特性。",
		],
	},
	"re-渲染组件": {
		"prefix": "re-渲染组件",
		"body": [
			"之前，我们遇到的 React 元素都只是 DOM 标签：",
			"",
			"const element = <div />;",
			"不过，React 元素也可以是用户自定义的组件：",
			"",
			"const element = <Welcome name=\"Sara\" />;",
			"当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。",
			"",
			"例如，这段代码会在页面上渲染 “Hello, Sara”：",
			"",
			"function Welcome(props) {",
			"  return <h1>Hello, {props.name}</h1>;",
			"}",
			"",
			"const element = <Welcome name=\"Sara\" />;",
			"ReactDOM.render(",
			"  element,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"让我们来回顾一下这个例子中发生了什么：",
			"",
			"我们调用 ReactDOM.render() 函数，并传入 <Welcome name=\"Sara\" /> 作为参数。",
			"React 调用 Welcome 组件，并将 {name: 'Sara'} 作为 props 传入。",
			"Welcome 组件将 <h1>Hello, Sara</h1> 元素作为返回值。",
			"React DOM 将 DOM 高效地更新为 <h1>Hello, Sara</h1>。",
			"注意： 组件名称必须以大写字母开头。",
			"",
			"React 会将以小写字母开头的组件视为原生 DOM 标签。例如，<div /> 代表 HTML 的 div 标签，而 <Welcome /> 则代表一个组件，并且需在作用域内使用 Welcome。",
			"",
			"你可以在深入 JSX中了解更多关于此规范的原因。",
		],
	},
	"re-组合组件": {
		"prefix": "re-组合组件",
		"body": [
			"组件可以在其输出中引用其他组件。这就可以让我们用同一组件来抽象出任意层次的细节。按钮，表单，对话框，甚至整个屏幕的内容：在 React 应用程序中，这些通常都会以组件的形式表示。",
			"",
			"例如，我们可以创建一个可以多次渲染 Welcome 组件的 App 组件：",
			"",
			"function Welcome(props) {",
			"  return <h1>Hello, {props.name}</h1>;",
			"}",
			"",
			"function App() {",
			"  return (",
			"    <div>",
			"      <Welcome name=\"Sara\" />",
			"      <Welcome name=\"Cahal\" />",
			"      <Welcome name=\"Edite\" />",
			"    </div>",
			"  );",
			"}",
			"",
			"ReactDOM.render(",
			"  <App />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"通常来说，每个新的 React 应用程序的顶层组件都是 App 组件。但是，如果你将 React 集成到现有的应用程序中，你可能需要使用像 Button 这样的小组件，并自下而上地将这类组件逐步应用到视图层的每一处。",
		],
	},
	"re-tick": {
		"prefix": "re-tick",
		"body": [
			"class Clock extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {date: new Date()};",
			"  }",
			"",
			"  componentDidMount() {",
			"    this.timerID = setInterval(",
			"      () => this.tick(),",
			"      1000",
			"    );",
			"  }",
			"",
			"  componentWillUnmount() {",
			"    clearInterval(this.timerID);",
			"  }",
			"",
			"  tick() {",
			"    this.setState({",
			"      date: new Date()",
			"    });",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <div>",
			"        <h1>Hello, world!</h1>",
			"        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>",
			"      </div>",
			"    );",
			"  }",
			"}",
			"",
			"ReactDOM.render(",
			"  <Clock />,",
			"  document.getElementById('root')",
			");",
		],
	},
	"re-正确地使用 State": {
		"prefix": "re-正确地使用 State",
		"body": [
			"关于 setState() 你应该了解三件事：",
			"",
			"不要直接修改 State",
			"例如，此代码不会重新渲染组件：",
			"",
			"// Wrong",
			"this.state.comment = 'Hello';",
			"而是应该使用 setState():",
			"",
			"// Correct",
			"this.setState({comment: 'Hello'});",
			"构造函数是唯一可以给 this.state 赋值的地方：",
			"",
			"State 的更新可能是异步的",
			"出于性能考虑，React 可能会把多个 setState() 调用合并成一个调用。",
			"",
			"因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态。",
			"",
			"例如，此代码可能会无法更新计数器：",
			"",
			"// Wrong",
			"this.setState({",
			"  counter: this.state.counter + this.props.increment,",
			"});",
			"要解决这个问题，可以让 setState() 接收一个函数而不是一个对象。这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：",
			"",
			"// Correct",
			"this.setState((state, props) => ({",
			"  counter: state.counter + props.increment",
			"}));",
			"上面使用了箭头函数，不过使用普通的函数也同样可以：",
			"",
			"// Correct",
			"this.setState(function(state, props) {",
			"  return {",
			"    counter: state.counter + props.increment",
			"  };",
			"});",
		],
	},
	"re-State 的更新会被合并": {
		"prefix": "re-State 的更新会被合并",
		"body": [
			"State 的更新会被合并",
			"当你调用 setState() 的时候，React 会把你提供的对象合并到当前的 state。",
			"",
			"例如，你的 state 包含几个独立的变量：",
			"",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {",
			"      posts: [],",
			"      comments: []",
			"    };",
			"  }",
			"然后你可以分别调用 setState() 来单独地更新它们：",
			"",
			"  componentDidMount() {",
			"    fetchPosts().then(response => {",
			"      this.setState({",
			"        posts: response.posts",
			"      });",
			"    });",
			"",
			"    fetchComments().then(response => {",
			"      this.setState({",
			"        comments: response.comments",
			"      });",
			"    });",
			"  }",
			"这里的合并是浅合并，所以 this.setState({comments}) 完整保留了 this.state.posts， 但是完全替换了 this.state.comments。",
		],
	},
	"re-数据是向下流动的": {
		"prefix": "re-数据是向下流动的",
		"body": [
			"不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。",
			"",
			"这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。",
			"",
			"组件可以选择把它的 state 作为 props 向下传递到它的子组件中：",
			"",
			"<h2>It is {this.state.date.toLocaleTimeString()}.</h2>",
			"这对于自定义组件同样适用：",
			"",
			"<FormattedDate date={this.state.date} />",
			"FormattedDate 组件会在其 props 中接收参数 date，但是组件本身无法知道它是来自于 Clock 的 state，或是 Clock 的 props，还是手动输入的：",
			"",
			"function FormattedDate(props) {",
			"  return <h2>It is {props.date.toLocaleTimeString()}.</h2>;",
			"}",
			"在 CodePen 上尝试",
			"",
			"这通常会被叫做“自上而下”或是“单向”的数据流。任何的 state 总是所属于特定的组件，而且从该 state 派生的任何数据或 UI 只能影响树中“低于”它们的组件。",
			"",
			"如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。",
			"",
			"为了证明每个组件都是真正独立的，我们可以创建一个渲染三个 Clock 的 App 组件：",
			"",
			"function App() {",
			"  return (",
			"    <div>",
			"      <Clock />",
			"      <Clock />",
			"      <Clock />",
			"    </div>",
			"  );",
			"}",
			"",
			"ReactDOM.render(",
			"  <App />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"每个 Clock 组件都会单独设置它自己的计时器并且更新它。",
			"",
			"在 React 应用中，组件是有状态组件还是无状态组件属于组件实现的细节，它可能会随着时间的推移而改变。你可以在有状态的组件中使用无状态的组件，反之亦然。",
		],
	},
	"re-bind": {
		"prefix": "re-bind",
		"body": [
			"当你使用 ES6 class 语法定义一个组件的时候，通常的做法是将事件处理函数声明为 class 中的方法。例如，下面的 Toggle 组件会渲染一个让用户切换开关状态的按钮：",
			"",
			"class Toggle extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {isToggleOn: true};",
			"",
			"    // 为了在回调中使用 `this`，这个绑定是必不可少的",
			"    this.handleClick = this.handleClick.bind(this);",
			"  }",
			"",
			"  handleClick() {",
			"    this.setState(state => ({",
			"      isToggleOn: !state.isToggleOn",
			"    }));",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <button onClick={this.handleClick}>",
			"        {this.state.isToggleOn ? 'ON' : 'OFF'}",
			"      </button>",
			"    );",
			"  }",
			"}",
			"",
			"ReactDOM.render(",
			"  <Toggle />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。",
			"",
			"这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。",
			"",
			"如果觉得使用 bind 很麻烦，这里有两种方式可以解决。如果你正在使用实验性的 public class fields 语法，你可以使用 class fields 正确的绑定回调函数：",
			"",
			"class LoggingButton extends React.Component {",
			"  // 此语法确保 `handleClick` 内的 `this` 已被绑定。",
			"  // 注意: 这是 *实验性* 语法。",
			"  handleClick = () => {",
			"    console.log('this is:', this);",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <button onClick={this.handleClick}>",
			"        Click me",
			"      </button>",
			"    );",
			"  }",
			"}",
			"Create React App 默认启用此语法。",
			"",
			"如果你没有使用 class fields 语法，你可以在回调中使用箭头函数：",
			"",
			"class LoggingButton extends React.Component {",
			"  handleClick() {",
			"    console.log('this is:', this);",
			"  }",
			"",
			"  render() {",
			"    // 此语法确保 `handleClick` 内的 `this` 已被绑定。",
			"    return (",
			"      <button onClick={() => this.handleClick()}>",
			"        Click me",
			"      </button>",
			"    );",
			"  }",
			"}",
			"此语法问题在于每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。",
		],
	},
	"re-向事件处理程序传递参数1": {
		"prefix": "re-向事件处理程序传递参数1",
		"body": [
			"在循环中，通常我们会为事件处理函数传递额外的参数。例如，若 id 是你要删除那一行的 ID，以下两种方式都可以向事件处理函数传递参数：",
			"",
			"<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>",
			"<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>",
			"上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。",
			"",
			"在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。",
		],
	},
	"re-if": {
		"prefix": "re-if",
		"body": [
			"eact 中的条件渲染和 JavaScript 中的一样，使用 JavaScript 运算符 if 或者条件运算符去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI。",
			"",
			"观察这两个组件:",
			"",
			"function UserGreeting(props) {",
			"  return <h1>Welcome back!</h1>;",
			"}",
			"",
			"function GuestGreeting(props) {",
			"  return <h1>Please sign up.</h1>;",
			"}",
			"再创建一个 Greeting 组件，它会根据用户是否登录来决定显示上面的哪一个组件。",
			"",
			"function Greeting(props) {",
			"  const isLoggedIn = props.isLoggedIn;",
			"  if (isLoggedIn) {",
			"    return <UserGreeting />;",
			"  }",
			"  return <GuestGreeting />;",
			"}",
			"",
			"ReactDOM.render(",
			"  // Try changing to isLoggedIn={true}:",
			"  <Greeting isLoggedIn={false} />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"这个示例根据 isLoggedIn 的值来渲染不同的问候语。",
		],
	},
	"re-元素变量1": {
		"prefix": "re-元素变量1",
		"body": [
			"你可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变。",
			"",
			"观察这两个组件，它们分别代表了注销和登录按钮：",
			"",
			"function LoginButton(props) {",
			"  return (",
			"    <button onClick={props.onClick}>",
			"      Login",
			"    </button>",
			"  );",
			"}",
			"",
			"function LogoutButton(props) {",
			"  return (",
			"    <button onClick={props.onClick}>",
			"      Logout",
			"    </button>",
			"  );",
			"}",
			"在下面的示例中，我们将创建一个名叫 LoginControl 的有状态的组件。",
			"",
			"它将根据当前的状态来渲染 <LoginButton /> 或者 <LogoutButton />。同时它还会渲染上一个示例中的 <Greeting />。",
			"",
			"class LoginControl extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.handleLoginClick = this.handleLoginClick.bind(this);",
			"    this.handleLogoutClick = this.handleLogoutClick.bind(this);",
			"    this.state = {isLoggedIn: false};",
			"  }",
			"",
			"  handleLoginClick() {",
			"    this.setState({isLoggedIn: true});",
			"  }",
			"",
			"  handleLogoutClick() {",
			"    this.setState({isLoggedIn: false});",
			"  }",
			"",
			"  render() {",
			"    const isLoggedIn = this.state.isLoggedIn;",
			"    let button;",
			"    if (isLoggedIn) {",
			"      button = <LogoutButton onClick={this.handleLogoutClick} />;",
			"    } else {",
			"      button = <LoginButton onClick={this.handleLoginClick} />;",
			"    }",
			"",
			"    return (",
			"      <div>",
			"        <Greeting isLoggedIn={isLoggedIn} />",
			"        {button}",
			"      </div>",
			"    );",
			"  }",
			"}",
			"",
			"ReactDOM.render(",
			"  <LoginControl />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"声明一个变量并使用 if 语句进行条件渲染是不错的方式，但有时你可能会想使用更为简洁的语法。接下来，我们将介绍几种在 JSX 中内联条件渲染的方法。",
		],
	},
	"re-与运算符 &&1": {
		"prefix": "re-与运算符 &&1",
		"body": [
			"通过花括号包裹代码，你可以在 JSX 中嵌入任何表达式。这也包括 JavaScript 中的逻辑与 (&&) 运算符。它可以很方便地进行元素的条件渲染。",
			"",
			"function Mailbox(props) {",
			"  const unreadMessages = props.unreadMessages;",
			"  return (",
			"    <div>",
			"      <h1>Hello!</h1>",
			"      {unreadMessages.length > 0 &&",
			"        <h2>",
			"          You have {unreadMessages.length} unread messages.",
			"        </h2>",
			"      }",
			"    </div>",
			"  );",
			"}",
			"",
			"const messages = ['React', 'Re: React', 'Re:Re: React'];",
			"ReactDOM.render(",
			"  <Mailbox unreadMessages={messages} />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"之所以能这样做，是因为在 JavaScript 中，true && expression 总是会返回 expression, 而 false && expression 总是会返回 false。",
			"",
			"因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。",
		],
	},
	"re-三目运算符1": {
		"prefix": "re-三目运算符1",
		"body": [
			"另一种内联条件渲染的方法是使用 JavaScript 中的三目运算符 condition ? true : false。",
			"",
			"在下面这个示例中，我们用它来条件渲染一小段文本",
			"",
			"render() {",
			"  const isLoggedIn = this.state.isLoggedIn;",
			"  return (",
			"    <div>",
			"      The user is <b>{isLoggedIn ? 'currently' : 'not'}</b> logged in.",
			"    </div>",
			"  );",
			"}",
			"同样的，它也可以用于较为复杂的表达式中，虽然看起来不是很直观：",
			"",
			"render() {",
			"  const isLoggedIn = this.state.isLoggedIn;",
			"  return (",
			"    <div>",
			"      {isLoggedIn",
			"        ? <LogoutButton onClick={this.handleLogoutClick} />",
			"        : <LoginButton onClick={this.handleLoginClick} />",
			"      }",
			"    </div>",
			"  );",
			"}",
			"就像在 JavaScript 中一样，你可以根据团队的习惯来选择可读性更高的代码风格。需要注意的是，如果条件变得过于复杂，那你应该考虑如何提取组件。",
		],
	},
	"re-阻止组件渲染1": {
		"prefix": "re-阻止组件渲染1",
		"body": [
			"在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。",
			"",
			"下面的示例中，<WarningBanner /> 会根据 prop 中 warn 的值来进行条件渲染。如果 warn 的值是 false，那么组件则不会渲染:",
			"",
			"function WarningBanner(props) {",
			"  if (!props.warn) {",
			"    return null;",
			"  }",
			"",
			"  return (",
			"    <div className=\"warning\">",
			"      Warning!",
			"    </div>",
			"  );",
			"}",
			"",
			"class Page extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {showWarning: true};",
			"    this.handleToggleClick = this.handleToggleClick.bind(this);",
			"  }",
			"",
			"  handleToggleClick() {",
			"    this.setState(state => ({",
			"      showWarning: !state.showWarning",
			"    }));",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <div>",
			"        <WarningBanner warn={this.state.showWarning} />",
			"        <button onClick={this.handleToggleClick}>",
			"          {this.state.showWarning ? 'Hide' : 'Show'}",
			"        </button>",
			"      </div>",
			"    );",
			"  }",
			"}",
			"",
			"ReactDOM.render(",
			"  <Page />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"在组件的 render 方法中返回 null 并不会影响组件的生命周期。例如，上面这个示例中，componentDidUpdate 依然会被调用。",
			"",
			"编辑此页面",
		],
	},
	"re-map": {
		"prefix": "re-map",
		"body": [
			"让我们来给每个列表元素分配一个 key 属性来解决上面的那个警告：",
			"",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    <li key={number.toString()}>",
			"      {number}",
			"    </li>",
			"  );",
			"  return (",
			"    <ul>{listItems}</ul>",
			"  );",
			"}",
			"",
			"const numbers = [1, 2, 3, 4, 5];",
			"ReactDOM.render(",
			"  <NumberList numbers={numbers} />,",
			"  document.getElementById('root')",
			");",
		],
	},
	"re-key": {
		"prefix": "re-key",
		"body": [
			"key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。",
			"",
			"const numbers = [1, 2, 3, 4, 5];",
			"const listItems = numbers.map((number) =>",
			"  <li key={number.toString()}>",
			"    {number}",
			"  </li>",
			");",
			"一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用数据中的 id 来作为元素的 key：",
			"",
			"const todoItems = todos.map((todo) =>",
			"  <li key={todo.id}>",
			"    {todo.text}",
			"  </li>",
			");",
			"当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key：",
			"",
			"const todoItems = todos.map((todo, index) =>",
			"  // Only do this if items have no stable IDs",
			"  <li key={index}>",
			"    {todo.text}",
			"  </li>",
			");",
			"如果列表项目的顺序可能会变化，我们不建议使用索引来用作 key 值，因为这样做会导致性能变差，还可能引起组件状态的问题。可以看看 Robin Pokorny 的深度解析使用索引作为 key 的负面影响这一篇文章。如果你选择不指定显式的 key 值，那么 React 将默认使用索引用作为列表项目的 key 值。",
			"",
			"要是你有兴趣了解更多的话，这里有一篇文章深入解析为什么 key 是必须的可以参考。",
		],
	},
	"re-正确的使用 key 的方式": {
		"prefix": "re-正确的使用 key 的方式",
		"body": [
			"function ListItem(props) {",
			"  // 正确！这里不需要指定 key：",
			"  return <li>{props.value}</li>;",
			"}",
			"",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    // 正确！key 应该在数组的上下文中被指定",
			"    <ListItem key={number.toString()}              value={number} />",
			"",
			"  );",
			"  return (",
			"    <ul>",
			"      {listItems}",
			"    </ul>",
			"  );",
			"}",
			"",
			"const numbers = [1, 2, 3, 4, 5];",
			"ReactDOM.render(",
			"  <NumberList numbers={numbers} />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"一个好的经验法则是：在 map() 方法中的元素需要设置 key 属性",
		],
	},
	"re-key 只是在兄弟节点之间必须唯一": {
		"prefix": "re-key 只是在兄弟节点之间必须唯一",
		"body": [
			"数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值：",
			"",
			"function Blog(props) {",
			"  const sidebar = (",
			"    <ul>",
			"      {props.posts.map((post) =>",
			"        <li key={post.id}>",
			"          {post.title}",
			"        </li>",
			"      )}",
			"    </ul>",
			"  );",
			"  const content = props.posts.map((post) =>",
			"    <div key={post.id}>",
			"      <h3>{post.title}</h3>",
			"      <p>{post.content}</p>",
			"    </div>",
			"  );",
			"  return (",
			"    <div>",
			"      {sidebar}",
			"      <hr />",
			"      {content}",
			"    </div>",
			"  );",
			"}",
			"",
			"const posts = [",
			"  {id: 1, title: 'Hello World', content: 'Welcome to learning React!'},",
			"  {id: 2, title: 'Installation', content: 'You can install React from npm.'}",
			"];",
			"ReactDOM.render(",
			"  <Blog posts={posts} />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"key 会传递信息给 React ，但不会传递给你的组件。如果你的组件中需要使用 key 属性的值，请用其他属性名显式传递这个值：",
			"",
			"const content = posts.map((post) =>",
			"  <Post",
			"    key={post.id}",
			"    id={post.id}",
			"    title={post.title} />",
			");",
			"上面例子中，Post 组件可以读出 props.id，但是不能读出 props.key",
		],
	},
	"re-在 JSX 中嵌入 map()": {
		"prefix": "re-在 JSX 中嵌入 map()",
		"body": [
			"在上面的例子中，我们声明了一个单独的 listItems 变量并将其包含在 JSX 中：",
			"",
			"function NumberList(props) {",
			"  const numbers = props.numbers;",
			"  const listItems = numbers.map((number) =>",
			"    <ListItem key={number.toString()}",
			"              value={number} />",
			"  );",
			"  return (",
			"    <ul>",
			"      {listItems}",
			"    </ul>",
			"  );",
			"}",
		],
	},
	"re-input": {
		"prefix": "re-input",
		"body": [
			"在 HTML 中，表单元素（如<input>、 <textarea> 和 <select>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。",
			"",
			"我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。",
			"",
			"例如，如果我们想让前一个示例在提交时打印出名称，我们可以将表单写为受控组件：",
			"",
			"class NameForm extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {value: ''};",
			"",
			"    this.handleChange = this.handleChange.bind(this);",
			"    this.handleSubmit = this.handleSubmit.bind(this);",
			"  }",
			"",
			"  handleChange(event) {",
			"    this.setState({value: event.target.value});",
			"  }",
			"",
			"  handleSubmit(event) {",
			"    alert('提交的名字: ' + this.state.value);",
			"    event.preventDefault();",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <form onSubmit={this.handleSubmit}>",
			"        <label>",
			"          名字:",
			"          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />",
			"        </label>",
			"        <input type=\"submit\" value=\"提交\" />",
			"      </form>",
			"    );",
			"  }",
			"}",
			"在 CodePen 上尝试",
			"",
			"由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。",
			"",
			"对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。",
		],
	},
	"re-textarea 标签": {
		"prefix": "re-textarea 标签",
		"body": [
			"在 HTML 中, <textarea> 元素通过其子元素定义其文本:",
			"",
			"<textarea>",
			"  你好， 这是在 text area 里的文本",
			"</textarea>",
			"而在 React 中，<textarea> 使用 value 属性代替。这样，可以使得使用 <textarea> 的表单和使用单行 input 的表单非常类似：",
			"",
			"class EssayForm extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {",
			"      value: '请撰写一篇关于你喜欢的 DOM 元素的文章.'",
			"    };",
			"",
			"    this.handleChange = this.handleChange.bind(this);",
			"    this.handleSubmit = this.handleSubmit.bind(this);",
			"  }",
			"",
			"  handleChange(event) {",
			"    this.setState({value: event.target.value});",
			"  }",
			"",
			"  handleSubmit(event) {",
			"    alert('提交的文章: ' + this.state.value);",
			"    event.preventDefault();",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <form onSubmit={this.handleSubmit}>",
			"        <label>",
			"          文章:",
			"          <textarea value={this.state.value} onChange={this.handleChange} />",
			"        </label>",
			"        <input type=\"submit\" value=\"提交\" />",
			"      </form>",
			"    );",
			"  }",
			"}",
			"请注意，this.state.value 初始化于构造函数中，因此文本区域默认有初值。",
		],
	},
	"re-select 标签": {
		"prefix": "re-select 标签",
		"body": [
			"在 HTML 中，<select> 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表：",
			"",
			"<select>",
			"  <option value=\"grapefruit\">葡萄柚</option>",
			"  <option value=\"lime\">酸橙</option>",
			"  <option selected value=\"coconut\">椰子</option>",
			"  <option value=\"mango\">芒果</option>",
			"</select>",
			"请注意，由于 selected 属性的缘故，椰子选项默认被选中。React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。例如：",
			"",
			"class FlavorForm extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {value: 'coconut'};",
			"",
			"    this.handleChange = this.handleChange.bind(this);",
			"    this.handleSubmit = this.handleSubmit.bind(this);",
			"  }",
			"",
			"  handleChange(event) {",
			"    this.setState({value: event.target.value});",
			"  }",
			"",
			"  handleSubmit(event) {",
			"    alert('你喜欢的风味是: ' + this.state.value);",
			"    event.preventDefault();",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <form onSubmit={this.handleSubmit}>",
			"        <label>",
			"          选择你喜欢的风味:",
			"          <select value={this.state.value} onChange={this.handleChange}>",
			"            <option value=\"grapefruit\">葡萄柚</option>",
			"            <option value=\"lime\">酸橙</option>",
			"            <option value=\"coconut\">椰子</option>",
			"            <option value=\"mango\">芒果</option>",
			"          </select>",
			"        </label>",
			"        <input type=\"submit\" value=\"提交\" />",
			"      </form>",
			"    );",
			"  }",
			"}",
			"在 CodePen 上尝试",
			"",
			"总的来说，这使得 <input type=\"text\">, <textarea> 和 <select> 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。",
			"",
			"注意",
			"",
			"你可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项：",
			"",
			"<select multiple={true} value={['B', 'C']}>",
		],
	},
	"re-文件 input 标签": {
		"prefix": "re-文件 input 标签",
		"body": [
			"在 HTML 中，<input type=\"file\"> 允许用户从存储设备中选择一个或多个文件，将其上传到服务器，或通过使用 JavaScript 的 File API 进行控制。",
			"",
			"<input type=\"file\" />",
			"因为它的 value 只读，所以它是 React 中的一个非受控组件。将与其他非受控组件在后续文档中一起讨论。",
		],
	},
	"re-当需要处理多个 input 元素时": {
		"prefix": "re-当需要处理多个 input 元素时",
		"body": [
			"当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作。",
			"",
			"例如：",
			"",
			"class Reservation extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {",
			"      isGoing: true,",
			"      numberOfGuests: 2",
			"    };",
			"",
			"    this.handleInputChange = this.handleInputChange.bind(this);",
			"  }",
			"",
			"  handleInputChange(event) {",
			"    const target = event.target;",
			"    const value = target.name === 'isGoing' ? target.checked : target.value;",
			"    const name = target.name;",
			"",
			"    this.setState({",
			"      [name]: value",
			"    });",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <form>",
			"        <label>",
			"          参与:",
			"          <input",
			"            name=\"isGoing\"",
			"            type=\"checkbox\"",
			"            checked={this.state.isGoing}",
			"            onChange={this.handleInputChange} />",
			"        </label>",
			"        <br />",
			"        <label>",
			"          来宾人数:",
			"          <input",
			"            name=\"numberOfGuests\"",
			"            type=\"number\"",
			"            value={this.state.numberOfGuests}",
			"            onChange={this.handleInputChange} />",
			"        </label>",
			"      </form>",
			"    );",
			"  }",
			"}",
			"在 CodePen 上尝试",
			"",
			"这里使用了 ES6 计算属性名称的语法更新给定输入名称对应的 state 值：",
			"",
			"例如：",
			"",
			"this.setState({",
			"  [name]: value",
			"});",
			"等同 ES5:",
			"",
			"var partialState = {};",
			"partialState[name] = value;",
			"this.setState(partialState);",
			"另外，由于 setState() 自动将部分 state 合并到当前 state, 只需调用它更改部分 state 即可。",
		],
	},
	"re-受控输入空值": {
		"prefix": "re-受控输入空值",
		"body": [
			"在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将value 设置为 undefined 或 null。",
			"",
			"下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）",
			"",
			"ReactDOM.render(<input value=\"hi\" />, mountNode);",
			"",
			"setTimeout(function() {",
			"  ReactDOM.render(<input value={null} />, mountNode);",
			"}, 1000);",
		],
	},
	"re-状态提升": {
		"prefix": "re-状态提升",
		"body": [
			"https://react.docschina.org/docs/lifting-state-up.html",
		],
	},
	"re-props.children": {
		"prefix": "re-props.children",
		"body": [
			"有些组件无法提前知晓它们子组件的具体内容。在 Sidebar（侧边栏）和 Dialog（对话框）等展现通用容器（box）的组件中特别容易遇到这种情况。",
			"",
			"我们建议这些组件使用一个特殊的 children prop 来将他们的子组件传递到渲染结果中：",
			"",
			"function FancyBorder(props) {",
			"  return (",
			"    <div className={'FancyBorder FancyBorder-' + props.color}>",
			"      {props.children}",
			"    </div>",
			"  );",
			"}",
			"这使得别的组件可以通过 JSX 嵌套，将任意组件作为子组件传递给它们。",
			"",
			"function WelcomeDialog() {",
			"  return (",
			"    <FancyBorder color=\"blue\">",
			"      <h1 className=\"Dialog-title\">",
			"        Welcome",
			"      </h1>",
			"      <p className=\"Dialog-message\">",
			"        Thank you for visiting our spacecraft!",
			"      </p>",
			"    </FancyBorder>",
			"  );",
			"}",
			"在 CodePen 上尝试",
			"",
			"<FancyBorder> JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder 组件。因为 FancyBorder 将 {props.children} 渲染在一个 <div> 中，被传递的这些子组件最终都会出现在输出结果中。",
			"",
			"少数情况下，你可能需要在一个组件中预留出几个“洞”。这种情况下，我们可以不使用 children，而是自行约定：将所需内容传入 props，并使用相应的 prop。",
			"",
			"function SplitPane(props) {",
			"  return (",
			"    <div className=\"SplitPane\">",
			"      <div className=\"SplitPane-left\">",
			"        {props.left}",
			"      </div>",
			"      <div className=\"SplitPane-right\">",
			"        {props.right}",
			"      </div>",
			"    </div>",
			"  );",
			"}",
			"",
			"function App() {",
			"  return (",
			"    <SplitPane",
			"      left={",
			"        <Contacts />",
			"      }",
			"      right={",
			"        <Chat />",
			"      } />",
			"  );",
			"}",
			"在 CodePen 上尝试",
			"",
			"<Contacts /> 和 <Chat /> 之类的 React 元素本质就是对象（object），所以你可以把它们当作 props，像其他数据一样传递。这种方法可能使你想起别的库中“槽”（slot）的概念，但在 React 中没有“槽”这一概念的限制，你可以将任何东西作为 props 进行传递。",
		],
	},
	"re-特例关系": {
		"prefix": "re-特例关系",
		"body": [
			"有些时候，我们会把一些组件看作是其他组件的特殊实例，比如 WelcomeDialog 可以说是 Dialog 的特殊实例。",
			"",
			"在 React 中，我们也可以通过组合来实现这一点。“特殊”组件可以通过 props 定制并渲染“一般”组件：",
			"",
			"function Dialog(props) {",
			"  return (",
			"    <FancyBorder color=\"blue\">",
			"      <h1 className=\"Dialog-title\">",
			"        {props.title}",
			"      </h1>",
			"      <p className=\"Dialog-message\">",
			"        {props.message}",
			"      </p>",
			"    </FancyBorder>",
			"  );",
			"}",
			"",
			"function WelcomeDialog() {",
			"  return (",
			"    <Dialog",
			"      title=\"Welcome\"",
			"      message=\"Thank you for visiting our spacecraft!\" />",
			"  );",
			"}",
			"在 CodePen 上尝试",
			"",
			"组合也同样适用于以 class 形式定义的组件。",
			"",
			"function Dialog(props) {",
			"  return (",
			"    <FancyBorder color=\"blue\">",
			"      <h1 className=\"Dialog-title\">",
			"        {props.title}",
			"      </h1>",
			"      <p className=\"Dialog-message\">",
			"        {props.message}",
			"      </p>",
			"      {props.children}",
			"    </FancyBorder>",
			"  );",
			"}",
			"",
			"class SignUpDialog extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.handleChange = this.handleChange.bind(this);",
			"    this.handleSignUp = this.handleSignUp.bind(this);",
			"    this.state = {login: ''};",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <Dialog title=\"Mars Exploration Program\"",
			"              message=\"How should we refer to you?\">",
			"        <input value={this.state.login}",
			"               onChange={this.handleChange} />",
			"        <button onClick={this.handleSignUp}>",
			"          Sign Me Up!",
			"        </button>",
			"      </Dialog>",
			"    );",
			"  }",
			"",
			"  handleChange(e) {",
			"    this.setState({login: e.target.value});",
			"  }",
			"",
			"  handleSignUp() {",
			"    alert(`Welcome aboard, ${this.state.login}!`);",
			"  }",
			"}",
			"在 CodePen 上尝试",
		],
	},
	"re-那么继承呢？": {
		"prefix": "re-那么继承呢？",
		"body": [
			"在 Facebook，我们在成百上千个组件中使用 React。我们并没有发现需要使用继承来构建组件层次的情况。",
			"",
			"Props 和组合为你提供了清晰而安全地定制组件外观和行为的灵活方式。注意：组件可以接受任意 props，包括基本数据类型，React 元素以及函数。",
			"",
			"如果你想要在组件间复用非 UI 的功能，我们建议将其提取为一个单独的 JavaScript 模块，如函数、对象或者类。组件可以直接引入（import）而无需通过 extend 继承它们。",
		],
	},
	"re-何时使用 Context": {
		"prefix": "re-何时使用 Context",
		"body": [
			"Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。举个例子，在下面的代码中，我们通过一个 “theme” 属性手动调整一个按钮组件的样式：",
			"",
			"class App extends React.Component {",
			"  render() {",
			"    return <Toolbar theme=\"dark\" />;",
			"  }",
			"}",
			"",
			"function Toolbar(props) {",
			"  // Toolbar 组件接受一个额外的“theme”属性，然后传递给 ThemedButton 组件。",
			"  // 如果应用中每一个单独的按钮都需要知道 theme 的值，这会是件很麻烦的事，",
			"  // 因为必须将这个值层层传递所有组件。",
			"  return (",
			"    <div>",
			"      <ThemedButton theme={props.theme} />",
			"    </div>",
			"  );",
			"}",
			"",
			"class ThemedButton extends React.Component {",
			"  render() {",
			"    return <Button theme={this.props.theme} />;",
			"  }",
			"}",
			"使用 context, 我们可以避免通过中间元素传递 props：",
			"",
			"// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。",
			"// 为当前的 theme 创建一个 context（“light”为默认值）。",
			"const ThemeContext = React.createContext('light');",
			"class App extends React.Component {",
			"  render() {",
			"    // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。",
			"    // 无论多深，任何组件都能读取这个值。",
			"    // 在这个例子中，我们将 “dark” 作为当前的值传递下去。",
			"    return (",
			"      <ThemeContext.Provider value=\"dark\">",
			"        <Toolbar />",
			"      </ThemeContext.Provider>",
			"    );",
			"  }",
			"}",
			"",
			"// 中间的组件再也不必指明往下传递 theme 了。",
			"function Toolbar() {",
			"  return (",
			"    <div>",
			"      <ThemedButton />",
			"    </div>",
			"  );",
			"}",
			"",
			"class ThemedButton extends React.Component {",
			"  // 指定 contextType 读取当前的 theme context。",
			"  // React 会往上找到最近的 theme Provider，然后使用它的值。",
			"  // 在这个例子中，当前的 theme 值为 “dark”。",
			"  static contextType = ThemeContext;",
			"  render() {",
			"    return <Button theme={this.context} />;",
			"  }",
			"}",
		],
	},
	"re-React.createContext": {
		"prefix": "re-React.createContext",
		"body": [
			"React.createContext",
			"const MyContext = React.createContext(defaultValue);",
			"创建一个 Context 对象。当 React 渲染一个订阅了这个 Context 对象的组件，这个组件会从组件树中离自身最近的那个匹配的 Provider 中读取到当前的 context 值。",
			"",
			"只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。这有助于在不使用 Provider 包装组件的情况下对组件进行测试。注意：将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效。",
		],
	},
	"re-Context.Provider": {
		"prefix": "re-Context.Provider",
		"body": [
			"<MyContext.Provider value={/* 某个值 */}>",
			"每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。",
			"",
			"Provider 接收一个 value 属性，传递给消费组件。一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据。",
			"",
			"当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。Provider 及其内部 consumer 组件都不受制于 shouldComponentUpdate 函数，因此当 consumer 组件在其祖先组件退出更新的情况下也能更新。",
			"",
			"通过新旧值检测来确定变化，使用了与 Object.is 相同的算法。",
			"",
			"注意",
			"",
			"当传递对象给 value 时，检测变化的方式会导致一些问题：详见注意事项。",
		],
	},
	"re-Class.contextType": {
		"prefix": "re-Class.contextType",
		"body": [
			"class MyClass extends React.Component {",
			"  componentDidMount() {",
			"    let value = this.context;",
			"    /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */",
			"  }",
			"  componentDidUpdate() {",
			"    let value = this.context;",
			"    /* ... */",
			"  }",
			"  componentWillUnmount() {",
			"    let value = this.context;",
			"    /* ... */",
			"  }",
			"  render() {",
			"    let value = this.context;",
			"    /* 基于 MyContext 组件的值进行渲染 */",
			"  }",
			"}",
			"MyClass.contextType = MyContext;",
			"挂载在 class 上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。这能让你使用 this.context 来消费最近 Context 上的那个值。你可以在任何生命周期中访问到它，包括 render 函数中。",
			"",
			"注意：",
			"",
			"你只通过该 API 订阅单一 context。如果你想订阅多个，阅读使用多个 Context 章节",
			"",
			"如果你正在使用实验性的 public class fields 语法，你可以使用 static 这个类属性来初始化你的 contextType。",
		],
	},
	"re-错误边界（Error Boundaries）": {
		"prefix": "re-错误边界（Error Boundaries）",
		"body": [
			"如果一个 class 组件中定义了 static getDerivedStateFromError() 或 componentDidCatch() 这两个生命周期方法中的任意一个（或两个）时，那么它就变成一个错误边界。当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。",
			"",
			"class ErrorBoundary extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = { hasError: false };",
			"  }",
			"",
			"  static getDerivedStateFromError(error) {",
			"    // 更新 state 使下一次渲染能够显示降级后的 UI",
			"    return { hasError: true };",
			"  }",
			"",
			"  componentDidCatch(error, errorInfo) {",
			"    // 你同样可以将错误日志上报给服务器",
			"    logErrorToMyService(error, errorInfo);",
			"  }",
			"",
			"  render() {",
			"    if (this.state.hasError) {",
			"      // 你可以自定义降级后的 UI 并渲染",
			"      return <h1>Something went wrong.</h1>;",
			"    }",
			"",
			"    return this.props.children; ",
			"  }",
			"}",
			"然后你可以将它作为一个常规组件去使用：",
			"",
			"<ErrorBoundary>",
			"  <MyWidget />",
			"</ErrorBoundary>",
			"错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。",
			"",
			"注意错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。如果一个错误边界无法渲染错误信息，则错误会冒泡至最近的上层错误边界，这也类似于 JavaScript 中 catch {} 的工作机制。",
		],
	},
	"re-Refs 转发": {
		"prefix": "re-Refs 转发",
		"body": [
			"Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧。对于大多数应用中的组件来说，这通常不是必需的。但其对某些组件，尤其是可重用的组件库是很有用的。最常见的案例如下所述。",
			"",
			"转发 refs 到 DOM 组件",
			"考虑这个渲染原生 DOM 元素 button 的 FancyButton 组件：",
			"",
			"function FancyButton(props) {",
			"  return (",
			"    <button className=\"FancyButton\">",
			"      {props.children}",
			"    </button>",
			"  );",
			"}",
			"React 组件隐藏其实现细节，包括其渲染结果。其他使用 FancyButton 的组件通常不需要获取内部的 DOM 元素 button 的 ref。这很好，因为这防止组件过度依赖其他组件的 DOM 结构。",
			"",
			"虽然这种封装对类似 FeedStory 或 Comment 这样的应用级组件是理想的，但其对 FancyButton 或 MyTextInput 这样的高可复用“叶”组件来说可能是不方便的。这些组件倾向于在整个应用中以一种类似常规 DOM button 和 input 的方式被使用，并且访问其 DOM 节点对管理焦点，选中或动画来说是不可避免的。",
			"",
			"Ref 转发是一个可选特性，其允许某些组件接收 ref，并将其向下传递（换句话说，“转发”它）给子组件。",
			"",
			"在下面的示例中，FancyButton 使用 React.forwardRef 来获取传递给它的 ref，然后转发到它渲染的 DOM button：",
			"",
			"const FancyButton = React.forwardRef((props, ref) => (",
			"  <button ref={ref} className=\"FancyButton\">",
			"    {props.children}",
			"  </button>",
			"));",
			"",
			"// 你可以直接获取 DOM button 的 ref：",
			"const ref = React.createRef();",
			"<FancyButton ref={ref}>Click me!</FancyButton>;",
			"这样，使用 FancyButton 的组件可以获取底层 DOM 节点 button 的 ref ，并在必要时访问，就像其直接使用 DOM button 一样。",
			"",
			"以下是对上述示例发生情况的逐步解释：",
			"",
			"我们通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量。",
			"我们通过指定 ref 为 JSX 属性，将其向下传递给 <FancyButton ref={ref}>。",
			"React 传递 ref 给 forwardRef 内函数 (props, ref) => ...，作为其第二个参数。",
			"我们向下转发该 ref 参数到 <button ref={ref}>，将其指定为 JSX 属性。",
			"当 ref 挂载完成，ref.current 将指向 <button> DOM 节点。",
			"注意",
			"",
			"第二个参数 ref 只在使用 React.forwardRef 定义组件时存在。常规函数和 class 组件不接收 ref 参数，且 props 中也不存在 ref。",
			"",
			"Ref 转发不仅限于 DOM 组件，你也可以转发 refs 到 class 组件实例中。",
		],
	},
	"re-Fragments": {
		"prefix": "re-Fragments",
		"body": [
			"React 中的一个常见模式是一个组件返回多个元素。Fragments 允许你将子列表分组，而无需向 DOM 添加额外节点。",
			"",
			"render() {",
			"  return (",
			"    <React.Fragment>",
			"      <ChildA />",
			"      <ChildB />",
			"      <ChildC />",
			"    </React.Fragment>",
			"  );",
			"}",
			"还有一种新的短语法可用于声明它们。",
			"",
			"动机",
			"一种常见模式是组件返回一个子元素列表。以此 React 代码片段为例：",
			"",
			"class Table extends React.Component {",
			"  render() {",
			"    return (",
			"      <table>",
			"        <tr>",
			"          <Columns />",
			"        </tr>",
			"      </table>",
			"    );",
			"  }",
			"}",
			"<Columns /> 需要返回多个 <td> 元素以使渲染的 HTML 有效。如果在 <Columns /> 的 render() 中使用了父 div，则生成的 HTML 将无效。",
			"",
			"class Columns extends React.Component {",
			"  render() {",
			"    return (",
			"      <div>",
			"        <td>Hello</td>",
			"        <td>World</td>",
			"      </div>",
			"    );",
			"  }",
			"}",
			"得到一个 <Table /> 输出：",
			"",
			"<table>",
			"  <tr>",
			"    <div>",
			"      <td>Hello</td>",
			"      <td>World</td>",
			"    </div>",
			"  </tr>",
			"</table>",
			"Fragments 解决了这个问题。",
			"",
			"用法",
			"class Columns extends React.Component {",
			"  render() {",
			"    return (",
			"      <React.Fragment>",
			"        <td>Hello</td>",
			"        <td>World</td>",
			"      </React.Fragment>",
			"    );",
			"  }",
			"}",
			"这样可以正确的输出 <Table />：",
			"",
			"<table>",
			"  <tr>",
			"    <td>Hello</td>",
			"    <td>World</td>",
			"  </tr>",
			"</table>",
			"短语法",
			"你可以使用一种新的，且更简短的语法来声明 Fragments。它看起来像空标签：",
			"",
			"class Columns extends React.Component {",
			"  render() {",
			"    return (",
			"      <>",
			"        <td>Hello</td>",
			"        <td>World</td>",
			"      </>",
			"    );",
			"  }",
			"}",
			"你可以像使用任何其他元素一样使用 <> </>，除了它不支持 key 或属性。",
		],
	},
	"re-带 key 的 Fragments": {
		"prefix": "re-带 key 的 Fragments",
		"body": [
			"使用显式 <React.Fragment> 语法声明的片段可能具有 key。一个使用场景是将一个集合映射到一个 Fragments 数组 - 举个例子，创建一个描述列表：",
			"",
			"function Glossary(props) {",
			"  return (",
			"    <dl>",
			"      {props.items.map(item => (",
			"        // 没有`key`，React 会发出一个关键警告",
			"        <React.Fragment key={item.id}>",
			"          <dt>{item.term}</dt>",
			"          <dd>{item.description}</dd>",
			"        </React.Fragment>",
			"      ))}",
			"    </dl>",
			"  );",
			"}",
			"key 是唯一可以传递给 Fragment 的属性。未来我们可能会添加对其他属性的支持，例如事件。",
		],
	},
	"re-深入 JSX": {
		"prefix": "re-深入 JSX",
		"body": [
			"实际上，JSX 仅仅只是 React.createElement(component, props, ...children) 函数的语法糖。如下 JSX 代码：",
			"",
			"<MyButton color=\"blue\" shadowSize={2}>",
			"  Click Me",
			"</MyButton>",
			"会编译为：",
			"",
			"React.createElement(",
			"  MyButton,",
			"  {color: 'blue', shadowSize: 2},",
			"  'Click Me'",
			")",
			"如果没有子节点，你还可以使用自闭合的标签形式，如：",
			"",
			"<div className=\"sidebar\" />",
			"会编译为:",
			"",
			"React.createElement(",
			"  'div',",
			"  {className: 'sidebar'}",
			")",
			"如果你想测试一些特定的 JSX 会转换成什么样的 JavaScript，你可以尝试使用 在线的 Babel 编译器。",
		],
	},
	"re-在 JSX 类型中使用点语法": {
		"prefix": "re-在 JSX 类型中使用点语法",
		"body": [
			"在 JSX 中，你也可以使用点语法来引用一个 React 组件。当你在一个模块中导出许多 React 组件时，这会非常方便。例如，如果 MyComponents.DatePicker 是一个组件，你可以在 JSX 中直接使用：",
			"",
			"import React from 'react';",
			"",
			"const MyComponents = {",
			"  DatePicker: function DatePicker(props) {",
			"    return <div>Imagine a {props.color} datepicker here.</div>;",
			"  }",
			"}",
			"",
			"function BlueDatePicker() {",
			"  return <MyComponents.DatePicker color=\"blue\" />;",
			"}",
		],
	},
	"re-用户定义的组件必须以大写字母开头": {
		"prefix": "re-用户定义的组件必须以大写字母开头",
		"body": [
			"以小写字母开头的元素代表一个 HTML 内置组件，比如 <div> 或者 <span> 会生成相应的字符串 'div' 或者 'span' 传递给 React.createElement（作为参数）。大写字母开头的元素则对应着在 JavaScript 引入或自定义的组件，如 <Foo /> 会编译为 React.createElement(Foo)。",
			"",
			"我们建议使用大写字母开头命名自定义组件。如果你确实需要一个以小写字母开头的组件，则在 JSX 中使用它之前，必须将它赋值给一个大写字母开头的变量。",
			"",
			"例如，以下的代码将无法按照预期运行：",
			"",
			"import React from 'react';",
			"",
			"// 错误！组件应该以大写字母开头：",
			"function hello(props) {",
			"  // 正确！这种 <div> 的使用是合法的，因为 div 是一个有效的 HTML 标签",
			"  return <div>Hello {props.toWhat}</div>;",
			"}",
			"",
			"function HelloWorld() {",
			"  // 错误！React 会认为 <hello /> 是一个 HTML 标签，因为它没有以大写字母开头：",
			"  return <hello toWhat=\"World\" />;",
			"}",
			"要解决这个问题，我们需要重命名 hello 为 Hello，同时在 JSX 中使用 <Hello /> ：",
			"",
			"import React from 'react';",
			"",
			"// 正确！组件需要以大写字母开头：",
			"function Hello(props) {",
			"  // 正确！ 这种 <div> 的使用是合法的，因为 div 是一个有效的 HTML 标签：",
			"  return <div>Hello {props.toWhat}</div>;",
			"}",
			"",
			"function HelloWorld() {",
			"  // 正确！React 知道 <Hello /> 是一个组件，因为它是大写字母开头的：",
			"  return <Hello toWhat=\"World\" />;",
			"}",
		],
	},
	"re-在运行时选择类型": {
		"prefix": "re-在运行时选择类型",
		"body": [
			"你不能将通用表达式作为 React 元素类型。如果你想通过通用表达式来（动态）决定元素类型，你需要首先将它赋值给大写字母开头的变量。这通常用于根据 prop 来渲染不同组件的情况下:",
			"",
			"import React from 'react';",
			"import { PhotoStory, VideoStory } from './stories';",
			"",
			"const components = {",
			"  photo: PhotoStory,",
			"  video: VideoStory",
			"};",
			"",
			"function Story(props) {",
			"  // 错误！JSX 类型不能是一个表达式。",
			"  return <components[props.storyType] story={props.story} />;",
			"}",
			"要解决这个问题, 需要首先将类型赋值给一个大写字母开头的变量：",
			"",
			"import React from 'react';",
			"import { PhotoStory, VideoStory } from './stories';",
			"",
			"const components = {",
			"  photo: PhotoStory,",
			"  video: VideoStory",
			"};",
			"",
			"function Story(props) {",
			"  // 正确！JSX 类型可以是大写字母开头的变量。",
			"  const SpecificStory = components[props.storyType];",
			"  return <SpecificStory story={props.story} />;",
			"}",
		],
	},
	"re-JavaScript 表达式作为 Props": {
		"prefix": "re-JavaScript 表达式作为 Props",
		"body": [
			"你可以把包裹在 {} 中的 JavaScript 表达式作为一个 prop 传递给 JSX 元素。例如，如下的 JSX：",
			"",
			"<MyComponent foo={1 + 2 + 3 + 4} />",
			"在 MyComponent 中，props.foo 的值等于 1 + 2 + 3 + 4 的执行结果 10。",
			"",
			"if 语句以及 for 循环不是 JavaScript 表达式，所以不能在 JSX 中直接使用。但是，你可以用在 JSX 以外的代码中。比如：",
			"",
			"function NumberDescriber(props) {",
			"  let description;",
			"  if (props.number % 2 == 0) {",
			"    description = <strong>even</strong>;",
			"  } else {",
			"    description = <i>odd</i>;",
			"  }",
			"  return <div>{props.number} is an {description} number</div>;",
			"}",
		],
	},
	"re-字符串字面量": {
		"prefix": "re-字符串字面量",
		"body": [
			"你可以将字符串字面量赋值给 prop. 如下两个 JSX 表达式是等价的：",
			"",
			"<MyComponent message=\"hello world\" />",
			"",
			"<MyComponent message={'hello world'} />",
			"当你将字符串字面量赋值给 prop 时，它的值是未转义的。所以，以下两个 JSX 表达式是等价的：",
			"",
			"<MyComponent message=\"&lt;3\" />",
			"",
			"<MyComponent message={'<3'} />",
			"这种行为通常是不重要的，这里只是提醒有这个用法。",
		],
	},
	"re-Props 默认值为 “True”": {
		"prefix": "re-Props 默认值为 “True”",
		"body": [
			"如果你没给 prop 赋值，它的默认值是 true。以下两个 JSX 表达式是等价的：",
			"",
			"<MyTextBox autocomplete />",
			"",
			"<MyTextBox autocomplete={true} />",
			"通常，我们不建议不传递 value 给 prop，因为这可能与 ES6 对象简写混淆，{foo} 是 {foo: foo} 的简写，而不是 {foo: true}。这样实现只是为了保持和 HTML 中标签属性的行为一致。",
		],
	},
	"re-属性展开": {
		"prefix": "re-属性展开",
		"body": [
			"如果你已经有了一个 props 对象，你可以使用展开运算符 ... 来在 JSX 中传递整个 props 对象。以下两个组件是等价的：",
			"",
			"function App1() {",
			"  return <Greeting firstName=\"Ben\" lastName=\"Hector\" />;",
			"}",
			"",
			"function App2() {",
			"  const props = {firstName: 'Ben', lastName: 'Hector'};",
			"  return <Greeting {...props} />;",
			"}",
			"你还可以选择只保留当前组件需要接收的 props，并使用展开运算符将其他 props 传递下去。",
			"",
			"const Button = props => {",
			"  const { kind, ...other } = props;",
			"  const className = kind === \"primary\" ? \"PrimaryButton\" : \"SecondaryButton\";",
			"  return <button className={className} {...other} />;",
			"};",
			"",
			"const App = () => {",
			"  return (",
			"    <div>",
			"      <Button kind=\"primary\" onClick={() => console.log(\"clicked!\")}>",
			"        Hello World!",
			"      </Button>",
			"    </div>",
			"  );",
			"};",
			"在上述例子中，kind 的 prop 会被安全的保留，它将不会被传递给 DOM 中的 <button> 元素。 所有其他的 props 会通过 ...other 对象传递，使得这个组件的应用可以非常灵活。你可以看到它传递了一个 onClick 和 children 属性。",
			"",
			"属性展开在某些情况下很有用，但是也很容易将不必要的 props 传递给不相关的组件，或者将无效的 HTML 属性传递给 DOM。我们建议谨慎的使用该语法。",
		],
	},
	"re-JavaScript 表达式作为子元素": {
		"prefix": "re-JavaScript 表达式作为子元素",
		"body": [
			"JavaScript 表达式可以被包裹在 {} 中作为子元素。例如，以下表达式是等价的：",
			"",
			"<MyComponent>foo</MyComponent>",
			"",
			"<MyComponent>{'foo'}</MyComponent>",
			"这对于展示任意长度的列表非常有用。例如，渲染 HTML 列表：",
			"",
			"function Item(props) {",
			"  return <li>{props.message}</li>;",
			"}",
			"",
			"function TodoList() {",
			"  const todos = ['finish doc', 'submit pr', 'nag dan to review'];",
			"  return (",
			"    <ul>",
			"      {todos.map((message) => <Item key={message} message={message} />)}",
			"    </ul>",
			"  );",
			"}",
			"JavaScript 表达式也可以和其他类型的子元素组合。这种做法可以方便地替代模板字符串：",
			"",
			"function Hello(props) {",
			"  return <div>Hello {props.addressee}!</div>;",
			"}",
		],
	},
	"re-函数作为子元素": {
		"prefix": "re-函数作为子元素",
		"body": [
			"通常，JSX 中的 JavaScript 表达式将会被计算为字符串、React 元素或者是列表。不过，props.children 和其他 prop 一样，它可以传递任意类型的数据，而不仅仅是 React 已知的可渲染类型。例如，如果你有一个自定义组件，你可以把回调函数作为 props.children 进行传递：",
			"",
			"// 调用子元素回调 numTimes 次，来重复生成组件",
			"function Repeat(props) {",
			"  let items = [];",
			"  for (let i = 0; i < props.numTimes; i++) {",
			"    items.push(props.children(i));",
			"  }",
			"  return <div>{items}</div>;",
			"}",
			"",
			"function ListOfTenThings() {",
			"  return (",
			"    <Repeat numTimes={10}>",
			"      {(index) => <div key={index}>This is item {index} in the list</div>}",
			"    </Repeat>",
			"  );",
			"}",
			"你可以将任何东西作为子元素传递给自定义组件，只要确保在该组件渲染之前能够被转换成 React 理解的对象。这种用法并不常见，但可以用于扩展 JSX。",
		],
	},
	"re-性能优化": {
		"prefix": "re-性能优化",
		"body": [
			"使用生产版本",
			"当你需要对你的 React 应用进行 benchmark，或者遇到了性能问题，请确保你正在使用压缩后的生产版本。",
			"",
			"React 默认包含了许多有用的警告信息。这些警告信息在开发过程中非常有帮助。然而这使得 React 变得更大且更慢，所以你需要确保部署时使用了生产版本。",
			"",
			"如果你不能确定你的编译过程是否设置正确，你可以通过安装 Chrome 的 React 开发者工具 来检查。如果你浏览一个基于 React 生产版本的网站，图标背景会变成深色：",
			"",
			"React DevTools on a website with production version of React",
			"如果你浏览一个基于 React 开发模式的网站，图标背景会变成红色：",
			"",
			"React DevTools on a website with development version of React",
			"推荐你在开发应用时使用开发模式，而在为用户部署应用时使用生产模式。",
			"",
			"你可以在下面看到几种为应用构建生产版本的操作说明。",
			"",
			"Create React App",
			"如果你的项目是通过 Create React App 构建的，运行：",
			"",
			"npm run build",
			"这段命令将在你的项目下的 build/ 目录中生成对应的生产版本。",
			"",
			"注意只有在生产部署前才需要执行这个命令。正常开发使用 npm start 即可。",
			"",
			"单文件构建",
			"我们提供了可以在生产环境使用的单文件版 React 和 React DOM：",
			"",
			"<script src=\"https://unpkg.com/react@16/umd/react.production.min.js\"></script>",
			"<script src=\"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js\"></script>",
			"注意只有以 .production.min.js 为结尾的 React 文件适用于生产。",
			"",
			"Brunch",
			"通过安装 terser-brunch 插件，来获得最高效的 Brunch 生产构建：",
			"",
			"# 如果你使用 npm",
			"npm install --save-dev terser-brunch",
			"",
			"# 如果你使用 Yarn",
			"yarn add --dev terser-brunch",
			"接着，在 build 命令后添加 -p 参数，以创建生产构建：",
			"",
			"brunch build -p",
			"请注意，你只需要在生产构建时这么做。你不需要在开发环境中使用 -p 参数或者应用这个插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。",
			"",
			"Browserify",
			"为了最高效的生产构建，需要安装一些插件：",
			"",
			"# 如果你使用 npm",
			"npm install --save-dev envify terser uglifyify",
			"",
			"# 如果你使用 Yarn",
			"yarn add --dev envify terser uglifyify",
			"为了创建生产构建，确保你添加了以下转换器 （顺序很重要）：",
			"",
			"envify 转换器用于设置正确的环境变量。设置为全局 (-g)。",
			"uglifyify 转换器移除开发相关的引用代码。同样设置为全局 (-g)。",
			"最后，将产物传给 terser 并进行压缩（为什么要这么做？）。",
			"举个例子：",
			"",
			"browserify ./index.js \",
			"  -g [ envify --NODE_ENV production ] \",
			"  -g uglifyify \",
			"  | terser --compress --mangle > ./bundle.js",
			"请注意，你只需要在生产构建时用到它。你不需要在开发环境应用这些插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。",
			"",
			"Rollup",
			"为了最高效的 Rollup 生产构建，需要安装一些插件：",
			"",
			"# 如果你使用 npm",
			"npm install --save-dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser",
			"",
			"# 如果你使用 Yarn",
			"yarn add --dev rollup-plugin-commonjs rollup-plugin-replace rollup-plugin-terser",
			"为了创建生产构建，确保你添加了以下插件 （顺序很重要）：",
			"",
			"replace 插件确保环境被正确设置。",
			"commonjs 插件用于支持 CommonJS。",
			"terser 插件用于压缩并生成最终的产物。",
			"plugins: [",
			"  // ...",
			"  require('rollup-plugin-replace')({",
			"    'process.env.NODE_ENV': JSON.stringify('production')",
			"  }),",
			"  require('rollup-plugin-commonjs')(),",
			"  require('rollup-plugin-terser')(),",
			"  // ...",
			"]",
			"点击查看完整的安装示例。",
			"",
			"请注意，你只需要在生产构建时用到它。你不需要在开发中使用 terser 插件或者 replace 插件替换 'production' 变量，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。",
			"",
			"webpack",
			"注意：",
			"",
			"如果你使用了 Create React App，请跟随上面的说明进行操作。",
			"只有当你直接配置了 webpack 才需要参考以下内容。",
			"",
			"在生产模式下，Webpack v4+ 将默认对代码进行压缩：",
			"",
			"const TerserPlugin = require('terser-webpack-plugin');",
			"",
			"module.exports = {",
			"  mode: 'production',",
			"  optimization: {",
			"    minimizer: [new TerserPlugin({ /* additional options here */ })],",
			"  },",
			"};",
			"你可以在 webpack 文档中了解更多内容。",
			"",
			"请注意，你只需要在生产构建时用到它。你不需要在开发中使用 TerserPlugin 插件，因为这会隐藏有用的 React 警告信息并使得构建速度变慢。",
			"",
			"使用 Chrome Performance 标签分析组件",
			"在开发模式下，你可以通过支持的浏览器可视化地了解组件是如何 挂载、更新以及卸载的。例如：",
			"",
			"在 Chrome 时间线中的 React 组件",
			"在 Chrome 中进行如下操作：",
			"",
			"临时禁用所有的 Chrome 扩展，尤其是 React 开发者工具。他们会严重干扰度量结果！",
			"确保你是在 React 的开发模式下运行应用。",
			"打开 Chrome 开发者工具的 Performance 标签并按下 Record。",
			"对你想分析的行为进行复现。尽量在 20 秒内完成以避免 Chrome 卡住。",
			"停止记录。",
			"在 User Timing 标签下会显示 React 归类好的事件。",
			"你可以查阅 Ben Schwarz 的文章以获取更详尽的指导。",
			"",
			"需要注意的是在生产环境中组件会相对渲染得更快些。当然了，这能帮助你查看是否有不相关的组件被错误地更新，以及 UI 更新的深度和频率。",
			"",
			"目前只有 Chrome、Edge 和 IE 支持该功能，但是我们使用的是标准的用户计时 API。我们期待有更多浏览器能支持它。",
			"",
			"使用开发者工具中的分析器对组件进行分析",
			"react-dom 16.5+ 和 react-native 0.57+ 加强了分析能力。在开发模式下，React 开发者工具会出现分析器标签。 你可以在《介绍 React 分析器》这篇博客中了解概述。 你也可以在 YouTube 上观看分析器的视频指导。",
			"",
			"如果你还未安装 React 开发者工具，你可以在这里找到它们：",
			"",
			"Chrome 浏览器扩展",
			"Firefox 浏览器扩展",
			"独立 Node 包",
			"注意",
			"",
			"react-dom 的生产分析包也可以在 react-dom/profiling 中找到。 通过查阅 fb.me/react-profiling 来了解更多关于使用这个包的内容。",
			"",
			"虚拟化长列表",
			"如果你的应用渲染了长列表（上百甚至上千的数据），我们推荐使用“虚拟滚动”技术。这项技术会在有限的时间内仅渲染有限的内容，并奇迹般地降低重新渲染组件消耗的时间，以及创建 DOM 节点的数量。",
			"",
			"react-window 和 react-virtualized 是热门的虚拟滚动库。 它们提供了多种可复用的组件，用于展示列表、网格和表格数据。 如果你想要一些针对你的应用做定制优化，你也可以创建你自己的虚拟滚动组件，就像 Twitter 所做的。",
			"",
			"避免调停",
			"React 构建并维护了一套内部的 UI 渲染描述。它包含了来自你的组件返回的 React 元素。该描述使得 React 避免创建 DOM 节点以及没有必要的节点访问，因为 DOM 操作相对于 JavaScript 对象操作更慢。虽然有时候它被称为“虚拟 DOM”，但是它在 React Native 中拥有相同的工作原理。",
			"",
			"当一个组件的 props 或 state 变更，React 会将最新返回的元素与之前渲染的元素进行对比，以此决定是否有必要更新真实的 DOM。当它们不相同时，React 会更新该 DOM。",
			"",
			"即使 React 只更新改变了的 DOM 节点，重新渲染仍然花费了一些时间。在大部分情况下它并不是问题，不过如果它已经慢到让人注意了，你可以通过覆盖生命周期方法 shouldComponentUpdate 来进行提速。该方法会在重新渲染前被触发。其默认实现总是返回 true，让 React 执行更新：",
			"",
			"shouldComponentUpdate(nextProps, nextState) {",
			"  return true;",
			"}",
			"如果你知道在什么情况下你的组件不需要更新，你可以在 shouldComponentUpdate 中返回 false 来跳过整个渲染过程。其包括该组件的 render 调用以及之后的操作。",
			"",
			"在大部分情况下，你可以继承 React.PureComponent 以代替手写 shouldComponentUpdate()。它用当前与之前 props 和 state 的浅比较覆写了 shouldComponentUpdate() 的实现。",
			"",
			"shouldComponentUpdate 的作用",
			"这是一个组件的子树。每个节点中，SCU 代表 shouldComponentUpdate 返回的值，而 vDOMEq 代表返回的 React 元素是否相同。最后，圆圈的颜色代表了该组件是否需要被调停。",
			"",
			"should component update",
			"节点 C2 的 shouldComponentUpdate 返回了 false，React 因而不会去渲染 C2，也因此 C4 和 C5 的 shouldComponentUpdate 不会被调用到。",
			"",
			"对于 C1 和 C3，shouldComponentUpdate 返回了 true，所以 React 需要继续向下查询子节点。这里 C6 的 shouldComponentUpdate 返回了 true，同时由于渲染的元素与之前的不同使得 React 更新了该 DOM。",
			"",
			"最后一个有趣的例子是 C8。React 需要渲染这个组件，但是由于其返回的 React 元素和之前渲染的相同，所以不需要更新 DOM。",
			"",
			"显而易见，你看到 React 只改变了 C6 的 DOM。对于 C8，通过对比了渲染的 React 元素跳过了渲染。而对于 C2 的子节点和 C7，由于 shouldComponentUpdate 使得 render 并没有被调用。因此它们也不需要对比元素了。",
			"",
			"示例",
			"如果你的组件只有当 props.color 或者 state.count 的值改变才需要更新时，你可以使用 shouldComponentUpdate 来进行检查：",
			"",
			"class CounterButton extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {count: 1};",
			"  }",
			"",
			"  shouldComponentUpdate(nextProps, nextState) {",
			"    if (this.props.color !== nextProps.color) {",
			"      return true;",
			"    }",
			"    if (this.state.count !== nextState.count) {",
			"      return true;",
			"    }",
			"    return false;",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <button",
			"        color={this.props.color}",
			"        onClick={() => this.setState(state => ({count: state.count + 1}))}>",
			"        Count: {this.state.count}",
			"      </button>",
			"    );",
			"  }",
			"}",
			"在这段代码中，shouldComponentUpdate 仅检查了 props.color 或 state.count 是否改变。如果这些值没有改变，那么这个组件不会更新。如果你的组件更复杂一些，你可以使用类似“浅比较”的模式来检查 props 和 state 中所有的字段，以此来决定是否组件需要更新。React 已经提供了一位好帮手来帮你实现这种常见的模式 - 你只要继承 React.PureComponent 就行了。所以这段代码可以改成以下这种更简洁的形式：",
			"",
			"class CounterButton extends React.PureComponent {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {count: 1};",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <button",
			"        color={this.props.color}",
			"        onClick={() => this.setState(state => ({count: state.count + 1}))}>",
			"        Count: {this.state.count}",
			"      </button>",
			"    );",
			"  }",
			"}",
			"大部分情况下，你可以使用 React.PureComponent 来代替手写 shouldComponentUpdate。但它只进行浅比较，所以当 props 或者 state 某种程度是可变的话，浅比较会有遗漏，那你就不能使用它了。当数据结构很复杂时，情况会变得麻烦。例如，你想要一个 ListOfWords 组件来渲染一组用逗号分开的单词。它有一个叫做 WordAdder 的父组件，该组件允许你点击一个按钮来添加一个单词到列表中。以下代码并不正确：",
			"",
			"class ListOfWords extends React.PureComponent {",
			"  render() {",
			"    return <div>{this.props.words.join(',')}</div>;",
			"  }",
			"}",
			"",
			"class WordAdder extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.state = {",
			"      words: ['marklar']",
			"    };",
			"    this.handleClick = this.handleClick.bind(this);",
			"  }",
			"",
			"  handleClick() {",
			"    // 这部分代码很糟，而且还有 bug",
			"    const words = this.state.words;",
			"    words.push('marklar');",
			"    this.setState({words: words});",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <div>",
			"        <button onClick={this.handleClick} />",
			"        <ListOfWords words={this.state.words} />",
			"      </div>",
			"    );",
			"  }",
			"}",
			"问题在于 PureComponent 仅仅会对新老 this.props.words 的值进行简单的对比。由于代码中 WordAdder 的 handleClick 方法改变了同一个 words 数组，使得新老 this.props.words 比较的其实还是同一个数组。即便实际上数组中的单词已经变了，但是比较结果是相同的。可以看到，即便多了新的单词需要被渲染， ListOfWords 却并没有被更新。",
			"",
			"不可变数据的力量",
			"避免该问题最简单的方式是避免更改你正用于 props 或 state 的值。例如，上面 handleClick 方法可以用 concat 重写：",
			"",
			"handleClick() {",
			"  this.setState(state => ({",
			"    words: state.words.concat(['marklar'])",
			"  }));",
			"}",
			"ES6 数组支持扩展运算符，这让代码写起来更方便了。如果你在使用 Create React App，该语法已经默认支持了。",
			"",
			"handleClick() {",
			"  this.setState(state => ({",
			"    words: [...state.words, 'marklar'],",
			"  }));",
			"};",
			"你可以用类似的方式改写代码来避免可变对象的产生。例如，我们有一个叫做 colormap 的对象。我们希望写一个方法来将 colormap.right 设置为 'blue'。我们可以这么写：",
			"",
			"function updateColorMap(colormap) {",
			"  colormap.right = 'blue';",
			"}",
			"为了不改变原本的对象，我们可以使用 Object.assign 方法：",
			"",
			"function updateColorMap(colormap) {",
			"  return Object.assign({}, colormap, {right: 'blue'});",
			"}",
			"现在 updateColorMap 返回了一个新的对象，而不是修改老对象。Object.assign 是 ES6 的方法，需要 polyfill。",
			"",
			"这里有一个 JavaScript 的提案，旨在添加对象扩展属性以使得更新不可变对象变得更方便：",
			"",
			"function updateColorMap(colormap) {",
			"  return {...colormap, right: 'blue'};",
			"}",
			"如果你在使用 Create React App，Object.assign 以及对象扩展运算符已经默认支持了。",
			"",
			"当处理深层嵌套对象时，以 immutable （不可变）的方式更新它们令人费解。如遇到此类问题，请参阅 Immer 或 immutability-helper。这些库会帮助你编写高可读性的代码，且不会失去 immutability （不可变性）带来的好处。",
			"",
			"编辑此页面",
		],
	},
	"re-Refs and the DOM": {
		"prefix": "re-Refs and the DOM",
		"body": [
			"Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。",
			"",
			"在典型的 React 数据流中，props 是父组件与子组件交互的唯一方式。要修改一个子组件，你需要使用新的 props 来重新渲染它。但是，在某些情况下，你需要在典型数据流之外强制修改子组件。被修改的子组件可能是一个 React 组件的实例，也可能是一个 DOM 元素。对于这两种情况，React 都提供了解决办法。",
			"",
			"何时使用 Refs",
			"下面是几个适合使用 refs 的情况：",
			"",
			"管理焦点，文本选择或媒体播放。",
			"触发强制动画。",
			"集成第三方 DOM 库。",
			"避免使用 refs 来做任何可以通过声明式实现来完成的事情。",
			"",
			"举个例子，避免在 Dialog 组件里暴露 open() 和 close() 方法，最好传递 isOpen 属性。",
			"",
			"勿过度使用 Refs",
			"你可能首先会想到使用 refs 在你的 app 中“让事情发生”。如果是这种情况，请花一点时间，认真再考虑一下 state 属性应该被安排在哪个组件层中。通常你会想明白，让更高的组件层级拥有这个 state，是更恰当的。查看 状态提升 以获取更多有关示例。",
			"",
			"注意",
			"",
			"下面的例子已经更新为使用在 React 16.3 版本引入的 React.createRef() API。如果你正在使用一个较早版本的 React，我们推荐你使用回调形式的 refs。",
			"",
			"创建 Refs",
			"Refs 是使用 React.createRef() 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。",
			"",
			"class MyComponent extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.myRef = React.createRef();",
			"  }",
			"  render() {",
			"    return <div ref={this.myRef} />;",
			"  }",
			"}",
			"访问 Refs",
			"当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问。",
			"",
			"const node = this.myRef.current;",
			"ref 的值根据节点的类型而有所不同：",
			"",
			"当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收底层 DOM 元素作为其 current 属性。",
			"当 ref 属性用于自定义 class 组件时，ref 对象接收组件的挂载实例作为其 current 属性。",
			"你不能在函数组件上使用 ref 属性，因为他们没有实例。",
			"以下例子说明了这些差异。",
		],
	},
	"re-为 DOM 元素添加 ref": {
		"prefix": "re-为 DOM 元素添加 ref",
		"body": [
			"以下代码使用 ref 去存储 DOM 节点的引用：",
			"",
			"class CustomTextInput extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    // 创建一个 ref 来存储 textInput 的 DOM 元素",
			"    this.textInput = React.createRef();",
			"    this.focusTextInput = this.focusTextInput.bind(this);",
			"  }",
			"",
			"  focusTextInput() {",
			"    // 直接使用原生 API 使 text 输入框获得焦点",
			"    // 注意：我们通过 \"current\" 来访问 DOM 节点",
			"    this.textInput.current.focus();",
			"  }",
			"",
			"  render() {",
			"    // 告诉 React 我们想把 <input> ref 关联到",
			"    // 构造器里创建的 `textInput` 上",
			"    return (",
			"      <div>",
			"        <input",
			"          type=\"text\"",
			"          ref={this.textInput} />",
			"        <input",
			"          type=\"button\"",
			"          value=\"Focus the text input\"",
			"          onClick={this.focusTextInput}",
			"        />",
			"      </div>",
			"    );",
			"  }",
			"}",
			"React 会在组件挂载时给 current 属性传入 DOM 元素，并在组件卸载时传入 null 值。ref 会在 componentDidMount 或 componentDidUpdate 生命周期钩子触发前更新。",
		],
	},
	"re-为 class 组件添加 Ref": {
		"prefix": "re-为 class 组件添加 Ref",
		"body": [
			"如果我们想包装上面的 CustomTextInput，来模拟它挂载之后立即被点击的操作，我们可以使用 ref 来获取这个自定义的 input 组件并手动调用它的 focusTextInput 方法：",
			"",
			"class AutoFocusTextInput extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.textInput = React.createRef();",
			"  }",
			"",
			"  componentDidMount() {",
			"    this.textInput.current.focusTextInput();",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <CustomTextInput ref={this.textInput} />",
			"    );",
			"  }",
			"}",
			"请注意，这仅在 CustomTextInput 声明为 class 时才有效：",
			"",
			"class CustomTextInput extends React.Component {",
			"  // ...",
			"}",
		],
	},
	"re-Refs 与函数组件": {
		"prefix": "re-Refs 与函数组件",
		"body": [
			"默认情况下，你不能在函数组件上使用 ref 属性，因为它们没有实例：",
			"",
			"function MyFunctionComponent() {",
			"  return <input />;",
			"}",
			"",
			"class Parent extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.textInput = React.createRef();",
			"  }",
			"  render() {",
			"    // This will *not* work!",
			"    return (",
			"      <MyFunctionComponent ref={this.textInput} />",
			"    );",
			"  }",
			"}",
			"如果要在函数组件中使用 ref，你可以使用 forwardRef（可与 useImperativeHandle 结合使用），或者可以将该组件转化为 class 组件。",
			"",
			"不管怎样，你可以在函数组件内部使用 ref 属性，只要它指向一个 DOM 元素或 class 组件：",
			"",
			"function CustomTextInput(props) {",
			"  // 这里必须声明 textInput，这样 ref 才可以引用它",
			"  const textInput = useRef(null);",
			"",
			"  function handleClick() {",
			"    textInput.current.focus();",
			"  }",
			"",
			"  return (",
			"    <div>",
			"      <input",
			"        type=\"text\"",
			"        ref={textInput} />",
			"      <input",
			"        type=\"button\"",
			"        value=\"Focus the text input\"",
			"        onClick={handleClick}",
			"      />",
			"    </div>",
			"  );",
			"}",
		],
	},
	"re-回调 Refs": {
		"prefix": "re-回调 Refs",
		"body": [
			"React 也支持另一种设置 refs 的方式，称为“回调 refs”。它能助你更精细地控制何时 refs 被设置和解除。",
			"",
			"不同于传递 createRef() 创建的 ref 属性，你会传递一个函数。这个函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问。",
			"",
			"下面的例子描述了一个通用的范例：使用 ref 回调函数，在实例的属性中存储对 DOM 节点的引用。",
			"",
			"class CustomTextInput extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"",
			"    this.textInput = null;",
			"",
			"    this.setTextInputRef = element => {",
			"      this.textInput = element;",
			"    };",
			"",
			"    this.focusTextInput = () => {",
			"      // 使用原生 DOM API 使 text 输入框获得焦点",
			"      if (this.textInput) this.textInput.focus();",
			"    };",
			"  }",
			"",
			"  componentDidMount() {",
			"    // 组件挂载后，让文本框自动获得焦点",
			"    this.focusTextInput();",
			"  }",
			"",
			"  render() {",
			"    // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React",
			"    // 实例上（比如 this.textInput）",
			"    return (",
			"      <div>",
			"        <input",
			"          type=\"text\"",
			"          ref={this.setTextInputRef}",
			"        />",
			"        <input",
			"          type=\"button\"",
			"          value=\"Focus the text input\"",
			"          onClick={this.focusTextInput}",
			"        />",
			"      </div>",
			"    );",
			"  }",
			"}",
			"React 将在组件挂载时，会调用 ref 回调函数并传入 DOM 元素，当卸载时调用它并传入 null。在 componentDidMount 或 componentDidUpdate 触发前，React 会保证 refs 一定是最新的。",
			"",
			"你可以在组件间传递回调形式的 refs，就像你可以传递通过 React.createRef() 创建的对象 refs 一样。",
			"",
			"function CustomTextInput(props) {",
			"  return (",
			"    <div>",
			"      <input ref={props.inputRef} />",
			"    </div>",
			"  );",
			"}",
			"",
			"class Parent extends React.Component {",
			"  render() {",
			"    return (",
			"      <CustomTextInput",
			"        inputRef={el => this.inputElement = el}",
			"      />",
			"    );",
			"  }",
			"}",
			"在上面的例子中，Parent 把它的 refs 回调函数当作 inputRef props 传递给了 CustomTextInput，而且 CustomTextInput 把相同的函数作为特殊的 ref 属性传递给了 <input>。结果是，在 Parent 中的 this.inputElement 会被设置为与 CustomTextInput 中的 input 元素相对应的 DOM 节点。",
		],
	},
	"re-TypeScript": {
		"prefix": "re-TypeScript",
		"body": [
			"TypeScript 是一种由微软开发的编程语言。它是 JavaScript 的一个类型超集，包含独立的编译器。作为一种类型语言，TypeScript 可以在构建时发现 bug 和错误，这样程序运行时就可以避免此类错误。您可以通过此文档 了解更多有关在 React 中使用 TypeScript 的知识。",
			"",
			"完成以下步骤，便可开始使用 TypeScript：",
			"",
			"将 TypeScript 添加到你的项目依赖中。",
			"配置 TypeScript 编译选项",
			"使用正确的文件扩展名",
			"为你使用的库添加定义",
			"下面让我们详细地介绍一下这些步骤：",
			"",
			"在 Create React App 中使用 TypeScript",
			"Create React App 内置了对 TypeScript 的支持。",
			"",
			"需要创建一个使用 TypeScript 的新项目，在终端运行：",
			"",
			"npx create-react-app my-app --template typescript",
			"如需将 TypeScript 添加到现有的 Create React App 项目中，请参考此文档.",
			"",
			"注意：",
			"",
			"如果你使用的是 Create React App，可以跳过本节的其余部分。其余部分讲述了不使用 Create React App 脚手架，手动配置项目的用户。",
			"",
			"添加 TypeScript 到现有项目中",
			"这一切都始于在终端中执行的一个命令。",
			"",
			"如果你使用 Yarn，执行：",
			"",
			"yarn add --dev typescript",
			"如果你使用 npm，执行：",
			"",
			"npm install --save-dev typescript",
			"恭喜！你已将最新版本的 TypeScript 安装到项目中。安装 TypeScript 后我们就可以使用 tsc 命令。在配置编译器之前，让我们将 tsc 添加到 package.json 中的 “scripts” 部分：",
			"",
			"{",
			"  // ...",
			"  \"scripts\": {",
			"    \"build\": \"tsc\",",
			"    // ...",
			"  },",
			"  // ...",
			"}",
			"配置 TypeScript 编译器",
			"没有配置项，编译器提供不了任何帮助。在 TypeScript 里，这些配置项都在一个名为 tsconfig.json 的特殊文件中定义。可以通过执行以下命令生成该文件：",
			"",
			"如果你使用 Yarn，执行：",
			"",
			"yarn run tsc --init",
			"如果你使用 npm，执行：",
			"",
			"npx tsc --init",
			"tsconfig.json 文件中，有许多配置项用于配置编译器。查看所有配置项的的详细说明，请参考此文档。",
			"",
			"我们来看一下 rootDir 和 outDir 这两个配置项。编译器将从项目中找到 TypeScript 文件并编译成相对应 JavaScript 文件。但我们不想混淆源文件和编译后的输出文件。",
			"",
			"为了解决该问题，我们将执行以下两个步骤：",
			"",
			"首先，让我们重新整理下项目目录，把所有的源代码放入 src 目录中。",
			"├── package.json",
			"├── src",
			"│   └── index.ts",
			"└── tsconfig.json",
			"其次，我们将通过配置项告诉编译器源码和输出的位置。",
			"// tsconfig.json",
			"",
			"{",
			"  \"compilerOptions\": {",
			"    // ...",
			"    \"rootDir\": \"src\",",
			"    \"outDir\": \"build\"",
			"    // ...",
			"  },",
			"}",
			"很好！现在，当我们运行构建脚本时，编译器会将生成的 javascript 输出到 build 文件夹。 TypeScript React Starter 提供了一套默认的 tsconfig.json 帮助你快速上手。",
			"",
			"通常情况下，你不希望将编译后生成的 JavaScript 文件保留在版本控制内。因此，应该把构建文件夹添加到 .gitignore 中。",
			"",
			"文件扩展名",
			"在 React 中，你的组件文件大多数使用 .js 作为扩展名。在 TypeScript 中，提供两种文件扩展名：",
			"",
			".ts 是默认的文件扩展名，而 .tsx 是一个用于包含 JSX 代码的特殊扩展名。",
			"",
			"运行 TypeScript",
			"如果你按照上面的说明操作，现在应该能运行 TypeScript 了。",
			"",
			"yarn build",
			"如果你使用 npm，执行：",
			"",
			"npm run build",
			"如果你没有看到输出信息，这意味着它编译成功了。",
			"",
			"类型定义",
			"为了能够显示来自其他包的错误和提示，编译器依赖于声明文件。声明文件提供有关库的所有类型信息。这样，我们的项目就可以用上像 npm 这样的平台提供的三方 JavaScript 库。",
			"",
			"获取一个库的声明文件有两种方式：",
			"",
			"Bundled - 该库包含了自己的声明文件。这样很好，因为我们只需要安装这个库，就可以立即使用它了。要知道一个库是否包含类型，看库中是否有 index.d.ts 文件。有些库会在 package.json 文件的 typings 或 types 属性中指定类型文件。",
			"",
			"DefinitelyTyped - DefinitelyTyped 是一个庞大的声明仓库，为没有声明文件的 JavaScript 库提供类型定义。这些类型定义通过众包的方式完成，并由微软和开源贡献者一起管理。例如，React 库并没有自己的声明文件。但我们可以从 DefinitelyTyped 获取它的声明文件。只要执行以下命令。",
			"",
			"# yarn",
			"yarn add --dev @types/react",
			"",
			"# npm",
			"npm i --save-dev @types/react",
			"局部声明 有时，你要使用的包里没有声明文件，在 DefinitelyTyped 上也没有。在这种情况下，我们可以创建一个本地的定义文件。因此，在项目的根目录中创建一个 declarations.d.ts 文件。一个简单的声明可能是这样的：",
			"",
			"declare module 'querystring' {",
			"  export function stringify(val: object): string",
			"  export function parse(val: string): object",
			"}",
			"你现在已做好编码准备了！我们建议你查看以下资源来了解有关 TypeScript 的更多知识：",
			"",
			"TypeScript 文档：基本类型",
			"TypeScript 文档：JavaScript 迁移",
			"TypeScript 文档：React 与 Webpack",
		],
	},
	"re-使用 PropTypes 进行类型检查": {
		"prefix": "re-使用 PropTypes 进行类型检查",
		"body": [
			"注意：",
			"",
			"自 React v15.5 起，React.PropTypes 已移入另一个包中。请使用 prop-types 库 代替。",
			"",
			"我们提供了一个 codemod 脚本来做自动转换。",
			"",
			"随着你的应用程序不断增长，你可以通过类型检查捕获大量错误。对于某些应用程序来说，你可以使用 Flow 或 TypeScript 等 JavaScript 扩展来对整个应用程序做类型检查。但即使你不使用这些扩展，React 也内置了一些类型检查的功能。要在组件的 props 上进行类型检查，你只需配置特定的 propTypes 属性：",
			"",
			"import PropTypes from 'prop-types';",
			"",
			"class Greeting extends React.Component {",
			"  render() {",
			"    return (",
			"      <h1>Hello, {this.props.name}</h1>",
			"    );",
			"  }",
			"}",
			"",
			"Greeting.propTypes = {",
			"  name: PropTypes.string",
			"};",
			"PropTypes 提供一系列验证器，可用于确保组件接收到的数据类型是有效的。在本例中, 我们使用了 PropTypes.string。当传入的 prop 值类型不正确时，JavaScript 控制台将会显示警告。出于性能方面的考虑，propTypes 仅在开发模式下进行检查。",
			"",
			"PropTypes",
			"以下提供了使用不同验证器的例子：",
			"",
			"import PropTypes from 'prop-types';",
			"",
			"MyComponent.propTypes = {",
			"  // 你可以将属性声明为 JS 原生类型，默认情况下",
			"  // 这些属性都是可选的。",
			"  optionalArray: PropTypes.array,",
			"  optionalBool: PropTypes.bool,",
			"  optionalFunc: PropTypes.func,",
			"  optionalNumber: PropTypes.number,",
			"  optionalObject: PropTypes.object,",
			"  optionalString: PropTypes.string,",
			"  optionalSymbol: PropTypes.symbol,",
			"",
			"  // 任何可被渲染的元素（包括数字、字符串、元素或数组）",
			"  // (或 Fragment) 也包含这些类型。",
			"  optionalNode: PropTypes.node,",
			"",
			"  // 一个 React 元素。",
			"  optionalElement: PropTypes.element,",
			"",
			"  // 一个 React 元素类型（即，MyComponent）。",
			"  optionalElementType: PropTypes.elementType,",
			"",
			"  // 你也可以声明 prop 为类的实例，这里使用",
			"  // JS 的 instanceof 操作符。",
			"  optionalMessage: PropTypes.instanceOf(Message),",
			"",
			"  // 你可以让你的 prop 只能是特定的值，指定它为",
			"  // 枚举类型。",
			"  optionalEnum: PropTypes.oneOf(['News', 'Photos']),",
			"",
			"  // 一个对象可以是几种类型中的任意一个类型",
			"  optionalUnion: PropTypes.oneOfType([",
			"    PropTypes.string,",
			"    PropTypes.number,",
			"    PropTypes.instanceOf(Message)",
			"  ]),",
			"",
			"  // 可以指定一个数组由某一类型的元素组成",
			"  optionalArrayOf: PropTypes.arrayOf(PropTypes.number),",
			"",
			"  // 可以指定一个对象由某一类型的值组成",
			"  optionalObjectOf: PropTypes.objectOf(PropTypes.number),",
			"",
			"  // 可以指定一个对象由特定的类型值组成",
			"  optionalObjectWithShape: PropTypes.shape({",
			"    color: PropTypes.string,",
			"    fontSize: PropTypes.number",
			"  }),",
			"  ",
			"  // An object with warnings on extra properties",
			"  optionalObjectWithStrictShape: PropTypes.exact({",
			"    name: PropTypes.string,",
			"    quantity: PropTypes.number",
			"  }),   ",
			"",
			"  // 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保",
			"  // 这个 prop 没有被提供时，会打印警告信息。",
			"  requiredFunc: PropTypes.func.isRequired,",
			"",
			"  // 任意类型的数据",
			"  requiredAny: PropTypes.any.isRequired,",
			"",
			"  // 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。",
			"  // 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。",
			"  customProp: function(props, propName, componentName) {",
			"    if (!/matchme/.test(props[propName])) {",
			"      return new Error(",
			"        'Invalid prop `' + propName + '` supplied to' +",
			"        ' `' + componentName + '`. Validation failed.'",
			"      );",
			"    }",
			"  },",
			"",
			"  // 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。",
			"  // 它应该在验证失败时返回一个 Error 对象。",
			"  // 验证器将验证数组或对象中的每个值。验证器的前两个参数",
			"  // 第一个是数组或对象本身",
			"  // 第二个是他们当前的键。",
			"  customArrayProp: PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) {",
			"    if (!/matchme/.test(propValue[key])) {",
			"      return new Error(",
			"        'Invalid prop `' + propFullName + '` supplied to' +",
			"        ' `' + componentName + '`. Validation failed.'",
			"      );",
			"    }",
			"  })",
			"};",
			"限制单个元素",
			"你可以通过 PropTypes.element 来确保传递给组件的 children 中只包含一个元素。",
			"",
			"import PropTypes from 'prop-types';",
			"",
			"class MyComponent extends React.Component {",
			"  render() {",
			"    // 这必须只有一个元素，否则控制台会打印警告。",
			"    const children = this.props.children;",
			"    return (",
			"      <div>",
			"        {children}",
			"      </div>",
			"    );",
			"  }",
			"}",
			"",
			"MyComponent.propTypes = {",
			"  children: PropTypes.element.isRequired",
			"};",
			"默认 Prop 值",
			"您可以通过配置特定的 defaultProps 属性来定义 props 的默认值：",
			"",
			"class Greeting extends React.Component {",
			"  render() {",
			"    return (",
			"      <h1>Hello, {this.props.name}</h1>",
			"    );",
			"  }",
			"}",
			"",
			"// 指定 props 的默认值：",
			"Greeting.defaultProps = {",
			"  name: 'Stranger'",
			"};",
			"",
			"// 渲染出 \"Hello, Stranger\"：",
			"ReactDOM.render(",
			"  <Greeting />,",
			"  document.getElementById('example')",
			");",
			"如果你正在使用像 transform-class-properties 的 Babel 转换工具，你也可以在 React 组件类中声明 defaultProps 作为静态属性。此语法提案还没有最终确定，需要进行编译后才能在浏览器中运行。要了解更多信息，请查阅 class fields proposal。",
			"",
			"class Greeting extends React.Component {",
			"  static defaultProps = {",
			"    name: 'stranger'",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <div>Hello, {this.props.name}</div>",
			"    )",
			"  }",
			"}",
			"defaultProps 用于确保 this.props.name 在父组件没有指定其值时，有一个默认值。propTypes 类型检查发生在 defaultProps 赋值后，所以类型检查也适用于 defaultProps。",
		],
	},
	"re-非受控组件": {
		"prefix": "re-非受控组件",
		"body": [
			"在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。",
			"",
			"要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。",
			"",
			"例如，下面的代码使用非受控组件接受一个表单的值：",
			"",
			"class NameForm extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.handleSubmit = this.handleSubmit.bind(this);",
			"    this.input = React.createRef();",
			"  }",
			"",
			"  handleSubmit(event) {",
			"    alert('A name was submitted: ' + this.input.current.value);",
			"    event.preventDefault();",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <form onSubmit={this.handleSubmit}>",
			"        <label>",
			"          Name:",
			"          <input type=\"text\" ref={this.input} />",
			"        </label>",
			"        <input type=\"submit\" value=\"Submit\" />",
			"      </form>",
			"    );",
			"  }",
			"}",
			"在 CodePen 上尝试",
			"",
			"因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。",
			"",
			"如果你还是不清楚在某个特殊场景中应该使用哪种组件，那么 这篇关于受控和非受控输入组件的文章 会很有帮助。",
			"",
			"默认值",
			"在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值，在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value。",
			"",
			"render() {",
			"  return (",
			"    <form onSubmit={this.handleSubmit}>",
			"      <label>",
			"        Name:",
			"        <input",
			"          defaultValue=\"Bob\"",
			"          type=\"text\"",
			"          ref={this.input} />",
			"      </label>",
			"      <input type=\"submit\" value=\"Submit\" />",
			"    </form>",
			"  );",
			"}",
			"同样，<input type=\"checkbox\"> 和 <input type=\"radio\"> 支持 defaultChecked，<select> 和 <textarea> 支持 defaultValue。",
			"",
			"文件输入",
			"在 HTML 中，<input type=\"file\"> 可以让用户选择一个或多个文件上传到服务器，或者通过使用 File API 进行操作。",
			"",
			"<input type=\"file\" />",
			"在 React 中，<input type=\"file\" /> 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。",
			"",
			"您应该使用 File API 与文件进行交互。下面的例子显示了如何创建一个 DOM 节点的 ref 从而在提交表单时获取文件的信息。",
			"",
			"class FileInput extends React.Component {",
			"  constructor(props) {",
			"    super(props);",
			"    this.handleSubmit = this.handleSubmit.bind(this);",
			"    this.fileInput = React.createRef();",
			"  }",
			"  handleSubmit(event) {",
			"    event.preventDefault();",
			"    alert(",
			"      `Selected file - ${this.fileInput.current.files[0].name}`",
			"    );",
			"  }",
			"",
			"  render() {",
			"    return (",
			"      <form onSubmit={this.handleSubmit}>",
			"        <label>",
			"          Upload file:",
			"          <input type=\"file\" ref={this.fileInput} />",
			"        </label>",
			"        <br />",
			"        <button type=\"submit\">Submit</button>",
			"      </form>",
			"    );",
			"  }",
			"}",
			"",
			"ReactDOM.render(",
			"  <FileInput />,",
			"  document.getElementById('root')",
			");",
			"在 CodePen 上尝试",
			"",
			"编辑此页面",
		],
	},
	"re-React.Component": {
		"prefix": "re-React.Component",
		"body": [
			"本章节提供了 React class 组件的详细 API 参考。本章节默认你已熟悉基本的 React 概念，例如 组件 & Props，以及 State & 生命周期等。如果你还未熟悉，请先阅读之前章节进行学习。",
			"",
			"概览",
			"React 的组件可以定义为 class 或函数的形式。class 组件目前提供了更多的功能，这些功能将在此章节中详细介绍。如需定义 class 组件，需要继承 React.Component：",
			"",
			"class Welcome extends React.Component {",
			"  render() {",
			"    return <h1>Hello, {this.props.name}</h1>;",
			"  }",
			"}",
			"在 React.Component 的子类中有个必须定义的 render() 函数。本章节介绍其他方法均为可选。",
			"",
			"我们强烈建议你不要创建自己的组件基类。 在 React 组件中，代码重用的主要方式是组合而不是继承。",
			"",
			"注意:",
			"",
			"React 并不会强制你使用 ES6 的 class 语法。如果你倾向于不使用它，你可以使用 create-react-class 模块或类似的自定义抽象来代替。请查阅不使用 ES6 了解更多。",
			"",
			"组件的生命周期",
			"每个组件都包含“生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。你可以使用此生命周期图谱作为速查表。在下述列表中，常用的生命周期方法会被加粗。其余生命周期函数的使用则相对罕见。",
			"",
			"挂载",
			"当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：",
			"",
			"constructor()",
			"static getDerivedStateFromProps()",
			"render()",
			"componentDidMount()",
			"注意:",
			"",
			"下述生命周期方法即将过时，在新代码中应该避免使用它们：",
			"",
			"UNSAFE_componentWillMount()",
			"更新",
			"当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：",
			"",
			"static getDerivedStateFromProps()",
			"shouldComponentUpdate()",
			"render()",
			"getSnapshotBeforeUpdate()",
			"componentDidUpdate()",
			"注意:",
			"",
			"下述方法即将过时，在新代码中应该避免使用它们：",
			"",
			"UNSAFE_componentWillUpdate()",
			"UNSAFE_componentWillReceiveProps()",
			"卸载",
			"当组件从 DOM 中移除时会调用如下方法：",
			"",
			"componentWillUnmount()",
			"错误处理",
			"当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：",
			"",
			"static getDerivedStateFromError()",
			"componentDidCatch()",
			"其他 APIs",
			"组件还提供了一些额外的 API：",
			"",
			"setState()",
			"forceUpdate()",
			"class 属性",
			"defaultProps",
			"displayName",
			"实例属性",
			"props",
			"state",
			"参考",
			"常用的生命周期方法",
			"本节中的方法涵盖了创建 React 组件时能遇到的绝大多数用例。想要更好了解这些方法，可以参考生命周期图谱。",
			"",
			"render()",
			"render()",
			"render() 方法是 class 组件中唯一必须实现的方法。",
			"",
			"当 render 被调用时，它会检查 this.props 和 this.state 的变化并返回以下类型之一：",
			"",
			"React 元素。通常通过 JSX 创建。例如，<div /> 会被 React 渲染为 DOM 节点，<MyComponent /> 会被 React 渲染为自定义组件，无论是 <div /> 还是 <MyComponent /> 均为 React 元素。",
			"数组或 fragments。 使得 render 方法可以返回多个元素。欲了解更多详细信息，请参阅 fragments 文档。",
			"Portals。可以渲染子节点到不同的 DOM 子树中。欲了解更多详细信息，请参阅有关 portals 的文档",
			"字符串或数值类型。它们在 DOM 中会被渲染为文本节点",
			"布尔类型或 null。什么都不渲染。（主要用于支持返回 test && <Child /> 的模式，其中 test 为布尔类型。)",
			"render() 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。",
			"",
			"如需与浏览器进行交互，请在 componentDidMount() 或其他生命周期方法中执行你的操作。保持 render() 为纯函数，可以使组件更容易思考。",
			"",
			"注意",
			"",
			"如果 shouldComponentUpdate() 返回 false，则不会调用 render()。",
			"",
			"constructor()",
			"constructor(props)",
			"如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。",
			"",
			"在 React 组件挂载之前，会调用它的构造函数。在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 super(props)。否则，this.props 在构造函数中可能会出现未定义的 bug。",
			"",
			"通常，在 React 中，构造函数仅用于以下两种情况：",
			"",
			"通过给 this.state 赋值对象来初始化内部 state。",
			"为事件处理函数绑定实例",
			"在 constructor() 函数中不要调用 setState() 方法。如果你的组件需要使用内部 state，请直接在构造函数中为 this.state 赋值初始 state：",
			"",
			"constructor(props) {",
			"  super(props);",
			"  // 不要在这里调用 this.setState()",
			"  this.state = { counter: 0 };",
			"  this.handleClick = this.handleClick.bind(this);",
			"}",
			"只能在构造函数中直接为 this.state 赋值。如需在其他方法中赋值，你应使用 this.setState() 替代。",
			"",
			"要避免在构造函数中引入任何副作用或订阅。如遇到此场景，请将对应的操作放置在 componentDidMount 中。",
			"",
			"注意",
			"",
			"避免将 props 的值复制给 state！这是一个常见的错误：",
			"",
			"constructor(props) {",
			" super(props);",
			" // 不要这样做",
			" this.state = { color: props.color };",
			"}",
			"如此做毫无必要（你可以直接使用 this.props.color），同时还产生了 bug（更新 prop 中的 color 时，并不会影响 state）。",
			"",
			"只有在你刻意忽略 prop 更新的情况下使用。此时，应将 prop 重命名为 initialColor 或 defaultColor。必要时，你可以修改它的 key，以强制“重置”其内部 state。",
			"",
			"请参阅关于避免派生状态的博文，以了解出现 state 依赖 props 的情况该如何处理。",
			"",
			"componentDidMount()",
			"componentDidMount()",
			"componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。",
			"",
			"这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅",
			"",
			"你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理",
			"",
			"componentDidUpdate()",
			"componentDidUpdate(prevProps, prevState, snapshot)",
			"componentDidUpdate() 会在更新后会被立即调用。首次渲染不会执行此方法。",
			"",
			"当组件更新后，可以在此处对 DOM 进行操作。如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。",
			"",
			"componentDidUpdate(prevProps) {",
			"  // 典型用法（不要忘记比较 props）：",
			"  if (this.props.userID !== prevProps.userID) {",
			"    this.fetchData(this.props.userID);",
			"  }",
			"}",
			"你也可以在 componentDidUpdate() 中直接调用 setState()，但请注意它必须被包裹在一个条件语句里，正如上述的例子那样进行处理，否则会导致死循环。它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。不要将 props “镜像”给 state，请考虑直接使用 props。 欲了解更多有关内容，请参阅为什么 props 复制给 state 会产生 bug。",
			"",
			"如果组件实现了 getSnapshotBeforeUpdate() 生命周期（不常用），则它的返回值将作为 componentDidUpdate() 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。",
			"",
			"注意",
			"",
			"如果 shouldComponentUpdate() 返回值为 false，则不会调用 componentDidUpdate()。",
			"",
			"componentWillUnmount()",
		],
	},
	// "re-": {
	// 	"prefix": "re-",
	// 	"body": [],
	// },
}