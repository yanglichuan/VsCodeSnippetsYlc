{
  // Place your 全局 snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  "git-初次运行 Git 前的配置": {
    "scope": "javascript,typescript",
    "prefix": "git-初次运行 Git 前的配置",
    "body": [
      "/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果在执行 git config 时带上 --system 选项，那么它就会读写该文件中的配置变量。 （由于它是系统配置文件，因此你需要管理员或超级用户权限来修改它。）",
      "",
      "~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 你可以传递 --global 选项让 Git 读写此文件，这会对你系统上 所有 的仓库生效。",
      "",
      "当前使用仓库的 Git 目录中的 config 文件（即 .git/config）：针对该仓库。 你可以传递 --local 选项让 Git 强制读写此文件，虽然默认情况下用的就是它。。 （当然，你需要进入某个 Git 仓库中才能让该选项生效。）",
      "你可以通过以下命令查看所有的配置以及它们所在的文件：",
      "",
      "$ git config --list --show-origin",
      "用户信息",
      "安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：",
      "",
      "$ git config --global user.name \"John Doe\"",
      "$ git config --global user.email johndoe@example.com",
      "再次强调，如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有 --global 选项的命令来配置。",
      "",
      "很多 GUI 工具都会在第一次运行时帮助你配置这些信息。",
      "",
      "文本编辑器",
      "既然用户信息已经设置完毕，你可以配置默认文本编辑器了，当 Git 需要你输入信息时会调用它。 如果未配置，Git 会使用操作系统默认的文本编辑器。",
      "",
      "如果你想使用不同的文本编辑器，例如 Emacs，可以这样做：",
      "",
      "$ git config --global core.editor emacs",
      "在 Windows 系统上，如果你想要使用别的文本编辑器，那么必须指定可执行文件的完整路径。 它可能随你的编辑器的打包方式而不同。",
      "",
      "对于 Notepad++，一个流行的代码编辑器来说，你可能想要使用 32 位的版本， 因为在本书编写时 64 位的版本尚不支持所有的插件。 如果你在使用 32 位的 Windows 系统，或在 64 位系统上使用 64 位的编辑器，那么你需要输入如下命令：",
      "",
      "$ git config --global core.editor \"'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"",
      "检查配置信息",
      "如果想要检查你的配置，可以使用 git config --list 命令来列出所有 Git 当时能找到的配置。",
      "",
      "$ git config --list",
      "user.name=John Doe",
      "user.email=johndoe@example.com",
      "color.status=auto",
      "color.branch=auto",
      "color.interactive=auto",
      "color.diff=auto",
      "...",
      "你可能会看到重复的变量名，因为 Git 会从不同的文件中读取同一个配置（例如：/etc/gitconfig 与 ~/.gitconfig）。 这种情况下，Git 会使用它找到的每一个变量的最后一个配置。",
      "",
      "你可以通过输入 git config <key>： 来检查 Git 的某一项配置",
      "",
      "$ git config user.name",
      "John Doe"
    ]
  },
  "git-起步 - 获取帮助": {
    "scope": "javascript,typescript",
    "prefix": "git-起步 - 获取帮助",
    "body": [
      "获取帮助",
      "若你使用 Git 时需要获取帮助，有三种等价的方法可以找到 Git 命令的综合手册（manpage）：",
      "",
      "$ git help <verb>",
      "$ git <verb> --help",
      "$ man git-<verb>",
      "例如，要想获得 git config 命令的手册，执行",
      "",
      "$ git help config",
      "这些命令很棒，因为你随时随地可以使用而无需联网。 如果你觉得手册或者本书的内容还不够用，你可以尝试在 Freenode IRC 服务器 https://freenode.net 上的 #git 或 #github 频道寻求帮助。 这些频道经常有上百人在线，他们都精通 Git 并且乐于助人。",
      "",
      "此外，如果你不需要全面的手册，只需要可用选项的快速参考，那么可以用 -h 选项获得更简明的 “help” 输出：",
      "",
      "$ git add -h",
      "usage: git add [<options>] [--] <pathspec>...",
      "",
      "    -n, --dry-run         dry run",
      "    -v, --verbose         be verbose",
      "",
      "    -i, --interactive     interactive picking",
      "    -p, --patch           select hunks interactively",
      "    -e, --edit            edit current diff and apply",
      "    -f, --force           allow adding otherwise ignored files",
      "    -u, --update          update tracked files",
      "    --renormalize         renormalize EOL of tracked files (implies -u)",
      "    -N, --intent-to-add   record only the fact that the path will be added later",
      "    -A, --all             add changes from all tracked and untracked files",
      "    --ignore-removal      ignore paths removed in the working tree (same as --no-all)",
      "    --refresh             don't add, only refresh the index",
      "    --ignore-errors       just skip files which cannot be added because of errors",
      "    --ignore-missing      check if - even missing - files are ignored in dry run",
      "    --chmod (+|-)x        override the executable bit of the listed files"
    ]
  },
  "git-Git 基础 - 获取 Git 仓库": {
    "scope": "javascript,typescript",
    "prefix": "git-Git 基础 - 获取 Git 仓库",
    "body": [
      "获取 Git 仓库",
      "通常有两种获取 Git 项目仓库的方式：",
      "",
      "将尚未进行版本控制的本地目录转换为 Git 仓库；",
      "",
      "从其它服务器 克隆 一个已存在的 Git 仓库。",
      "",
      "两种方式都会在你的本地机器上得到一个工作就绪的 Git 仓库。",
      "",
      "在已存在目录中初始化仓库",
      "如果你有一个尚未进行版本控制的项目目录，想要用 Git 来控制它，那么首先需要进入该项目目录中。 如果你还没这样做过，那么不同系统上的做法有些不同：",
      "",
      "在 Linux 上：",
      "",
      "$ cd /home/user/my_project",
      "在 macOS 上：",
      "",
      "$ cd /Users/user/my_project",
      "在 Windows 上：",
      "",
      "$ cd /c/user/my_project",
      "之后执行：",
      "",
      "$ git init",
      "该命令将创建一个名为 .git 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。 (参见 Git 内部原理 来了解更多关于到底 .git 文件夹中包含了哪些文件的信息。)",
      "",
      "如果在一个已存在文件的文件夹（而非空文件夹）中进行版本控制，你应该开始追踪这些文件并进行初始提交。 可以通过 git add 命令来指定所需的文件来进行追踪，然后执行 git commit ：",
      "",
      "$ git add *.c",
      "$ git add LICENSE",
      "$ git commit -m 'initial project version'",
      "稍后我们再逐一解释这些指令的行为。 现在，你已经得到了一个存在被追踪文件与初始提交的 Git 仓库。",
      "",
      "克隆现有的仓库",
      "如果你想获得一份已经存在了的 Git 仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 git clone 命令。 如果你对其它的 VCS 系统（比如说 Subversion）很熟悉，请留心一下你所使用的命令是\"clone\"而不是\"checkout\"。 这是 Git 区别于其它版本控制系统的一个重要特性，Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 git clone 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库 （虽然可能会丢失某些服务器端的钩子（hook）设置，但是所有版本的数据仍在，详见 在服务器上搭建 Git ）。",
      "",
      "克隆仓库的命令是 git clone <url> 。 比如，要克隆 Git 的链接库 libgit2，可以用下面的命令：",
      "",
      "$ git clone https://github.com/libgit2/libgit2",
      "这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹， 从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 libgit2 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。",
      "",
      "如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：",
      "",
      "$ git clone https://github.com/libgit2/libgit2 mylibgit",
      "这会执行与上一条命令相同的操作，但目标目录名变为了 mylibgit。",
      "",
      "Git 支持多种数据传输协议。 上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git 。 在服务器上搭建 Git 将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。"
    ]
  },
  "git-检查当前文件状态": {
    "scope": "javascript,typescript",
    "prefix": "git-检查当前文件状态",
    "body": [
      "检查当前文件状态",
      "可以用 git status 命令查看哪些文件处于什么状态。 如果在克隆仓库后立即使用此命令，会看到类似这样的输出：",
      "",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "nothing to commit, working directory clean",
      "这说明你现在的工作目录相当干净。换句话说，所有已跟踪文件在上次提交后都未被更改过。 此外，上面的信息还表明，当前目录下没有出现任何处于未跟踪状态的新文件，否则 Git 会在这里列出来。 最后，该命令还显示了当前所在分支，并告诉你这个分支同远程服务器上对应的分支没有偏离。 现在，分支名是“master”,这是默认的分支名。 我们在 Git 分支 中会详细讨论分支和引用。",
      "",
      "现在，让我们在项目下创建一个新的 README 文件。 如果之前并不存在这个文件，使用 git status 命令，你将看到一个新的未跟踪文件：",
      "",
      "$ echo 'My Project' > README",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Untracked files:",
      "  (use \"git add <file>...\" to include in what will be committed)",
      "",
      "    README",
      "",
      "nothing added to commit but untracked files present (use \"git add\" to track)",
      "在状态报告中可以看到新建的 README 文件出现在 Untracked files 下面。 未跟踪的文件意味着 Git 在之前的快照（提交）中没有这些文件；Git 不会自动将之纳入跟踪范围，除非你明明白白地告诉它“我需要跟踪该文件”。 这样的处理让你不必担心将生成的二进制文件或其它不想被跟踪的文件包含进来。 不过现在的例子中，我们确实想要跟踪管理 README 这个文件。",
      "",
      "跟踪新文件",
      "使用命令 git add 开始跟踪一个文件。 所以，要跟踪 README 文件，运行：",
      "",
      "$ git add README",
      "此时再运行 git status 命令，会看到 README 文件已被跟踪，并处于暂存状态：",
      "",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git restore --staged <file>...\" to unstage)",
      "",
      "    new file:   README",
      "只要在 Changes to be committed 这行下面的，就说明是已暂存状态。 如果此时提交，那么该文件在你运行 git add 时的版本将被留存在后续的历史记录中。 你可能会想起之前我们使用 git init 后就运行了 git add <files> 命令，开始跟踪当前目录下的文件。 git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。",
      "",
      "暂存已修改的文件",
      "现在我们来修改一个已被跟踪的文件。 如果你修改了一个名为 CONTRIBUTING.md 的已被跟踪的文件，然后运行 git status 命令，会看到下面内容：",
      "",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    new file:   README",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      "    modified:   CONTRIBUTING.md",
      "文件 CONTRIBUTING.md 出现在 Changes not staged for commit 这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。 要暂存这次更新，需要运行 git add 命令。 这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“精确地将内容添加到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。 现在让我们运行 git add 将“CONTRIBUTING.md”放到暂存区，然后再看看 git status 的输出：",
      "",
      "$ git add CONTRIBUTING.md",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    new file:   README",
      "    modified:   CONTRIBUTING.md",
      "现在两个文件都已暂存，下次提交时就会一并记录到仓库。 假设此时，你想要在 CONTRIBUTING.md 里再加条注释。 重新编辑存盘后，准备好提交。 不过且慢，再运行 git status 看看：",
      "",
      "$ vim CONTRIBUTING.md",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    new file:   README",
      "    modified:   CONTRIBUTING.md",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      "    modified:   CONTRIBUTING.md",
      "怎么回事？ 现在 CONTRIBUTING.md 文件同时出现在暂存区和非暂存区。 这怎么可能呢？ 好吧，实际上 Git 只不过暂存了你运行 git add 命令时的版本。 如果你现在提交，CONTRIBUTING.md 的版本是你最后一次运行 git add 命令时的那个版本，而不是你运行 git commit 时，在工作目录中的当前版本。 所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本重新暂存起来：",
      "",
      "$ git add CONTRIBUTING.md",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    new file:   README",
      "    modified:   CONTRIBUTING.md",
      "状态简览",
      "git status 命令的输出十分详细，但其用语有些繁琐。 Git 有一个选项可以帮你缩短状态命令的输出，这样可以以简洁的方式查看更改。 如果你使用 git status -s 命令或 git status --short 命令，你将得到一种格式更为紧凑的输出。",
      "",
      "$ git status -s",
      " M README",
      "MM Rakefile",
      "A  lib/git.rb",
      "M  lib/simplegit.rb",
      "?? LICENSE.txt",
      "新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示： README 文件在工作区已修改但尚未暂存，而 lib/simplegit.rb 文件已修改且已暂存。 Rakefile 文件已修，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。"
    ]
  },
  "git-忽略文件": {
    "scope": "javascript,typescript",
    "prefix": "git-忽略文件",
    "body": [
      "一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 .gitignore 的文件，列出要忽略的文件的模式。 来看一个实际的 .gitignore 例子：",
      "",
      "$ cat .gitignore",
      "*.[oa]",
      "*~",
      "第一行告诉 Git 忽略所有以 .o 或 .a 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有名字以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就为你的新仓库设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。",
      "",
      "文件 .gitignore 的格式规范如下：",
      "",
      "所有空行或者以 # 开头的行都会被 Git 忽略。",
      "",
      "可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。",
      "",
      "匹配模式可以以（/）开头防止递归。",
      "",
      "匹配模式可以以（/）结尾指定目录。",
      "",
      "要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。",
      "",
      "所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。 星号（*）匹配零个或多个任意字符；[abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）； 问号（?）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配（比如 [0-9] 表示匹配所有 0 到 9 的数字）。 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。",
      "",
      "我们再看一个 .gitignore 文件的例子：",
      "",
      "# 忽略所有的 .a 文件",
      "*.a",
      "",
      "# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件",
      "!lib.a",
      "",
      "# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO",
      "/TODO",
      "",
      "# 忽略任何目录下名为 build 的文件夹",
      "build/",
      "",
      "# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt",
      "doc/*.txt",
      "",
      "# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件",
      "doc/**/*.pdf"
    ]
  },
  "git-查看已暂存和未暂存的修改": {
    "scope": "javascript,typescript",
    "prefix": "git-查看已暂存和未暂存的修改",
    "body": [
      "查看已暂存和未暂存的修改",
      "如果 git status 命令的输出对于你来说过于简略，而你想知道具体修改了什么地方，可以用 git diff 命令。 稍后我们会详细介绍 git diff，你通常可能会用它来回答这两个问题：当前做的哪些更新尚未暂存？ 有哪些更新已暂存并准备好下次提交？ 虽然 git status 已经通过在相应栏下列出文件名的方式回答了这个问题，但 git diff 能通过文件补丁的格式更加具体地显示哪些行发生了改变。",
      "",
      "假如再次修改 README 文件后暂存，然后编辑 CONTRIBUTING.md 文件后先不暂存， 运行 status 命令将会看到：",
      "",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    modified:   README",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      "    modified:   CONTRIBUTING.md",
      "要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 git diff：",
      "",
      "$ git diff",
      "diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md",
      "index 8ebb991..643e24f 100644",
      "--- a/CONTRIBUTING.md",
      "+++ b/CONTRIBUTING.md",
      "@@ -65,7 +65,8 @@ branch directly, things can get messy.",
      " Please include a nice description of your changes when you submit your PR;",
      " if we have to read the whole diff to figure out why you're contributing",
      " in the first place, you're less likely to get feedback and have your change",
      "-merged in.",
      "+merged in. Also, split your changes into comprehensive chunks if your patch is",
      "+longer than a dozen lines.",
      "",
      " If you are starting to work on a particular area, feel free to submit a PR",
      " that highlights your work in progress (and note in the PR title that it's",
      "此命令比较的是工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。",
      "",
      "若要查看已暂存的将要添加到下次提交里的内容，可以用 git diff --staged 命令。 这条命令将比对已暂存文件与最后一次提交的文件差异：",
      "",
      "$ git diff --staged",
      "diff --git a/README b/README",
      "new file mode 100644",
      "index 0000000..03902a1",
      "--- /dev/null",
      "+++ b/README",
      "@@ -0,0 +1 @@",
      "+My Project",
      "请注意，git diff 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 git diff 后却什么也没有，就是这个原因。",
      "",
      "像之前说的，暂存 CONTRIBUTING.md 后再编辑，可以使用 git status 查看已被暂存的修改或未被暂存的修改。 如果我们的环境（终端输出）看起来如下：",
      "",
      "$ git add CONTRIBUTING.md",
      "$ echo '# test line' >> CONTRIBUTING.md",
      "$ git status",
      "On branch master",
      "Your branch is up-to-date with 'origin/master'.",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    modified:   CONTRIBUTING.md",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      "    modified:   CONTRIBUTING.md",
      "现在运行 git diff 看暂存前后的变化：",
      "",
      "$ git diff",
      "diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md",
      "index 643e24f..87f08c8 100644",
      "--- a/CONTRIBUTING.md",
      "+++ b/CONTRIBUTING.md",
      "@@ -119,3 +119,4 @@ at the",
      " ## Starter Projects",
      "",
      " See our [projects list](https://github.com/libgit2/libgit2/blob/development/PROJECTS.md).",
      "+# test line",
      "然后用 git diff --cached 查看已经暂存起来的变化（ --staged 和 --cached 是同义词）："
    ]
  },
  "git-查看提交历史": {
    "scope": "javascript,typescript",
    "prefix": "git-查看提交历史",
    "body": [
      "在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。 完成这个任务最简单而又有效的工具是 git log 命令。",
      "",
      "我们使用一个非常简单的 “simplegit” 项目作为示例。 运行下面的命令获取该项目：",
      "",
      "$ git clone https://github.com/schacon/simplegit-progit",
      "当你在此项目中运行 git log 命令时，可以看到下面的输出：",
      "",
      "$ git log",
      "commit ca82a6dff817ec66f44342007202690a93763949",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Mon Mar 17 21:52:11 2008 -0700",
      "",
      "    changed the version number",
      "",
      "commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Sat Mar 15 16:40:33 2008 -0700",
      "",
      "    removed unnecessary test",
      "",
      "commit a11bef06a3f659402fe7563abf99ad00de2209e6",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Sat Mar 15 10:31:28 2008 -0700",
      "",
      "    first commit",
      "不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。 正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。",
      "",
      "git log 有许多选项可以帮助你搜寻你所要找的提交， 下面我们会介绍几个最常用的选项。",
      "",
      "其中一个比较有用的选项是 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交：",
      "",
      "$ git log -p -2",
      "commit ca82a6dff817ec66f44342007202690a93763949",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Mon Mar 17 21:52:11 2008 -0700",
      "",
      "    changed the version number",
      "",
      "diff --git a/Rakefile b/Rakefile",
      "index a874b73..8f94139 100644",
      "--- a/Rakefile",
      "+++ b/Rakefile",
      "@@ -5,7 +5,7 @@ require 'rake/gempackagetask'",
      " spec = Gem::Specification.new do |s|",
      "     s.platform  =   Gem::Platform::RUBY",
      "     s.name      =   \"simplegit\"",
      "-    s.version   =   \"0.1.0\"",
      "+    s.version   =   \"0.1.1\"",
      "     s.author    =   \"Scott Chacon\"",
      "     s.email     =   \"schacon@gee-mail.com\"",
      "     s.summary   =   \"A simple gem for using Git in Ruby code.\"",
      "",
      "commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Sat Mar 15 16:40:33 2008 -0700",
      "",
      "    removed unnecessary test",
      "",
      "diff --git a/lib/simplegit.rb b/lib/simplegit.rb",
      "index a0a60ae..47c6340 100644",
      "--- a/lib/simplegit.rb",
      "+++ b/lib/simplegit.rb",
      "@@ -18,8 +18,3 @@ class SimpleGit",
      "     end",
      "",
      " end",
      "-",
      "-if $0 == __FILE__",
      "-  git = SimpleGit.new",
      "-  puts git.show",
      "-end",
      "该选项除了显示基本信息之外，还附带了每次提交的变化。 当进行代码审查，或者快速浏览某个搭档的提交所带来的变化的时候，这个参数就非常有用了。 你也可以为 git log 附带一系列的总结性选项。 比如你想看到每次提交的简略统计信息，可以使用 --stat 选项：",
      "",
      "$ git log --stat",
      "commit ca82a6dff817ec66f44342007202690a93763949",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Mon Mar 17 21:52:11 2008 -0700",
      "",
      "    changed the version number",
      "",
      " Rakefile | 2 +-",
      " 1 file changed, 1 insertion(+), 1 deletion(-)",
      "",
      "commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Sat Mar 15 16:40:33 2008 -0700",
      "",
      "    removed unnecessary test",
      "",
      " lib/simplegit.rb | 5 -----",
      " 1 file changed, 5 deletions(-)",
      "",
      "commit a11bef06a3f659402fe7563abf99ad00de2209e6",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Sat Mar 15 10:31:28 2008 -0700",
      "",
      "    first commit",
      "",
      " README           |  6 ++++++",
      " Rakefile         | 23 +++++++++++++++++++++++",
      " lib/simplegit.rb | 25 +++++++++++++++++++++++++",
      " 3 files changed, 54 insertions(+)",
      "正如你所看到的，--stat 选项在每次提交的下面列出所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。 在每次提交的最后还有一个总结。",
      "",
      "另一个非常有用的选项是 --pretty。 这个选项可以使用不同于默认格式的方式展示提交历史。 这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：",
      "",
      "$ git log --pretty=oneline",
      "ca82a6dff817ec66f44342007202690a93763949 changed the version number",
      "085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test",
      "a11bef06a3f659402fe7563abf99ad00de2209e6 first commit",
      "最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：",
      "",
      "$ git log --pretty=format:\"%h - %an, %ar : %s\"",
      "ca82a6d - Scott Chacon, 6 years ago : changed the version number",
      "085bb3b - Scott Chacon, 6 years ago : removed unnecessary test",
      "a11bef0 - Scott Chacon, 6 years ago : first commit",
      "git log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。",
      "",
      "Table 1. git log --pretty=format 常用的选项",
      "你一定奇怪 作者 和 提交者 之间究竟有何差别， 其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。 所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。 我们会在 分布式 Git 再详细介绍两者之间的细微差别。",
      "",
      "当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：",
      "",
      "$ git log --pretty=format:\"%h %s\" --graph",
      "这种输出类型会在我们下一章学完分支与合并以后变得更加有趣。",
      "",
      "以上只是简单介绍了一些 git log 命令支持的选项。 git log 的常用选项 列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的：",
      "",
      "Table 2. git log 的常用选项",
      "限制输出长度",
      "除了定制输出格式的选项之外，git log 还有许多非常实用的限制输出长度的选项，也就是只输出一部分的提交。 之前你已经看到过 -2 选项了，它只会显示最近的两条提交， 实际上，你可以使用类似 -<n> 的选项，其中的 n 可以是任何整数，表示仅显示最近的 n 条提交。 不过实践中这个选项不是很常用，因为 Git 默认会将所有的输出传送到分页程序中，所以你一次只会看到一页的内容。",
      "",
      "但是，类似 --since 和 --until 这种按照时间作限制的选项很有用。 例如，下面的命令会列出最近两周的所有提交：",
      "",
      "$ git log --since=2.weeks",
      "该命令可用的格式十分丰富——可以是类似 \"2008-01-15\" 的具体的某一天，也可以是类似 \"2 years 1 day 3 minutes ago\" 的相对日期。",
      "",
      "还可以过滤出匹配指定条件的提交。 用 --author 选项显示指定作者的提交，用 --grep 选项搜索提交说明中的关键字。",
      "另一个非常有用的过滤器是 -S（俗称“pickaxe”选项，取“用鹤嘴锄在土里捡石头”之意）， 它接受一个字符串参数，并且只会显示那些添加或删除了该字符串的提交。 假设你想找出添加或删除了对某一个特定函数的引用的提交，可以调用：",
      "",
      "$ git log -S function_name",
      "最后一个很实用的 git log 选项是路径（path）， 如果只关心某些文件或者目录的历史提交，可以在 git log 选项的最后指定它们的路径。 因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。",
      "",
      "在 限制 git log 输出的选项 中列出了常用的选项",
      "",
      "Table 3. 限制 git log 输出的选项"
    ]
  },
  "git-撤消操作": {
    "scope": "javascript,typescript",
    "prefix": "git-撤消操作",
    "body": [
      "撤消操作",
      "在任何一个阶段，你都有可能想要撤消某些操作。 这里，我们将会学习几个撤消你所做修改的基本工具。 注意，有些撤消操作是不可逆的。 这是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有的几个地方之一。",
      "",
      "有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 --amend 选项的提交命令来重新提交：",
      "",
      "$ git commit --amend",
      "这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令）， 那么快照会保持不变，而你所修改的只是提交信息。",
      "",
      "文本编辑器启动后，可以看到之前的提交信息。 编辑后保存会覆盖原来的提交信息。",
      "",
      "例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：",
      "",
      "$ git commit -m 'initial commit'",
      "$ git add forgotten_file",
      "$ git commit --amend",
      "最终你只会有一个提交——第二次提交将代替第一次提交的结果。",
      "取消暂存的文件",
      "接下来的两个小节演示如何操作暂存区和工作目录中已修改的文件。 这些命令在修改文件状态的同时，也会提示如何撤消操作。 例如，你已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 git add * 暂存了它们两个。如何只取消暂存两个中的一个呢？ git status 命令提示了你：",
      "",
      "$ git add *",
      "$ git status",
      "On branch master",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    renamed:    README.md -> README",
      "    modified:   CONTRIBUTING.md",
      "在 “Changes to be committed” 文字正下方，提示使用 git reset HEAD <file>... 来取消暂存。 所以，我们可以这样来取消暂存 CONTRIBUTING.md 文件：",
      "",
      "$ git reset HEAD CONTRIBUTING.md",
      "Unstaged changes after reset:",
      "M	CONTRIBUTING.md",
      "$ git status",
      "On branch master",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    renamed:    README.md -> README",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      "    modified:   CONTRIBUTING.md",
      "这个命令有点儿奇怪，但是起作用了。 CONTRIBUTING.md 文件已经是修改未暂存的状态了",
      "到目前为止这个神奇的调用就是你需要对 git reset 命令了解的全部。 我们将会在 重置揭密 中了解 reset 的更多细节以及如何掌握它做一些真正有趣的事。",
      "",
      "撤消对文件的修改",
      "如果你并不想保留对 CONTRIBUTING.md 文件的修改怎么办？ 你该如何方便地撤消修改——将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？ 幸运的是，git status 也告诉了你应该如何做。 在最后一个例子中，未暂存区域是这样：",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      "    modified:   CONTRIBUTING.md",
      "它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：",
      "",
      "$ git checkout -- CONTRIBUTING.md",
      "$ git status",
      "On branch master",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "    renamed:    README.md -> README",
      "可以看到那些修改已经被撤消了。"
    ]
  },
  "git-远程仓库的使用": {
    "scope": "javascript,typescript",
    "prefix": "git-远程仓库的使用",
    "body": [
      "查看远程仓库",
      "如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin ——这是 Git 给你克隆的仓库服务器的默认名字：",
      "",
      "$ git clone https://github.com/schacon/ticgit",
      "Cloning into 'ticgit'...",
      "remote: Reusing existing pack: 1857, done.",
      "remote: Total 1857 (delta 0), reused 0 (delta 0)",
      "Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.",
      "Resolving deltas: 100% (772/772), done.",
      "Checking connectivity... done.",
      "$ cd ticgit",
      "$ git remote",
      "origin",
      "你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。",
      "",
      "$ git remote -v",
      "origin	https://github.com/schacon/ticgit (fetch)",
      "origin	https://github.com/schacon/ticgit (push)",
      "如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样：",
      "",
      "$ cd grit",
      "$ git remote -v",
      "bakkdoor  https://github.com/bakkdoor/grit (fetch)",
      "bakkdoor  https://github.com/bakkdoor/grit (push)",
      "cho45     https://github.com/cho45/grit (fetch)",
      "cho45     https://github.com/cho45/grit (push)",
      "defunkt   https://github.com/defunkt/grit (fetch)",
      "defunkt   https://github.com/defunkt/grit (push)",
      "koke      git://github.com/koke/grit.git (fetch)",
      "koke      git://github.com/koke/grit.git (push)",
      "origin    git@github.com:mojombo/grit.git (fetch)",
      "origin    git@github.com:mojombo/grit.git (push)",
      "这表示我们能非常方便地拉取其它用户的贡献。我们还可以拥有向他们推送的权限，这里暂不详述。",
      "",
      "注意这些远程仓库使用了不同的协议。我们将会在 在服务器上搭建 Git 中了解关于它们的更多信息。",
      "",
      "添加远程仓库",
      "我们在之前的章节中已经提到并展示了 git clone 命令是如何自行添加远程仓库的， 不过这里将告诉你如何自己来添加它。 运行 git remote add <shortname> <url> 添加一个新的远程 Git 仓库，同时指定一个方便使用的简写：",
      "",
      "$ git remote",
      "origin",
      "$ git remote add pb https://github.com/paulboone/ticgit",
      "$ git remote -v",
      "origin	https://github.com/schacon/ticgit (fetch)",
      "origin	https://github.com/schacon/ticgit (push)",
      "pb	https://github.com/paulboone/ticgit (fetch)",
      "pb	https://github.com/paulboone/ticgit (push)",
      "现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：",
      "",
      "$ git fetch pb",
      "remote: Counting objects: 43, done.",
      "remote: Compressing objects: 100% (36/36), done.",
      "remote: Total 43 (delta 10), reused 31 (delta 5)",
      "Unpacking objects: 100% (43/43), done.",
      "From https://github.com/paulboone/ticgit",
      " * [new branch]      master     -> pb/master",
      " * [new branch]      ticgit     -> pb/ticgit",
      "现在 Paul 的 master 分支可以在本地通过 pb/master 访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 （我们将会在 Git 分支 中详细介绍什么是分支以及如何使用分支。）",
      "",
      "从远程仓库中抓取与拉取",
      "就如刚才所见，从远程仓库中获得数据，可以执行：",
      "",
      "$ git fetch <remote>",
      "这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。",
      "",
      "如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。",
      "",
      "如果你的当前分支设置了跟踪远程分支（阅读下一节和 Git 分支 了解更多信息）， 那么可以用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。",
      "",
      "推送到远程仓库",
      "当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push <remote> <branch>。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字）， 那么运行这个命令就可以将你所做的备份到服务器：",
      "",
      "$ git push origin master",
      "只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。 阅读 Git 分支 了解如何推送到远程仓库服务器的详细信息。",
      "",
      "查看某个远程仓库",
      "如果想要查看某一个远程仓库的更多信息，可以使用 git remote show <remote> 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：",
      "",
      "$ git remote show origin",
      "* remote origin",
      "  Fetch URL: https://github.com/schacon/ticgit",
      "  Push  URL: https://github.com/schacon/ticgit",
      "  HEAD branch: master",
      "  Remote branches:",
      "    master                               tracked",
      "    dev-branch                           tracked",
      "  Local branch configured for 'git pull':",
      "    master merges with remote master",
      "  Local ref configured for 'git push':",
      "    master pushes to master (up to date)",
      "它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull， 就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。",
      "",
      "这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。",
      "",
      "$ git remote show origin",
      "* remote origin",
      "  URL: https://github.com/my-org/complex-project",
      "  Fetch URL: https://github.com/my-org/complex-project",
      "  Push  URL: https://github.com/my-org/complex-project",
      "  HEAD branch: master",
      "  Remote branches:",
      "    master                           tracked",
      "    dev-branch                       tracked",
      "    markdown-strip                   tracked",
      "    issue-43                         new (next fetch will store in remotes/origin)",
      "    issue-45                         new (next fetch will store in remotes/origin)",
      "    refs/remotes/origin/issue-11     stale (use 'git remote prune' to remove)",
      "  Local branches configured for 'git pull':",
      "    dev-branch merges with remote dev-branch",
      "    master     merges with remote master",
      "  Local refs configured for 'git push':",
      "    dev-branch                     pushes to dev-branch                     (up to date)",
      "    markdown-strip                 pushes to markdown-strip                 (up to date)",
      "    master                         pushes to master                         (up to date)",
      "这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了， 还有当你执行 git pull 时哪些本地分支可以与它跟踪的远程分支自动合并。",
      "",
      "远程仓库的重命名与移除",
      "你可以运行 git remote rename 来修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：",
      "",
      "$ git remote rename pb paul",
      "$ git remote",
      "origin",
      "paul",
      "值得注意的是这同样也会修改你所有远程跟踪的分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。",
      "",
      "如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或者某一个贡献者不再贡献了——可以使用 git remote remove 或 git remote rm ：",
      "",
      "$ git remote remove paul",
      "$ git remote",
      "origin",
      "一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。",
      "",
      "prev | next"
    ]
  },
  "git-打标签tag": {
    "scope": "javascript,typescript",
    "prefix": "git-打标签tag",
    "body": [
      "打标签",
      "像其他版本控制系统（VCS）一样，Git 可以给仓库历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（ v1.0 、 v2.0 等等）。 在本节中，你将会学习如何列出已有的标签、如何创建和删除新的标签、以及不同类型的标签分别是什么。",
      "",
      "列出标签",
      "在 Git 中列出已有的标签非常简单，只需要输入 git tag （可带上可选的 -l 选项 --list）：",
      "",
      "$ git tag",
      "v1.0",
      "v2.0",
      "这个命令以字母顺序列出标签，但是它们显示的顺序并不重要。",
      "",
      "你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣，可以运行：",
      "",
      "$ git tag -l \"v1.8.5*\"",
      "v1.8.5",
      "v1.8.5-rc0",
      "v1.8.5-rc1",
      "v1.8.5-rc2",
      "v1.8.5-rc3",
      "v1.8.5.1",
      "v1.8.5.2",
      "v1.8.5.3",
      "v1.8.5.4",
      "v1.8.5.5",
      "Note",
      "按照通配符列出标签需要 -l 或 --list 选项",
      "如果你只想要完整的标签列表，那么运行 git tag 就会默认假定你想要一个列表，它会直接给你列出来， 此时的 -l 或 --list 是可选的。",
      "",
      "然而，如果你提供了一个匹配标签名的通配模式，那么 -l 或 --list 就是强制使用的。",
      "",
      "创建标签",
      "Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。",
      "",
      "轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。",
      "",
      "而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。",
      "",
      "附注标签",
      "在 Git 中创建附注标签十分简单。 最简单的方式是当你在运行 tag 命令时指定 -a 选项：",
      "",
      "$ git tag -a v1.4 -m \"my version 1.4\"",
      "$ git tag",
      "v0.1",
      "v1.3",
      "v1.4",
      "-m 选项指定了一条将会存储在标签中的信息。 如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。",
      "",
      "通过使用 git show 命令可以看到标签信息和与之对应的提交信息：",
      "",
      "$ git show v1.4",
      "tag v1.4",
      "Tagger: Ben Straub <ben@straub.cc>",
      "Date:   Sat May 3 20:19:12 2014 -0700",
      "",
      "my version 1.4",
      "",
      "commit ca82a6dff817ec66f44342007202690a93763949",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Mon Mar 17 21:52:11 2008 -0700",
      "",
      "    changed the version number",
      "输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。",
      "",
      "轻量标签",
      "另一种给提交打标签的方式是使用轻量标签。 轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：",
      "",
      "$ git tag v1.4-lw",
      "$ git tag",
      "v0.1",
      "v1.3",
      "v1.4",
      "v1.4-lw",
      "v1.5",
      "这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：",
      "",
      "$ git show v1.4-lw",
      "commit ca82a6dff817ec66f44342007202690a93763949",
      "Author: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Mon Mar 17 21:52:11 2008 -0700",
      "",
      "    changed the version number",
      "后期打标签",
      "你也可以对过去的提交打标签。 假设提交历史是这样的：",
      "",
      "$ git log --pretty=oneline",
      "15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch 'experiment'",
      "a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support",
      "0d52aaab4479697da7686c15f77a3d64d9165190 one more thing",
      "6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch 'experiment'",
      "0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function",
      "4682c3261057305bdd616e23b64b0857d832627b added a todo file",
      "166ae0c4d3f420721acbb115cc33848dfcc2121a started write support",
      "9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile",
      "964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo",
      "8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme",
      "现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：",
      "",
      "$ git tag -a v1.2 9fceb02",
      "可以看到你已经在那次提交上打上标签了：",
      "",
      "$ git tag",
      "v0.1",
      "v1.2",
      "v1.3",
      "v1.4",
      "v1.4-lw",
      "v1.5",
      "",
      "$ git show v1.2",
      "tag v1.2",
      "Tagger: Scott Chacon <schacon@gee-mail.com>",
      "Date:   Mon Feb 9 15:32:16 2009 -0800",
      "",
      "version 1.2",
      "commit 9fceb02d0ae598e95dc970b74767f19372d61af8",
      "Author: Magnus Chacon <mchacon@gee-mail.com>",
      "Date:   Sun Apr 27 20:43:35 2008 -0700",
      "",
      "    updated rakefile",
      "...",
      "共享标签",
      "默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。",
      "",
      "$ git push origin v1.5",
      "Counting objects: 14, done.",
      "Delta compression using up to 8 threads.",
      "Compressing objects: 100% (12/12), done.",
      "Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, done.",
      "Total 14 (delta 3), reused 0 (delta 0)",
      "To git@github.com:schacon/simplegit.git",
      " * [new tag]         v1.5 -> v1.5",
      "如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。",
      "",
      "$ git push origin --tags",
      "Counting objects: 1, done.",
      "Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, done.",
      "Total 1 (delta 0), reused 0 (delta 0)",
      "To git@github.com:schacon/simplegit.git",
      " * [new tag]         v1.4 -> v1.4",
      " * [new tag]         v1.4-lw -> v1.4-lw",
      "现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。",
      "删除标签",
      "要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：",
      "",
      "$ git tag -d v1.4-lw",
      "Deleted tag 'v1.4-lw' (was e7d5add)",
      "注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：",
      "",
      "第一种变体是 git push <remote> :refs/tags/<tagname> ：",
      "",
      "$ git push origin :refs/tags/v1.4-lw",
      "To /git@github.com:schacon/simplegit.git",
      " - [deleted]         v1.4-lw",
      "上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。",
      "",
      "第二种更直观的删除远程标签的方式是：",
      "",
      "$ git push origin --delete <tagname>",
      "检出标签",
      "如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：",
      "",
      "$ git checkout 2.0.0",
      "Note: checking out '2.0.0'.",
      "",
      "You are in 'detached HEAD' state. You can look around, make experimental",
      "changes and commit them, and you can discard any commits you make in this",
      "state without impacting any branches by performing another checkout.",
      "",
      "If you want to create a new branch to retain commits you create, you may",
      "do so (now or later) by using -b with the checkout command again. Example:",
      "",
      "  git checkout -b <new-branch>",
      "",
      "HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final",
      "",
      "$ git checkout 2.0-beta-0.1",
      "Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final",
      "HEAD is now at df3f601... add atlas.json and cover image",
      "在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：",
      "",
      "$ git checkout -b version2 v2.0.0",
      "Switched to a new branch 'version2'",
      "如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了"
    ]
  },
  "git-Git 别名": {
    "scope": "javascript,typescript",
    "prefix": "git-Git 别名",
    "body": [
      "Git 别名",
      "在我们结束本章 Git 基础之前，正好有一个小技巧可以使你的 Git 体验更简单、容易、熟悉：别名。 我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。",
      "",
      "Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：",
      "",
      "$ git config --global alias.co checkout",
      "$ git config --global alias.br branch",
      "$ git config --global alias.ci commit",
      "$ git config --global alias.st status",
      "这意味着，当要输入 git commit 时，只需要输入 git ci。 随着你继续不断地使用 Git，可能也会经常使用其他命令，所以创建别名时不要犹豫。",
      "",
      "在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：",
      "",
      "$ git config --global alias.unstage 'reset HEAD --'",
      "这会使下面的两个命令等价：",
      "",
      "$ git unstage fileA",
      "$ git reset HEAD -- fileA",
      "这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：",
      "",
      "$ git config --global alias.last 'log -1 HEAD'",
      "这样，可以轻松地看到最后一次提交：",
      "",
      "$ git last",
      "commit 66938dae3329c7aebe598c2246a8e6af90d04646",
      "Author: Josh Goebel <dreamer3@example.com>",
      "Date:   Tue Aug 26 19:48:51 2008 +0800",
      "",
      "    test for current head",
      "",
      "    Signed-off-by: Scott Chacon <schacon@example.com>",
      "可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：",
      "",
      "$ git config --global alias.visual '!gitk'"
    ]
  },
  "git-分支简介": {
    "scope": "javascript,typescript",
    "prefix": "git-分支简介",
    "body": [
      "分支简介",
      "为了真正理解 Git 处理分支的方式，我们需要回顾一下 Git 是如何保存数据的。",
      "",
      "或许你还记得 起步 的内容， Git 保存的不是文件的变化或者差异，而是一系列不同时刻的 快照 。",
      "",
      "在进行提交操作时，Git 会保存一个提交对象（commit object）。 知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象，",
      "",
      "为了更加形象地说明，我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用我们在 起步 中提到的 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：",
      "",
      "$ git add README test.rb LICENSE",
      "$ git commit -m 'The initial commit of my project'",
      "当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。",
      "",
      "现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树 对象 （记录着目录结构和 blob 对象索引）以及一个 提交 对象（包含着指向前述树对象的指针和所有提交信息）。",
      "",
      "首次提交对象及其树结构。",
      "Figure 9. 首次提交对象及其树结构",
      "做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。",
      "",
      "提交对象及其父对象。",
      "Figure 10. 提交对象及其父对象",
      "Git 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。",
      "分支创建",
      "Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：",
      "",
      "$ git branch testing",
      "这会在当前所在的提交对象上创建一个指针。",
      "",
      "两个指向相同提交历史的分支。",
      "Figure 12. 两个指向相同提交历史的分支",
      "那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。",
      "",
      "HEAD 指向当前所在的分支。",
      "Figure 13. HEAD 指向当前所在的分支",
      "你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。",
      "",
      "$ git log --oneline --decorate",
      "f30ab (HEAD -> master, testing) add feature #32 - ability to add new formats to the central interface",
      "34ac2 Fixed bug #1328 - stack overflow under certain conditions",
      "98ca9 The initial commit of my project",
      "正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。",
      "",
      "分支切换",
      "要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：",
      "",
      "$ git checkout testing",
      "这样 HEAD 就指向 testing 分支了。",
      "",
      "HEAD 指向当前所在的分支。",
      "Figure 14. HEAD 指向当前所在的分支",
      "那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：",
      "",
      "$ vim test.rb",
      "$ git commit -a -m 'made a change'",
      "HEAD 分支随着提交操作自动向前移动。",
      "Figure 15. HEAD 分支随着提交操作自动向前移动",
      "如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：",
      "",
      "$ git checkout master",
      "检出时 HEAD 随之移动。",
      "Figure 16. 检出时 HEAD 随之移动",
      "这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。",
      "我们不妨再稍微做些修改并提交：",
      "",
      "$ vim test.rb",
      "$ git commit -a -m 'made other changes'",
      "现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。",
      "",
      "项目分叉历史。",
      "Figure 17. 项目分叉历史",
      "你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。",
      "",
      "$ git log --oneline --decorate --graph --all",
      "* c2b9e (HEAD, master) made other changes",
      "| * 87ab2 (testing) made a change",
      "|/",
      "* f30ab add feature #32 - ability to add new formats to the",
      "* 34ac2 fixed bug #1328 - stack overflow under certain conditions",
      "* 98ca9 initial commit of my project",
      "由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？",
      "",
      "这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。",
      "",
      "接下来，让我们看看你为什么应该这样做。"
    ]
  },
  "git-分支的新建与合并": {
    "scope": "javascript,typescript",
    "prefix": "git-分支的新建与合并",
    "body": [
      "分支的新建与合并",
      "让我们来看一个简单的分支新建与分支合并的例子，实际工作中你可能会用到类似的工作流。 你将经历如下步骤：",
      "",
      "开发某个网站。",
      "",
      "为实现某个新的用户需求，创建一个分支。",
      "",
      "在这个分支上开展工作。",
      "",
      "正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：",
      "",
      "切换到你的线上分支（production branch）。",
      "",
      "为这个紧急任务新建一个分支，并在其中修复它。",
      "",
      "在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。",
      "",
      "切换回你最初工作的分支上，继续工作。",
      "",
      "新建分支",
      "首先，我们假设你正在你的项目上工作，并且在 master 分支上已经有了一些提交。",
      "",
      "一个简单的提交历史。",
      "Figure 18. 一个简单提交历史",
      "现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。 想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 -b 参数的 git checkout 命令：",
      "",
      "$ git checkout -b iss53",
      "Switched to a new branch \"iss53\"",
      "它是下面两条命令的简写：",
      "",
      "$ git branch iss53",
      "$ git checkout iss53",
      "创建一个新分支指针。",
      "Figure 19. 创建一个新分支指针",
      "你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支 （也就是说，你的 HEAD 指针指向了 iss53 分支）",
      "",
      "$ vim index.html",
      "$ git commit -a -m 'added a new footer [issue 53]'",
      "`iss53` 分支随着工作的进展向前推进。",
      "Figure 20. iss53 分支随着工作的进展向前推进",
      "现在你接到那个电话，有个紧急问题等待你来解决。 有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起， 你也不需要花大力气来还原关于 53# 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。 你所要做的仅仅是切换回 master 分支。",
      "",
      "但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改， 它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。 有一些方法可以绕过这个问题（即，暂存（stashing） 和 修补提交（commit amending））， 我们会在 贮藏与清理 中看到关于这两个命令的介绍。 现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 master 分支了：",
      "",
      "$ git checkout master",
      "Switched to branch 'master'",
      "这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。",
      "",
      "接下来，你要修复这个紧急问题。 我们来建立一个 hotfix 分支，在该分支上工作直到问题解决：",
      "",
      "$ git checkout -b hotfix",
      "Switched to a new branch 'hotfix'",
      "$ vim index.html",
      "$ git commit -a -m 'fixed the broken email address'",
      "[hotfix 1fb7853] fixed the broken email address",
      " 1 file changed, 2 insertions(+)",
      "基于 `master` 分支的紧急问题分支（hotfix branch）。",
      "Figure 21. 基于 master 分支的紧急问题分支 hotfix branch",
      "你可以运行你的测试，确保你的修改是正确的，然后将 hotfix 分支合并回你的 master 分支来部署到线上。 你可以使用 git merge 命令来达到上述目的：",
      "",
      "$ git checkout master",
      "$ git merge hotfix",
      "Updating f42c576..3a0874c",
      "Fast-forward",
      " index.html | 2 ++",
      " 1 file changed, 2 insertions(+)",
      "在合并的时候，你应该注意到了“快进（fast-forward）”这个词。 由于你想要合并的分支 hotfix 所指向的提交 C4 是你所在的提交 C2 的直接后继， 因此 Git 会直接将指针向前移动。换句话说，当你试图合并两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。",
      "",
      "现在，最新的修改已经在 master 分支所指向的提交快照中，你可以着手发布该修复了。",
      "",
      "`master` 被快进到 `hotfix`。",
      "Figure 22. master 被快进到 hotfix",
      "关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix 分支，因为你已经不再需要它了 —— master 分支已经指向了同一个位置。 你可以使用带 -d 选项的 git branch 命令来删除分支：",
      "",
      "$ git branch -d hotfix",
      "Deleted branch hotfix (3a0874c).",
      "现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（iss53 分支）。",
      "",
      "$ git checkout iss53",
      "Switched to branch \"iss53\"",
      "$ vim index.html",
      "$ git commit -a -m 'finished the new footer [issue 53]'",
      "[iss53 ad82d7a] finished the new footer [issue 53]",
      "1 file changed, 1 insertion(+)",
      "继续在 `iss53` 分支上的工作。",
      "Figure 23. 继续在 iss53 分支上的工作",
      "你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改，你可以使用 git merge master 命令将 master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支。",
      "",
      "分支的合并",
      "假设你已经修正了 #53 问题，并且打算将你的工作合并入 master 分支。 为此，你需要合并 iss53 分支到 master 分支，这和之前你合并 hotfix 分支所做的工作差不多。 你只需要检出到你想合并入的分支，然后运行 git merge 命令：",
      "",
      "$ git checkout master",
      "Switched to branch 'master'",
      "$ git merge iss53",
      "Merge made by the 'recursive' strategy.",
      "index.html |    1 +",
      "1 file changed, 1 insertion(+)",
      "这和你之前合并 hotfix 分支的时候看起来有一点不一样。 在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做一个简单的三方合并。",
      "",
      "一次典型合并中所用到的三个快照。",
      "Figure 24. 一次典型合并中所用到的三个快照",
      "和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。",
      "",
      "一个合并提交。",
      "Figure 25. 一个合并提交",
      "既然你的修改已经合并进来了，就不再需要 iss53 分支了。 现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。",
      "",
      "$ git branch -d iss53",
      "遇到冲突时的分支合并",
      "有时候合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。 如果你对 #53 问题的修改和有关 hotfix 分支的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：",
      "",
      "$ git merge iss53",
      "Auto-merging index.html",
      "CONFLICT (content): Merge conflict in index.html",
      "Automatic merge failed; fix conflicts and then commit the result.",
      "此时 Git 做了合并，但是没有自动地创建一个新的合并提交。 Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：",
      "",
      "$ git status",
      "On branch master",
      "You have unmerged paths.",
      "  (fix conflicts and run \"git commit\")",
      "",
      "Unmerged paths:",
      "  (use \"git add <file>...\" to mark resolution)",
      "",
      "    both modified:      index.html",
      "",
      "no changes added to commit (use \"git add\" and/or \"git commit -a\")",
      "任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：",
      "",
      "<<<<<<< HEAD:index.html",
      "<div id=\"footer\">contact : email.support@github.com</div>",
      "=======",
      "<div id=\"footer\">",
      " please contact us at support@github.com",
      "</div>",
      ">>>>>>> iss53:index.html",
      "这表示 HEAD 所指示的版本（也就是你的 master 分支所在的位置，因为你在运行 merge 命令的时候已经检出到了这个分支）在这个区段的上半部分（======= 的上半部分），而 iss53 分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个，或者你也可以自行合并这些内容。 例如，你可以通过把这段内容换成下面的样子来解决冲突：",
      "",
      "<div id=\"footer\">",
      "please contact us at email.support@github.com",
      "</div>",
      "上述的冲突解决方案仅保留了其中一个分支的修改，并且 <<<<<<< , ======= , 和 >>>>>>> 这些行被完全删除了。 在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。",
      "",
      "如果你想使用图形化工具来解决冲突，你可以运行 git mergetool，该命令会为你启动一个合适的可视化合并工具，并带领你一步一步解决这些冲突：",
      "",
      "$ git mergetool",
      "",
      "This message is displayed because 'merge.tool' is not configured.",
      "See 'git mergetool --tool-help' or 'git help config' for more details.",
      "'git mergetool' will now attempt to use one of the following tools:",
      "opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge",
      "Merging:",
      "index.html",
      "",
      "Normal merge conflict for 'index.html':",
      "  {local}: modified file",
      "  {remote}: modified file",
      "Hit return to start merge resolution tool (opendiff):",
      "如果你想使用除默认工具（在这里 Git 使用 opendiff 做为默认的合并工具，因为作者在 Mac 上运行该程序） 外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。",
      "",
      "Note",
      "如果你需要更加高级的工具来解决复杂的合并冲突，我们会在 高级合并 介绍更多关于分支合并的内容。",
      "",
      "等你退出合并工具之后，Git 会询问刚才的合并是否成功。 如果你回答是，Git 会暂存那些文件以表明冲突已解决： 你可以再次运行 git status 来确认所有的合并冲突都已被解决：",
      "",
      "$ git status",
      "On branch master",
      "All conflicts fixed but you are still merging.",
      "  (use \"git commit\" to conclude merge)",
      "",
      "Changes to be committed:",
      "",
      "    modified:   index.html",
      "如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。 默认情况下提交信息看起来像下面这个样子：",
      "",
      "Merge branch 'iss53'",
      "",
      "Conflicts:",
      "    index.html",
      "#",
      "# It looks like you may be committing a merge.",
      "# If this is not correct, please remove the file",
      "# .git/MERGE_HEAD",
      "# and try again.",
      "",
      "",
      "# Please enter the commit message for your changes. Lines starting",
      "# with '#' will be ignored, and an empty message aborts the commit.",
      "# On branch master",
      "# All conflicts fixed but you are still merging.",
      "#",
      "# Changes to be committed:",
      "# modified:   index.html",
      "#",
      "如果你觉得上述的信息不够充分，不能完全体现分支合并的过程，你可以修改上述信息， 添加一些细节给未来检视这个合并的读者一些帮助，告诉他们你是如何解决合并冲突的，以及理由是什么。"
    ]
  },
  "git-分支管理": {
    "scope": "javascript,typescript",
    "prefix": "git-分支管理",
    "body": [
      "分支管理",
      "现在已经创建、合并、删除了一些分支，让我们看看一些常用的分支管理工具。",
      "",
      "git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表：",
      "",
      "$ git branch",
      "  iss53",
      "* master",
      "  testing",
      "注意 master 分支前的 * 字符：它代表现在检出的那一个分支（也就是说，当前 HEAD 指针所指向的分支）。 这意味着如果在这时候提交，master 分支将会随着新的工作向前移动。 如果需要查看每一个分支的最后一次提交，可以运行 git branch -v 命令：",
      "",
      "$ git branch -v",
      "  iss53   93b412c fix javascript issue",
      "* master  7a98805 Merge branch 'iss53'",
      "  testing 782fd34 add scott to the author list in the readmes",
      "--merged 与 --no-merged 这两个有用的选项可以过滤这个列表中已经合并或尚未合并到当前分支的分支。 如果要查看哪些分支已经合并到当前分支，可以运行 git branch --merged：",
      "",
      "$ git branch --merged",
      "  iss53",
      "* master",
      "因为之前已经合并了 iss53 分支，所以现在看到它在列表中。 在这个列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；你已经将它们的工作整合到了另一个分支，所以并不会失去任何东西。",
      "",
      "查看所有包含未合并工作的分支，可以运行 git branch --no-merged：",
      "",
      "$ git branch --no-merged",
      "  testing",
      "这里显示了其他分支。 因为它包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败：",
      "",
      "$ git branch -d testing",
      "error: The branch 'testing' is not fully merged.",
      "If you are sure you want to delete it, run 'git branch -D testing'.",
      "如果真的想要删除分支并丢掉那些工作，如同帮助信息里所指出的，可以使用 -D 选项强制删除它"
    ]
  },
  "git-远程分支（创建）": {
    "scope": "javascript,typescript",
    "prefix": "git-远程分支(创建)",
    "body": [
      "远程分支",
      "远程引用是对远程仓库的引用（指针），包括分支、标签等等。 你可以通过 git ls-remote <remote> 来显式地获得远程引用的完整列表， 或者通过 git remote show <remote> 获得远程分支的更多信息。 然而，一个更常见的做法是利用远程跟踪分支。",
      "",
      "远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。",
      "",
      "它们以 <remote>/<branch> 的形式命名。 例如，如果你想要看你最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。",
      "",
      "这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。",
      "",
      "Note",
      "“origin” 并无特殊含义",
      "远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。",
      "",
      "克隆之后的服务器与本地仓库。",
      "Figure 30. 克隆之后的服务器与本地仓库",
      "如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。",
      "",
      "本地与远程的工作可以分叉。",
      "Figure 31. 本地与远程的工作可以分叉",
      "如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。",
      "",
      "`git fetch` 更新你的远程仓库引用。",
      "Figure 32. git fetch 更新你的远程跟踪分支",
      "为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 URL 的缩写。",
      "",
      "添加另一个远程仓库。",
      "Figure 33. 添加另一个远程仓库",
      "现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。",
      "",
      "远程跟踪分支 `teamone/master`。",
      "Figure 34. 远程跟踪分支 teamone/master",
      "推送",
      "当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。",
      "",
      "如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:",
      "",
      "$ git push origin serverfix",
      "Counting objects: 24, done.",
      "Delta compression using up to 8 threads.",
      "Compressing objects: 100% (15/15), done.",
      "Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.",
      "Total 24 (delta 2), reused 0 (delta 0)",
      "To https://github.com/schacon/simplegit",
      " * [new branch]      serverfix -> serverfix",
      "这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。 如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。",
      "",
      "Note",
      "如何避免每次输入密码",
      "如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。",
      "",
      "如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config --global credential.helper cache 来设置它。",
      "",
      "想要了解更多关于不同验证缓存的可用选项，查看 凭证存储。",
      "",
      "下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：",
      "",
      "$ git fetch origin",
      "remote: Counting objects: 7, done.",
      "remote: Compressing objects: 100% (2/2), done.",
      "remote: Total 3 (delta 0), reused 3 (delta 0)",
      "Unpacking objects: 100% (3/3), done.",
      "From https://github.com/schacon/simplegit",
      " * [new branch]      serverfix    -> origin/serverfix",
      "要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。",
      "",
      "可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：",
      "",
      "$ git checkout -b serverfix origin/serverfix",
      "Branch serverfix set up to track remote branch serverfix from origin.",
      "Switched to a new branch 'serverfix'",
      "这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。",
      "",
      "跟踪分支",
      "从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。",
      "",
      "当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：",
      "",
      "$ git checkout --track origin/serverfix",
      "Branch serverfix set up to track remote branch serverfix from origin.",
      "Switched to a new branch 'serverfix'",
      "由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：",
      "",
      "$ git checkout serverfix",
      "Branch serverfix set up to track remote branch serverfix from origin.",
      "Switched to a new branch 'serverfix'",
      "如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：",
      "",
      "$ git checkout -b sf origin/serverfix",
      "Branch sf set up to track remote branch serverfix from origin.",
      "Switched to a new branch 'sf'",
      "现在，本地分支 sf 会自动从 origin/serverfix 拉取。",
      "",
      "设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。",
      "",
      "$ git branch -u origin/serverfix",
      "Branch serverfix set up to track remote branch serverfix from origin.",
      "Note",
      "上游快捷方式",
      "当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在 master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u} 来取代 git merge origin/master。",
      "",
      "如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。",
      "",
      "$ git branch -vv",
      "  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets",
      "  master    1ae2a45 [origin/master] deploying index fix",
      "* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it",
      "  testing   5ea463a trying something new",
      "这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。",
      "",
      "需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：",
      "",
      "$ git fetch --all; git branch -vv",
      "拉取",
      "当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。",
      "",
      "由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。",
      "",
      "删除远程分支",
      "假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：",
      "",
      "$ git push origin --delete serverfix",
      "To https://github.com/schacon/simplegit",
      " - [deleted]         serverfix",
      "基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。"
    ]
  },
  "git-变基rebase": {
    "scope": "javascript,typescript",
    "prefix": "git-变基rebase",
    "body": [
      "变基",
      "在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。",
      "",
      "变基的基本操作",
      "请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。",
      "",
      "分叉的提交历史。",
      "Figure 35. 分叉的提交历史",
      "之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。",
      "",
      "通过合并操作来整合分叉了的历史。",
      "Figure 36. 通过合并操作来整合分叉的历史",
      "其实，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。",
      "",
      "在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：",
      "",
      "$ git checkout experiment",
      "$ git rebase master",
      "First, rewinding head to replay your work on top of it...",
      "Applying: added staged command",
      "它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）",
      "",
      "将 `C4` 中的修改变基到 `C3` 上。",
      "Figure 37. 将 C4 中的修改变基到 C3 上",
      "现在回到 master 分支，进行一次快进合并。",
      "",
      "$ git checkout master",
      "$ git merge experiment",
      "`master` 分支的快进合并。",
      "Figure 38. master 分支的快进合并",
      "此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。",
      "",
      "一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。",
      "",
      "请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。",
      "",
      "更有趣的变基例子",
      "在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。",
      "",
      "从一个主题分支里再分出一个主题分支的提交历史。",
      "Figure 39. 从一个主题分支里再分出一个主题分支的提交历史",
      "假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：",
      "",
      "$ git rebase --onto master server client",
      "以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。",
      "",
      "截取主题分支上的另一个主题分支，然后变基到其他分支。",
      "Figure 40. 截取主题分支上的另一个主题分支，然后变基到其他分支",
      "现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：",
      "",
      "$ git checkout master",
      "$ git merge client",
      "快进合并 `master` 分支，使之包含来自 `client` 分支的修改。",
      "Figure 41. 快进合并 master 分支，使之包含来自 client 分支的修改",
      "接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。",
      "",
      "$ git rebase master server",
      "如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。",
      "",
      "将 `server` 中的修改变基到 `master` 上。",
      "Figure 42. 将 server 中的修改变基到 master 上",
      "然后就可以快进合并主分支 master 了：",
      "",
      "$ git checkout master",
      "$ git merge server",
      "至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：",
      "",
      "$ git branch -d client",
      "$ git branch -d server",
      "最终的提交历史。",
      "Figure 43. 最终的提交历史",
      "变基的风险",
      "呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：",
      "",
      "如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。",
      "",
      "如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。",
      "",
      "变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。",
      "",
      "让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：",
      "",
      "克隆一个仓库，然后在它的基础上进行了一些开发。",
      "Figure 44. 克隆一个仓库，然后在它的基础上进行了一些开发",
      "然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：",
      "",
      "抓取别人的提交，合并到自己的开发分支。",
      "Figure 45. 抓取别人的提交，合并到自己的开发分支",
      "接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。",
      "",
      "有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。",
      "Figure 46. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交",
      "结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：",
      "",
      "你将相同的内容又合并了一次，生成了一个新的提交。",
      "Figure 47. 你将相同的内容又合并了一次，生成了一个新的提交",
      "此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。",
      "",
      "用变基解决变基",
      "如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。",
      "",
      "实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。",
      "",
      "如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。",
      "",
      "举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会：",
      "",
      "检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）",
      "",
      "检查其中哪些提交不是合并操作的结果（C2，C3，C4）",
      "",
      "检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）",
      "",
      "把查到的这些提交应用在 teamone/master 上面",
      "",
      "从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。",
      "",
      "在一个被变基然后强制推送的分支上再次执行变基。",
      "Figure 48. 在一个被变基然后强制推送的分支上再次执行变基",
      "要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。",
      "",
      "在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。",
      "",
      "如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。",
      "",
      "如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。",
      "",
      "如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。",
      "",
      "变基 vs. 合并",
      "至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。",
      "",
      "有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。",
      "",
      "另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。",
      "",
      "现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。",
      "",
      "总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。"
    ]
  },
  "git-": {
    "scope": "javascript,typescript",
    "prefix": "git-",
    "body": []
  },
  "git-重置揭密reset": {
    "scope": "javascript,typescript",
    "prefix": "git-重置揭密reset",
    "body": [
      "HEAD",
      "HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。",
      "",
      "其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：",
      "",
      "$ git cat-file -p HEAD",
      "tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf",
      "author Scott Chacon  1301511835 -0700",
      "committer Scott Chacon  1301511835 -0700",
      "",
      "initial commit",
      "",
      "$ git ls-tree -r HEAD",
      "100644 blob a906cb2a4a904a152...   README",
      "100644 blob 8f94139338f9404f2...   Rakefile",
      "040000 tree 99f1a6d12cb4b6f19...   lib",
      "Git 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。",
      "",
      "索引",
      "索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。",
      "",
      "Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。",
      "",
      "$ git ls-files -s",
      "100644 a906cb2a4a904a152e80877d4088654daad0c859 0	README",
      "100644 8f94139338f9404f26296befa88755fc2598c289 0	Rakefile",
      "100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0	lib/simplegit.rb",
      "再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。",
      "",
      "确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。",
      "",
      "工作目录",
      "最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。",
      "",
      "$ tree",
      ".",
      "├── README",
      "├── Rakefile",
      "└── lib",
      "    └── simplegit.rb",
      "",
      "1 directory, 3 files",
      "工作流程",
      "经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。",
      "",
      "reset workflow",
      "让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 master 分支。",
      "",
      "reset ex1",
      "此时，只有工作目录有内容。",
      "",
      "现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。",
      "",
      "reset ex2",
      "接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。",
      "",
      "reset ex3",
      "此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。",
      "",
      "现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。",
      "",
      "reset ex4",
      "如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。",
      "",
      "reset ex5",
      "此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。",
      "",
      "reset ex6",
      "现在运行 git status 会没有输出，因为三棵树又变得相同了。",
      "",
      "切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。",
      "",
      "重置的作用",
      "在以下情景中观察 reset 命令会更有意义。",
      "",
      "为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：",
      "",
      "reset start",
      "让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。",
      "",
      "第 1 步：移动 HEAD",
      "reset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。",
      "",
      "reset soft",
      "无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。",
      "",
      "现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。",
      "",
      "第 2 步：更新索引（--mixed）",
      "注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。",
      "",
      "接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。",
      "",
      "reset mixed",
      "如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。",
      "",
      "现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。",
      "",
      "第 3 步：更新工作目录（--hard）",
      "reset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。",
      "",
      "reset hard",
      "现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。",
      "",
      "必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。",
      "",
      "回顾",
      "reset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：",
      "",
      "移动 HEAD 分支的指向 （若指定了 --soft，则到此停止）",
      "",
      "使索引看起来像 HEAD （若未指定 --hard，则到此停止）",
      "",
      "使工作目录看起来像索引",
      "",
      "通过路径来重置",
      "前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。",
      "",
      "现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会：",
      "",
      "移动 HEAD 分支的指向 （已跳过）",
      "",
      "让索引看起来像 HEAD （到此处停止）",
      "",
      "所以它本质上只是将 file.txt 从 HEAD 复制到索引中。",
      "",
      "reset path1",
      "它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。",
      "",
      "reset path2",
      "这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）",
      "",
      "我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。",
      "",
      "reset path3",
      "它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。",
      "",
      "还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。",
      "",
      "压缩",
      "我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。",
      "",
      "假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）",
      "",
      "假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。",
      "",
      "reset squash r1",
      "那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：",
      "",
      "reset squash r2",
      "然后只需再次运行 git commit：",
      "",
      "reset squash r3",
      "现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。",
      "",
      "检出",
      "最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。",
      "",
      "不带路径",
      "运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。",
      "",
      "首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。",
      "",
      "第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。",
      "",
      "例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。",
      "",
      "所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。",
      "",
      "reset checkout",
      "带路径",
      "运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。",
      "",
      "此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。",
      "",
      "总结",
      "希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。",
      "",
      "下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。"
    ]
  },
  "git-选择修订版本": {
    "scope": "javascript,typescript",
    "prefix": "git-选择修订版本",
    "body": [
      "选择修订版本",
      "Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。",
      "",
      "单个修订版本",
      "你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。",
      "",
      "简短的 SHA-1",
      "Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。",
      "",
      "例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：",
      "",
      "$ git log",
      "commit 734713bc047d87bf7eac9674765ae793478c50d3",
      "Author: Scott Chacon <schacon@gmail.com>",
      "Date:   Fri Jan 2 18:32:33 2009 -0800",
      "",
      "    fixed refs handling, added gc auto, updated tests",
      "",
      "commit d921970aadf03b3cf0e71becdaab3147ba71cdef",
      "Merge: 1c002dd... 35cfb2b...",
      "Author: Scott Chacon <schacon@gmail.com>",
      "Date:   Thu Dec 11 15:08:43 2008 -0800",
      "",
      "    Merge commit 'phedders/rdocs'",
      "",
      "commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b",
      "Author: Scott Chacon <schacon@gmail.com>",
      "Date:   Thu Dec 11 14:58:32 2008 -0800",
      "",
      "    added some blame and merge stuff",
      "在本例中，假设你想要的提交其 SHA-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：",
      "",
      "$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b",
      "$ git show 1c002dd4b536e7479f",
      "$ git show 1c002d",
      "Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：",
      "",
      "$ git log --abbrev-commit --pretty=oneline",
      "ca82a6d changed the version number",
      "085bb3b removed unnecessary test code",
      "a11bef0 first commit",
      "通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。",
      "分支引用",
      "引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。 例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：",
      "",
      "$ git show ca82a6dff817ec66f44342007202690a93763949",
      "$ git show topic1",
      "如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse",
      "",
      "$ git rev-parse topic1",
      "ca82a6dff817ec66f44342007202690a93763949",
      "引用日志",
      "当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。",
      "",
      "你可以使用 git reflog 来查看引用日志",
      "",
      "$ git reflog",
      "734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated",
      "d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.",
      "1c002dd HEAD@{2}: commit: added some blame and merge stuff",
      "1c36188 HEAD@{3}: rebase -i (squash): updating HEAD",
      "95df984 HEAD@{4}: commit: # This is a combination of two commits.",
      "1c36188 HEAD@{5}: rebase -i (squash): updating HEAD",
      "7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD",
      "每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。",
      "",
      "$ git show HEAD@{5}",
      "你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入",
      "",
      "$ git show master@{yesterday}",
      "就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。",
      "",
      "可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：",
      "",
      "$ git log -g master",
      "commit 734713bc047d87bf7eac9674765ae793478c50d3",
      "Reflog: master@{0} (Scott Chacon <schacon@gmail.com>)",
      "Reflog message: commit: fixed refs handling, added gc auto, updated",
      "Author: Scott Chacon <schacon@gmail.com>",
      "Date:   Fri Jan 2 18:32:33 2009 -0800",
      "",
      "    fixed refs handling, added gc auto, updated tests",
      "",
      "commit d921970aadf03b3cf0e71becdaab3147ba71cdef",
      "Reflog: master@{1} (Scott Chacon <schacon@gmail.com>)",
      "Reflog message: merge phedders/rdocs: Merge made by recursive.",
      "Author: Scott Chacon <schacon@gmail.com>",
      "Date:   Thu Dec 11 15:08:43 2008 -0800",
      "",
      "    Merge commit 'phedders/rdocs'",
      "值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。"
    ]
  },
  "git-交互式暂存": {
    "scope": "javascript,typescript",
    "prefix": "git-交互式暂存",
    "body": [
      "交互式暂存",
      "本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：",
      "",
      "$ git add -i",
      "           staged     unstaged path",
      "  1:    unchanged        +0/-1 TODO",
      "  2:    unchanged        +1/-1 index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "",
      "*** Commands ***",
      "  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked",
      "  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp",
      "What now>",
      "可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。",
      "",
      "在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。",
      "",
      "暂存与取消暂存文件",
      "如果在 What now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：",
      "",
      "What now> u",
      "           staged     unstaged path",
      "  1:    unchanged        +0/-1 TODO",
      "  2:    unchanged        +1/-1 index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "Update>>",
      "要暂存 TODO 和 index.html 文件，可以输入数字：",
      "",
      "Update>> 1,2",
      "           staged     unstaged path",
      "* 1:    unchanged        +0/-1 TODO",
      "* 2:    unchanged        +1/-1 index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "Update>>",
      "每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update>> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：",
      "",
      "Update>>",
      "updated 2 paths",
      "",
      "*** Commands ***",
      "  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked",
      "  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp",
      "What now> s",
      "           staged     unstaged path",
      "  1:        +0/-1      nothing TODO",
      "  2:        +1/-1      nothing index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 r 或 3（撤消）选项：",
      "",
      "*** Commands ***",
      "  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked",
      "  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp",
      "What now> r",
      "           staged     unstaged path",
      "  1:        +0/-1      nothing TODO",
      "  2:        +1/-1      nothing index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "Revert>> 1",
      "           staged     unstaged path",
      "* 1:        +0/-1      nothing TODO",
      "  2:        +1/-1      nothing index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "Revert>> [enter]",
      "reverted one path",
      "再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：",
      "",
      "*** Commands ***",
      "  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked",
      "  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp",
      "What now> s",
      "           staged     unstaged path",
      "  1:    unchanged        +0/-1 TODO",
      "  2:        +1/-1      nothing index.html",
      "  3:    unchanged        +5/-1 lib/simplegit.rb",
      "如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：",
      "",
      "*** Commands ***",
      "  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked",
      "  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp",
      "What now> d",
      "           staged     unstaged path",
      "  1:        +1/-1      nothing index.html",
      "Review diff>> 1",
      "diff --git a/index.html b/index.html",
      "index 4d07108..4335f49 100644",
      "--- a/index.html",
      "+++ b/index.html",
      "@@ -16,7 +16,7 @@ Date Finder",
      "",
      " <p id=\"out\">...</p>",
      "",
      "-<div id=\"footer\">contact : support@github.com</div>",
      "+<div id=\"footer\">contact : email.support@github.com</div>",
      "",
      " <script type=\"text/javascript\">",
      "通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。",
      "",
      "暂存补丁",
      "Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：",
      "",
      "diff --git a/lib/simplegit.rb b/lib/simplegit.rb",
      "index dd5ecc4..57399e0 100644",
      "--- a/lib/simplegit.rb",
      "+++ b/lib/simplegit.rb",
      "@@ -22,7 +22,7 @@ class SimpleGit",
      "   end",
      "",
      "   def log(treeish = 'master')",
      "-    command(\"git log -n 25 #{treeish}\")",
      "+    command(\"git log -n 30 #{treeish}\")",
      "   end",
      "",
      "   def blame(path)",
      "Stage this hunk [y,n,a,d,/,j,J,g,e,?]?",
      "这时有很多选项。 输入 ? 显示所有可以使用的命令列表：",
      "",
      "Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?",
      "y - stage this hunk",
      "n - do not stage this hunk",
      "a - stage this and all the remaining hunks in the file",
      "d - do not stage this hunk nor any of the remaining hunks in the file",
      "g - select a hunk to go to",
      "/ - search for a hunk matching the given regex",
      "j - leave this hunk undecided, see next undecided hunk",
      "J - leave this hunk undecided, see next hunk",
      "k - leave this hunk undecided, see previous undecided hunk",
      "K - leave this hunk undecided, see previous hunk",
      "s - split the current hunk into smaller hunks",
      "e - manually edit the current hunk",
      "? - print help",
      "通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：",
      "",
      "What now> 1",
      "           staged     unstaged path",
      "  1:    unchanged        +0/-1 TODO",
      "  2:        +1/-1      nothing index.html",
      "  3:        +1/-1        +4/-0 lib/simplegit.rb",
      "simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。",
      "",
      "也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。",
      "",
      "更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。"
    ]
  },
  "git-贮藏与清理stash": {
    "scope": "javascript,typescript",
    "prefix": "git-贮藏与清理stash",
    "body": [
      "迁移到 git stash push",
      "截至 2017 年 10 月下旬，Git 邮件列表上进行了广泛讨论，该讨论中弃用了 git stash save 命令， 代之以现有 git stash push 命令。主因是 git stash push 引入了贮藏选定的 路径规范 的选项， 而有些东西 git stash save 不支持。",
      "",
      "git stash save 不会很快就消失，所以不用担心它突然不见。 不过你可能想要迁移到 push 来获取新功能。",
      "贮藏工作",
      "为了演示贮藏，你需要进入项目并改动几个文件，然后可以暂存其中的一个改动。 如果运行 git status，可以看到有改动的状态：",
      "",
      "$ git status",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      "modified:   index.html",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      " modified:   lib/simplegit.rb",
      "现在想要切换分支，但是还不想要提交之前的工作；所以贮藏修改。 将新的贮藏推送到栈上，运行 git stash 或 git stash push：",
      "",
      "$ git stash",
      "HEAD is now at 049d078 added the index file",
      "(To restore them type \"git stash apply\")",
      "可以看到工作目录是干净的了：",
      "",
      "$ git status",
      "# On branch master",
      "nothing to commit, working directory clean",
      "此时，你可以切换分支并在其他地方工作；你的修改被存储在栈上。 要查看贮藏的东西，可以使用 git stash list：",
      "",
      "$ git stash list",
      "stash@{0}: WIP on master: 049d078 added the index file",
      "stash@{1}: WIP on master: c264051 Revert \"added file_size\"",
      "stash@{2}: WIP on master: 21d80a5 added number to log",
      "在本例中，有两个之前的贮藏，所以你接触到了三个不同的贮藏工作。 可以通过原来 stash 命令的帮助提示中的命令将你刚刚贮藏的工作重新应用：git stash apply。 如果想要应用其中一个更旧的贮藏，可以通过名字指定它，像这样：git stash apply stash@{2}。 如果不指定一个贮藏，Git 认为指定的是最近的贮藏：",
      "",
      "$ git stash apply",
      "On branch master",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      " modified:   index.html",
      " modified:   lib/simplegit.rb",
      "",
      "no changes added to commit (use \"git add\" and/or \"git commit -a\")",
      "可以看到 Git 重新修改了当你保存贮藏时撤消的文件。 在本例中，当尝试应用贮藏时有一个干净的工作目录，并且尝试将它应用在保存它时所在的分支。 并不是必须要有一个干净的工作目录，或者要应用到同一分支才能成功应用贮藏。 可以在一个分支上保存一个贮藏，切换到另一个分支，然后尝试重新应用这些修改。 当应用贮藏时工作目录中也可以有修改与未提交的文件——如果有任何东西不能干净地应用，Git 会产生合并冲突。",
      "",
      "文件的改动被重新应用了，但是之前暂存的文件却没有重新暂存。 想要那样的话，必须使用 --index 选项来运行 git stash apply 命令，来尝试重新应用暂存的修改。 如果已经那样做了，那么你将回到原来的位置：",
      "",
      "$ git stash apply --index",
      "On branch master",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      " modified:   index.html",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      " modified:   lib/simplegit.rb",
      "应用选项只会尝试应用贮藏的工作——在堆栈上还有它。 可以运行 git stash drop 加上将要移除的贮藏的名字来移除它：",
      "",
      "$ git stash list",
      "stash@{0}: WIP on master: 049d078 added the index file",
      "stash@{1}: WIP on master: c264051 Revert \"added file_size\"",
      "stash@{2}: WIP on master: 21d80a5 added number to log",
      "$ git stash drop stash@{0}",
      "Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)",
      "也可以运行 git stash pop 来应用贮藏然后立即从栈上扔掉它。",
      "",
      "贮藏的创意性使用",
      "有几个贮藏的变种可能也很有用。 第一个非常流行的选项是 git stash 命令的 --keep-index 选项。 它告诉 Git 不仅要贮藏所有已暂存的内容，同时还要将它们保留在索引中。",
      "",
      "$ git status -s",
      "M  index.html",
      " M lib/simplegit.rb",
      "",
      "$ git stash --keep-index",
      "Saved working directory and index state WIP on master: 1b65b17 added the index file",
      "HEAD is now at 1b65b17 added the index file",
      "",
      "$ git status -s",
      "M  index.html",
      "另一个经常使用贮藏来做的事情是像贮藏跟踪文件一样贮藏未跟踪文件。 默认情况下，git stash 只会贮藏已修改和暂存的 已跟踪 文件。 如果指定 --include-untracked 或 -u 选项，Git 也会贮藏任何未跟踪文件。 然而，在贮藏中包含未跟踪的文件仍然不会包含明确 忽略 的文件。 要额外包含忽略的文件，请使用 --all 或 -a 选项。",
      "",
      "$ git status -s",
      "M  index.html",
      " M lib/simplegit.rb",
      "?? new-file.txt",
      "",
      "$ git stash -u",
      "Saved working directory and index state WIP on master: 1b65b17 added the index file",
      "HEAD is now at 1b65b17 added the index file",
      "",
      "$ git status -s",
      "$",
      "最终，如果指定了 --patch 标记，Git 不会贮藏所有修改过的任何东西， 但是会交互式地提示哪些改动想要贮藏、哪些改动需要保存在工作目录中。",
      "",
      "$ git stash --patch",
      "diff --git a/lib/simplegit.rb b/lib/simplegit.rb",
      "index 66d332e..8bb5674 100644",
      "--- a/lib/simplegit.rb",
      "+++ b/lib/simplegit.rb",
      "@@ -16,6 +16,10 @@ class SimpleGit",
      "         return `#{git_cmd} 2>&1`.chomp",
      "       end",
      "     end",
      "+",
      "+    def show(treeish = 'master')",
      "+      command(\"git show #{treeish}\")",
      "+    end",
      "",
      " end",
      " test",
      "Stash this hunk [y,n,q,a,d,/,e,?]? y",
      "",
      "Saved working directory and index state WIP on master: 1b65b17 added the index file",
      "从贮藏创建一个分支",
      "如果贮藏了一些工作，将它留在那儿了一会儿，然后继续在贮藏的分支上工作，在重新应用工作时可能会有问题。 如果应用尝试修改刚刚修改的文件，你会得到一个合并冲突并不得不解决它。 如果想要一个轻松的方式来再次测试贮藏的改动，可以运行 git stash branch <new branchname> 以你指定的分支名创建一个新分支，检出贮藏工作时所在的提交，重新在那应用工作，然后在应用成功后丢弃贮藏：",
      "",
      "$ git stash branch testchanges",
      "M index.html",
      "M  lib/simplegit.rb",
      "Switched to a new branch 'testchanges'",
      "On branch testchanges",
      "Changes to be committed:",
      "  (use \"git reset HEAD <file>...\" to unstage)",
      "",
      " modified:   index.html",
      "",
      "Changes not staged for commit:",
      "  (use \"git add <file>...\" to update what will be committed)",
      "  (use \"git checkout -- <file>...\" to discard changes in working directory)",
      "",
      " modified:   lib/simplegit.rb",
      "",
      "Dropped refs/stash@{0} (29d385a81d163dfd45a452a2ce816487a6b8b014)",
      "这是在新分支轻松恢复贮藏工作并继续工作的一个很不错的途径。",
      "",
      "清理工作目录",
      "对于工作目录中一些工作或文件，你想做的也许不是贮藏而是移除。 git clean 命令就是用来干这个的。",
      "",
      "清理工作目录有一些常见的原因，比如说为了移除由合并或外部工具生成的东西， 或是为了运行一个干净的构建而移除之前构建的残留。",
      "",
      "你需要谨慎地使用这个命令，因为它被设计为从工作目录中移除未被追踪的文件。 如果你改变主意了，你也不一定能找回来那些文件的内容。 一个更安全的选项是运行 git stash --all 来移除每一样东西并存放在栈中。",
      "",
      "你可以使用 git clean 命令去除冗余文件或者清理工作目录。 使用 git clean -f -d 命令来移除工作目录中所有未追踪的文件以及空的子目录。 -f 意味着“强制（force）”或“确定要移除”，使用它需要 Git 配置变量 clean.requireForce 没有显式设置为 false。",
      "",
      "如果只是想要看看它会做什么，可以使用 --dry-run 或 -n 选项来运行命令， 这意味着“做一次演习然后告诉你 将要 移除什么”。",
      "",
      "$ git clean -d -n",
      "Would remove test.o",
      "Would remove tmp/",
      "默认情况下，git clean 命令只会移除没有忽略的未跟踪文件。 任何与 .gitiignore 或其他忽略文件中的模式匹配的文件都不会被移除。 如果你也想要移除那些文件，例如为了做一次完全干净的构建而移除所有由构建生成的 .o 文件， 可以给 clean 命令增加一个 -x 选项。",
      "",
      "$ git status -s",
      " M lib/simplegit.rb",
      "?? build.TMP",
      "?? tmp/",
      "",
      "$ git clean -n -d",
      "Would remove build.TMP",
      "Would remove tmp/",
      "",
      "$ git clean -n -d -x",
      "Would remove build.TMP",
      "Would remove test.o",
      "Would remove tmp/",
      "如果不知道 git clean 命令将会做什么，在将 -n 改为 -f 来真正做之前总是先用 -n 来运行它做双重检查。 另一个小心处理过程的方式是使用 -i 或 “interactive” 标记来运行它。",
      "",
      "这将会以交互模式运行 clean 命令。",
      "",
      "$ git clean -x -i",
      "Would remove the following items:",
      "  build.TMP  test.o",
      "*** Commands ***",
      "    1: clean                2: filter by pattern    3: select by numbers    4: ask each             5: quit",
      "    6: help",
      "What now>",
      "这种方式下可以分别地检查每一个文件或者交互地指定删除的模式。"
    ]
  },
  "git-搜索": {
    "scope": "javascript,typescript",
    "prefix": "git-搜索",
    "body": [
      "无论仓库里的代码量有多少，你经常需要查找一个函数是在哪里调用或者定义的，或者显示一个方法的变更历史。 Git 提供了两个有用的工具来快速地从它的数据库中浏览代码和提交。 我们来简单的看一下。",
      "",
      "Git Grep",
      "Git 提供了一个 grep 命令，你可以很方便地从提交历史、工作目录、甚至索引中查找一个字符串或者正则表达式。 我们用 Git 本身源代码的查找作为例子。",
      "",
      "默认情况下 git grep 会查找你工作目录的文件。 第一种变体是，你可以传递 -n 或 --line-number 选项数来输出 Git 找到的匹配行的行号。",
      "",
      "$ git grep -n gmtime_r",
      "除了上面的基本搜索命令外，git grep 还支持大量其它有趣的选项。",
      "",
      "例如，若不想打印所有匹配的项，你可以使用 -c 或 --count 选项来让 git grep 输出概述的信息， 其中仅包括那些包含匹配字符串的文件，以及每个文件中包含了多少个匹配。",
      "",
      "$ git grep --count gmtime_r",
      "compat/gmtime.c:4",
      "compat/mingw.c:1",
      "compat/mingw.h:1",
      "date.c:3",
      "git-compat-util.h:2",
      "如果你还关心搜索字符串的 上下文，那么可以传入 -p 或 --show-function 选项来显示每一个匹配的字符串所在的方法或函数：",
      "",
      "$ git grep -p gmtime_r *.c",
      "如你所见，date.c 文件中的 match_multi_number 和 match_digit 两个函数都调用了 gmtime_r 例程 （第三个显示的匹配只是注释中的字符串）。",
      "",
      "你还可以使用 --and 标志来查看复杂的字符串组合，它确保了多个匹配出现在同一文本行中。 比如，我们要查看在旧版本 1.8.0 的 Git 代码库中定义了常量名包含 “LINK” 或者 “BUF_MAX” 这两个字符串的行 （这里也用到了 --break 和 --heading 选项来使输出更加容易阅读）。",
      "相比于一些常用的搜索命令比如 grep 和 ack，git grep 命令有一些的优点。 第一就是速度非常快，第二是你不仅仅可以可以搜索工作目录，还可以搜索任意的 Git 树。 在上一个例子中，我们在一个旧版本的 Git 源代码中查找，而不是当前检出的版本。",
      "",
      "Git 日志搜索",
      "或许你不想知道某一项在 哪里 ，而是想知道是什么 时候 存在或者引入的。 git log 命令有许多强大的工具可以通过提交信息甚至是 diff 的内容来找到某个特定的提交。",
      "",
      "例如，如果我们想找到 ZLIB_BUF_MAX 常量是什么时候引入的，我们可以使用 -S 选项 （在 Git 中俗称“鹤嘴锄（pickaxe）”选项）来显示新增和删除该字符串的提交。",
      "",
      "$ git log -S ZLIB_BUF_MAX --oneline",
      "e01503b zlib: allow feeding more than 4GB in one go",
      "ef49a7a zlib: zlib can only process 4GB at a time",
      "如果我们查看这些提交的 diff，我们可以看到在 ef49a7a 这个提交引入了常量，并且在 e01503b 这个提交中被修改了。",
      "",
      "如果你希望得到更精确的结果，你可以使用 -G 选项来使用正则表达式搜索。",
      "",
      "行日志搜索",
      "行日志搜索是另一个相当高级并且有用的日志搜索功能。 在 git log 后加上 -L 选项即可调用，它可以展示代码中一行或者一个函数的历史。",
      "",
      "例如，假设我们想查看 zlib.c 文件中`git_deflate_bound` 函数的每一次变更， 我们可以执行 git log -L :git_deflate_bound:zlib.c。 Git 会尝试找出这个函数的范围，然后查找历史记录，并且显示从函数创建之后一系列变更对应的补丁。",
      "",
      "$ git log -L :git_deflate_bound:zlib.c"
    ]
  },
  "git-git commit --amend --no-edit": {
    "scope": "javascript,typescript",
    "prefix": "git-git commit --amend --no-edit",
    "body": ["git commit --amend --no-edit"]
  },
  "git-git checkout -f bname": {
    "scope": "javascript,typescript",
    "prefix": "git-git checkout -f bname",
    "body": ["git checkout -f bname"]
  },
  "git-": {
    "scope": "javascript,typescript",
    "prefix": "git-",
    "body": []
  },
  "git-": {
    "scope": "javascript,typescript",
    "prefix": "git-",
    "body": []
  },
  "git-": {
    "scope": "javascript,typescript",
    "prefix": "git-",
    "body": []
  },
  "git-a": {
    "scope": "javascript,typescript",
    "prefix": "git-a",
    "body": [
      "",
      "                    init 初始化仓库",
      "                    ",
      "                    $ git init",
      "                    clone 克隆仓库",
      "                    ",
      "                    $ git clone https://github.com/repname",
      "                    $ git clone https://github.com/repname myrep #myrep作为本地仓库名",
      "                    config 配置",
      "                    ",
      "                    $ git config --list                #查看配置",
      "                    $ git config --system user.name    #系统级配置",
      "                    $ git config --global user.name    #全局配置，系统用户级",
      "                    $ git config user.name             #仓库级配置",
      "                    help 帮助",
      "                    ",
      "                    $ git help <verb>",
      "                    $ git <verb> --help",
      "                    $ man git-<verb>",
      "                    remot 远程仓库",
      "                    ",
      "                    $ git remote -v      　　　　　　　　　　　　 #查看远程仓库",
      "                    $ git remote show origin  　　　　　　　　　 #查看远程仓库",
      "                    $ git remote add pb https://github.com/pb #添加远程仓库",
      "                    $ git remote rename pb paul    　　　　　　 #重命名远程仓库",
      "                    $ git remote rm paul  　　　　　　　　　　　　#移除远程仓库",
      "                     2.基础命令",
      "                    status 查看文件状态",
      "                    ",
      "                    $ git status",
      "                    $ git status -s 　　　　#状态简览",
      "                    add 暂存已修改文件",
      "                    ",
      "                    $ git add filename",
      "                    $ git add -A 　　　　　  #暂存所有已修改文件",
      "                    commit 提交更新",
      "                    ",
      "                    $ git commit -m \"commit message\"",
      "                    $ git commit -a -m \"commit message\"    #跳过暂存区，直接提交",
      "                    push 推送到远程仓库",
      "                    ",
      "                    $ git push",
      "                    $ git push origin master",
      "                    fetch 从远程仓库拉取数据",
      "                    ",
      "                    $ git fetch [remote-name]",
      "                    merge 合并分支",
      "                    ",
      "                    $ git merge",
      "                    pull ( fetch + merge )",
      "                    ",
      "                    #用 fetch 和 merge 好了",
      "                    3.常用命令",
      "                    diff 查看修改",
      "                    ",
      "                    $ git diff              #比较 暂存区－工作区",
      "                    $ git diff --staged     #比较 仓库－暂存区",
      "                    log 查看提交历史",
      "                    ",
      "                    $ git log",
      "                    $ git log --stat    　　 #展示提交的简略统计信息",
      "                    撤销操作",
      "                    ",
      "                    $ git commit --amend         #重新提交",
      "                    $ git reset HEAD filename    #取消暂存的文件",
      "                    checkout 撤销对文件的修改",
      "                    ",
      "                    $ git checkout filename",
      "                    # 会覆盖工作区文件",
      "                    # 如果暂存区有改动的文件，则从暂存区到工作区",
      "                    # 如果暂存区无改动的文件，则从仓库到工作区",
      "                    tag 打标签",
      "                    ",
      "                    复制代码",
      "                    $ git tag     #查看标签",
      "                    $ git tag -a v1.4 -m \"my version 1.4\"　　 #创建附注标签",
      "                    $ git tag v1.4    　　　　　　　　　　　　　　#创建轻量标签",
      "                    $ git tag -a v1.2 9fceb02   　　　　　　　　#对某次提交后期打标签",
      "                    $ git push origin v1.5   　　　　　　　　　　#上传某个标签，GIT 默认不会 push 标签到远程仓库",
      "                    $ git push origin --tags 　　　　　　　　　　#上传所有不在远程仓库的标签",
      "                    $ git checkout -b version2 v2.0.0  　　　　#检出标签",
      "                    复制代码",
      "                    rm 移除文件",
      "                    ",
      "                    $ git rm filename     　　　 #个人感觉效果同 rm",
      "                    $ git rm --cached filename  #移除暂存区中的文件",
      "                    mv 移动文件",
      "                    ",
      "                    $ git mv file_from file_to    #个人感觉效果同 mv",
      "                     3.分支命令",
      "                    branch 创建分支",
      "                    ",
      "                    复制代码",
      "                    $ git branch　　　　　　　　　　#查看分支，前面带星号*的，是当前分支",
      "                    $ git branch testing　　　　  #创建 testing 分支",
      "                    $ git branch -d testing　    #删除 testing 分支",
      "                    $ git branch -v        　    #查看每个分支最后一次提交",
      "                    $ git branch --merged　　　　 #查看已合并到当前分支的分支",
      "                    $ git branch --no-merged　   #查看未合并到当前分支的分支",
      "                    复制代码",
      "                    checkout 切换分支",
      "                    ",
      "                    $ git checkout testing",
      "                    $ git checkout -b iss53　　  #创建分支，并切换到新创建的分支",
      "                    merge 合并分支",
      "                    ",
      "                    $ git merge hotfix           #把 hotfix 分支，合并到当前分支",
      "                    $ git mergetool　　　         #图形化解决冲突的工具",
      "                    4.底层命令",
      "                    cat-file 读取 GIT 仓库对象",
      "                    ",
      "                    $ git cat-file -p f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee    #查看对象内容",
      "                    $ git cat-file -p master^{tree}     #master 分支上最新的提交所指向的 tree 对象",
      "                    $ git cat-file -t f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee    #查看对象类型",
      "                    $ git cat-file -s f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee    #查看对象大小",
      "                    hash-object 操作 GIT 仓库对象",
      "                    ",
      "                    $ git hash-object -w filename.txt   #把 filename.txt 文件内容写入 GIT 仓库",
      "                    update-index 操作暂存区",
      "                    ",
      "                    $ git update-index --add --cacheinfo 100644 f8a67de1d4bf0d6dbaaaf8990ffe8394e5fa88ee #创建暂存区，并把 blob 对象添加到暂存区",
      "                    $ git update-index test.txt  　　　　   #更新暂存区",
      "                    $ git update-index --add new.txt　     #向暂存区添加文件",
      "                    write-tree 创建树对象",
      "                    ",
      "                    $ git write-tree         #根据当前暂存区内容，创建树对象",
      "                    read-tree 把树对象读入到暂存区",
      "                    ",
      "                    $ git read-tree 754a1e2d567bbbcee762a2d7768407f4d3290fc8",
      "                    $ git read-tree --prefix=bak 754a1e2d567bbbcee762a2d7768407f4d3290fc8 #把树对象当作子树读入暂存区",
      "                    commit-tree 创建提交对象",
      "                    ",
      "                    $ echo 'first commit' | git commit-tree 754a1e             #根据树对象，创建提交对象",
      "                    $ echo 'second commit' | git commit-tree 754a1e -p 32b8d2  #创建提交对象时，指定父提交对象",
      "                    update-ref 创建引用（分支、标签）",
      "                    ",
      "                    $ git update-ref refs/heads/master 32b8d2",
      "                    #或者如下直接编辑引用文件，不提倡这么做",
      "                    $ echo \"32b8d2094acef696efa3ca1b0a29639d97be1684\" > .git/refs/heads/master",
      "                    sysmbolic-ref 符号引用（retrofit2.http.HEAD）",
      "                    ",
      "                    $ git symbolic-ref HEAD refs/heads/test",
      "                    #或者如下直接编辑引用文件，不提倡这么做",
      "                    $ echo \"refs/heads/test\" .git/HEAD",
      "                    远程引用",
      "                    ",
      "                    #远程引用是只读的，看看就好了",
      "                    gc 生成包文件",
      "                    ",
      "                    $ git gc",
      "                    #作用：完整保存最新版文件，历史版本文件保存差异",
      "                    ＃GIT 会根据情况自己执行，一般不需要手动之行"
    ]
  }
}
