{
  // Place your snippets for sql here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  "sql-命令": {
    "prefix": "sql-命令",
    "body": [
      "本章将向您讲解 SQLite 编程人员所使用的简单却有用的命令。这些命令被称为 SQLite 的点命令，这些命令的不同之处在于它们不以分号 ; 结束。",
      "",
      "让我们在命令提示符下键入一个简单的 sqlite3 命令，在 SQLite 命令提示符下，您可以使用各种 SQLite 命令。",
      "",
      "$ sqlite3",
      "SQLite version 3.3.6",
      "Enter \".help\" for instructions",
      "sqlite>",
      "如需获取可用的点命令的清单，可以在任何时候输入 \".help\"。例如：",
      "",
      "sqlite>.help",
      "上面的命令会显示各种重要的 SQLite 点命令的列表，如下所示"
    ]
  },
  "sql-所有语法": {
    "prefix": "sql-所有语法",
    "body": [
      "大小写敏感性",
      "有个重要的点值得注意，SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如 GLOB 和 glob 在 SQLite 的语句中有不同的含义。",
      "",
      "注释",
      "SQLite 注释是附加的注释，可以在 SQLite 代码中添加注释以增加其可读性，他们可以出现在任何空白处，包括在表达式内和其他 SQL 语句的中间，但它们不能嵌套。",
      "",
      "SQL 注释以两个连续的 \"-\" 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。",
      "",
      "您也可以使用 C 风格的注释，以 \"/*\" 开始，并扩展至下一个 \"*/\" 字符对或直到输入结束，以先到者为准。SQLite的注释可以跨越多行。",
      "",
      "sqlite>.help -- 这是一个简单的注释",
      "SQLite 语句",
      "所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号（;）结束。",
      "",
      "SQLite ANALYZE 语句：",
      "ANALYZE;",
      "or",
      "ANALYZE database_name;",
      "or",
      "ANALYZE database_name.table_name;",
      "SQLite AND/OR 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  CONDITION-1 {AND|OR} CONDITION-2;",
      "SQLite ALTER TABLE 语句：",
      "ALTER TABLE table_name ADD COLUMN column_def...;",
      "SQLite ALTER TABLE 语句（Rename）：",
      "ALTER TABLE table_name RENAME TO new_table_name;",
      "SQLite ATTACH DATABASE 语句：",
      "ATTACH DATABASE 'DatabaseName' As 'Alias-Name';",
      "SQLite BEGIN TRANSACTION 语句：",
      "BEGIN;",
      "or",
      "BEGIN EXCLUSIVE TRANSACTION;",
      "SQLite BETWEEN 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  column_name BETWEEN val-1 AND val-2;",
      "SQLite COMMIT 语句：",
      "COMMIT;",
      "SQLite CREATE INDEX 语句：",
      "CREATE INDEX index_name",
      "ON table_name ( column_name COLLATE NOCASE );",
      "SQLite CREATE UNIQUE INDEX 语句：",
      "CREATE UNIQUE INDEX index_name",
      "ON table_name ( column1, column2,...columnN);",
      "SQLite CREATE TABLE 语句：",
      "CREATE TABLE table_name(",
      "   column1 datatype,",
      "   column2 datatype,",
      "   column3 datatype,",
      "   .....",
      "   columnN datatype,",
      "   PRIMARY KEY( one or more columns )",
      ");",
      "SQLite CREATE TRIGGER 语句：",
      "CREATE TRIGGER database_name.trigger_name ",
      "BEFORE INSERT ON table_name FOR EACH ROW",
      "BEGIN ",
      "   stmt1; ",
      "   stmt2;",
      "   ....",
      "END;",
      "SQLite CREATE VIEW 语句：",
      "CREATE VIEW database_name.view_name  AS",
      "SELECT statement....;",
      "SQLite CREATE VIRTUAL TABLE 语句：",
      "CREATE VIRTUAL TABLE database_name.table_name USING weblog( access.log );",
      "or",
      "CREATE VIRTUAL TABLE database_name.table_name USING fts3( );",
      "SQLite COMMIT TRANSACTION 语句：",
      "COMMIT;",
      "SQLite COUNT 子句：",
      "SELECT COUNT(column_name)",
      "FROM   table_name",
      "WHERE  CONDITION;",
      "SQLite DELETE 语句：",
      "DELETE FROM table_name",
      "WHERE  {CONDITION};",
      "SQLite DETACH DATABASE 语句：",
      "DETACH DATABASE 'Alias-Name';",
      "SQLite DISTINCT 子句：",
      "SELECT DISTINCT column1, column2....columnN",
      "FROM   table_name;",
      "SQLite DROP INDEX 语句：",
      "DROP INDEX database_name.index_name;",
      "SQLite DROP TABLE 语句：",
      "DROP TABLE database_name.table_name;",
      "SQLite DROP VIEW 语句：",
      "DROP VIEW view_name;",
      "SQLite DROP TRIGGER 语句：",
      "DROP TRIGGER trigger_name",
      "SQLite EXISTS 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  column_name EXISTS (SELECT * FROM   table_name );",
      "SQLite EXPLAIN 语句：",
      "EXPLAIN INSERT statement...;",
      "or ",
      "EXPLAIN QUERY PLAN SELECT statement...;",
      "SQLite GLOB 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  column_name GLOB { PATTERN };",
      "SQLite GROUP BY 子句：",
      "SELECT SUM(column_name)",
      "FROM   table_name",
      "WHERE  CONDITION",
      "GROUP BY column_name;",
      "SQLite HAVING 子句：",
      "SELECT SUM(column_name)",
      "FROM   table_name",
      "WHERE  CONDITION",
      "GROUP BY column_name",
      "HAVING (arithematic function condition);",
      "SQLite INSERT INTO 语句：",
      "INSERT INTO table_name( column1, column2....columnN)",
      "VALUES ( value1, value2....valueN);",
      "SQLite IN 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  column_name IN (val-1, val-2,...val-N);",
      "SQLite Like 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  column_name LIKE { PATTERN };",
      "SQLite NOT IN 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  column_name NOT IN (val-1, val-2,...val-N);",
      "SQLite ORDER BY 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  CONDITION",
      "ORDER BY column_name {ASC|DESC};",
      "SQLite PRAGMA 语句：",
      "PRAGMA pragma_name;",
      "",
      "For example:",
      "",
      "PRAGMA page_size;",
      "PRAGMA cache_size = 1024;",
      "PRAGMA table_info(table_name);",
      "SQLite RELEASE SAVEPOINT 语句：",
      "RELEASE savepoint_name;",
      "SQLite REINDEX 语句：",
      "REINDEX collation_name;",
      "REINDEX database_name.index_name;",
      "REINDEX database_name.table_name;",
      "SQLite ROLLBACK 语句：",
      "ROLLBACK;",
      "or",
      "ROLLBACK TO SAVEPOINT savepoint_name;",
      "SQLite SAVEPOINT 语句：",
      "SAVEPOINT savepoint_name;",
      "SQLite SELECT 语句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name;",
      "SQLite UPDATE 语句：",
      "UPDATE table_name",
      "SET column1 = value1, column2 = value2....columnN=valueN",
      "[ WHERE  CONDITION ];",
      "SQLite VACUUM 语句：",
      "VACUUM;",
      "SQLite WHERE 子句：",
      "SELECT column1, column2....columnN",
      "FROM   table_name",
      "WHERE  CONDITION;"
    ]
  },
  "sql-lei": {
    "prefix": "sql-",
    "body": [
      "每个存储在 SQLite 数据库中的值都具有以下存储类之一：",
      "",
      "存储类描述",
      "NULL值是一个 NULL 值。",
      "INTEGER值是一个带符号的整数，根据值的大小存储在 1、2、3、4、6 或 8 字节中。",
      "REAL值是一个浮点值，存储为 8 字节的 IEEE 浮点数字。",
      "TEXT值是一个文本字符串，使用数据库编码（UTF-8、UTF-16BE 或 UTF-16LE）存储。",
      "BLOB值是一个 blob 数据，完全根据它的输入存储。",
      "SQLite 的存储类稍微比数据类型更普遍。INTEGER 存储类，例如，包含 6 种不同的不同长度的整数数据类型。"
    ]
  },
  "sql-数据类型": {
    "prefix": "sql-数据类型",
    "body": []
  },
  "sql-创建数据库": {
    "prefix": "sql-创建数据库",
    "body": [
      "SQLite 的 sqlite3 命令被用来创建新的 SQLite 数据库。您不需要任何特殊的权限即可创建一个数据。",
      "",
      "语法",
      "sqlite3 命令的基本语法如下：",
      "",
      "$sqlite3 DatabaseName.db",
      "通常情况下，数据库名称在 RDBMS 内应该是唯一的。",
      "",
      "实例",
      "如果您想创建一个新的数据库 <testDB.db>，SQLITE3 语句如下所示：",
      "",
      "$sqlite3 testDB.db",
      "SQLite version 3.7.15.2 2013-01-09 11:53:05",
      "Enter \".help\" for instructions",
      "Enter SQL statements terminated with a \";\"",
      "sqlite>",
      "上面的命令将在当前目录下创建一个文件 testDB.db。该文件将被 SQLite 引擎用作数据库。如果您已经注意到 sqlite3 命令在成功创建数据库文件之后，将提供一个 sqlite> 提示符。",
      "",
      "一旦数据库被创建，您就可以使用 SQLite 的 .databases 命令来检查它是否在数据库列表中，如下所示：",
      "",
      "sqlite>.databases",
      "seq  name             file",
      "---  ---------------  ----------------------",
      "0    main             /home/sqlite/testDB.db",
      "您可以使用 SQLite .quit 命令退出 sqlite 提示符，如下所示：",
      "",
      "sqlite>.quit",
      "$"
    ]
  },
  "sql-dump 命令": {
    "prefix": "sql-dump 命令",
    "body": [
      ".dump 命令",
      "您可以在命令提示符中使用 SQLite .dump 点命令来导出完整的数据库在一个文本文件中，如下所示：",
      "",
      "$sqlite3 testDB.db .dump > testDB.sql",
      "上面的命令将转换整个 testDB.db 数据库的内容到 SQLite 的语句中，并将其转储到 ASCII 文本文件 testDB.sql 中。您可以通过简单的方式从生成的 testDB.sql 恢复，如下所示：",
      "",
      "$sqlite3 testDB.db < testDB.sql",
      "此时的数据库是空的，一旦数据库中有表和数据，您可以尝试上述两个程序。现在，让我们继续学习下一章。"
    ]
  },
  "sql-ATTACH DATABASE": {
    "prefix": "sql-ATTACH DATABASE",
    "body": [
      "假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DATABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。",
      "",
      "语法",
      "SQLite 的 ATTACH DATABASE 语句的基本语法如下：",
      "",
      "ATTACH DATABASE file_name AS database_name;",
      "如果数据库尚未被创建，上面的命令将创建一个数据库，如果数据库已存在，则把数据库文件名称与逻辑数据库 'Alias-Name' 绑定在一起。",
      "",
      "实例",
      "如果想附加一个现有的数据库 testDB.db，则 ATTACH DATABASE 语句将如下所示：",
      "",
      "sqlite> ATTACH DATABASE 'testDB.db' as 'TEST';",
      "使用 SQLite .database 命令来显示附加的数据库。",
      "",
      "sqlite> .database",
      "seq  name             file",
      "---  ---------------  ----------------------",
      "0    main             /home/sqlite/testDB.db",
      "2    test             /home/sqlite/testDB.db",
      "数据库名称 main 和 temp 被保留用于主数据库和存储临时表及其他临时数据对象的数据库。这两个数据库名称可用于每个数据库连接，且不应该被用于附加，否则将得到一个警告消息，如下所示：",
      "",
      "sqlite>  ATTACH DATABASE 'testDB.db' as 'TEMP';",
      "Error: database TEMP is already in use",
      "sqlite>  ATTACH DATABASE 'testDB.db' as 'main';",
      "Error: database main is already in use；"
    ]
  },
  "sql-DETACH DTABASE": {
    "prefix": "sql-DETACH DTABASE",
    "body": [
      "SQLite的 DETACH DTABASE 语句是用来把命名数据库从一个数据库连接分离和游离出来，连接是之前使用 ATTACH 语句附加的。如果同一个数据库文件已经被附加上多个别名，DETACH 命令将只断开给定名称的连接，而其余的仍然有效。您无法分离 main 或 temp 数据库。",
      "",
      "如果数据库是在内存中或者是临时数据库，则该数据库将被摧毁，且内容将会丢失。",
      "语法",
      "SQLite 的 DETACH DATABASE 'Alias-Name' 语句的基本语法如下：",
      "",
      "DETACH DATABASE 'Alias-Name';",
      "在这里，'Alias-Name' 与您之前使用 ATTACH 语句附加数据库时所用到的别名相同。",
      "",
      "实例",
      "假设在前面的章节中您已经创建了一个数据库，并给它附加了 'test' 和 'currentDB'，使用 .database 命令，我们可以看到：",
      "",
      "sqlite>.databases",
      "seq  name             file",
      "---  ---------------  ----------------------",
      "0    main             /home/sqlite/testDB.db",
      "2    test             /home/sqlite/testDB.db",
      "3    currentDB        /home/sqlite/testDB.db",
      "现在，让我们尝试把 'currentDB' 从 testDB.db 中分离出来，如下所示：",
      "",
      "sqlite> DETACH DATABASE 'currentDB';",
      "现在，如果检查当前附加的数据库，您会发现，testDB.db 仍与 'test' 和 'main' 保持连接。",
      "",
      "sqlite>.databases",
      "seq  name             file",
      "---  ---------------  ----------------------",
      "0    main             /home/sqlite/testDB.db",
      "2    test             /home/sqlite/testDB.db"
    ]
  },
  "sql-CREATE TABLE": {
    "prefix": "sql-CREATE TABLE",
    "body": [
      "SQLite 的 CREATE TABLE 语句用于在任何给定的数据库创建一个新表。创建基本表，涉及到命名表、定义列及每一列的数据类型。",
      "",
      "语法",
      "CREATE TABLE 语句的基本语法如下：",
      "",
      "CREATE TABLE database_name.table_name(",
      "   column1 datatype  PRIMARY KEY(one or more columns),",
      "   column2 datatype,",
      "   column3 datatype,",
      "   .....",
      "   columnN datatype,",
      ");",
      "CREATE TABLE 是告诉数据库系统创建一个新表的关键字。CREATE TABLE 语句后跟着表的唯一的名称或标识。您也可以选择指定带有 table_name 的 database_name。",
      "",
      "实例",
      "下面是一个实例，它创建了一个 COMPANY 表，ID 作为主键，NOT NULL 的约束表示在表中创建纪录时这些字段不能为 NULL：",
      "",
      "sqlite> CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL",
      ");",
      "让我们再创建一个表，我们将在随后章节的练习中使用：",
      "",
      "sqlite> CREATE TABLE DEPARTMENT(",
      "   ID INT PRIMARY KEY      NOT NULL,",
      "   DEPT           CHAR(50) NOT NULL,",
      "   EMP_ID         INT      NOT NULL",
      ");",
      "您可以使用 SQLIte 命令中的 .tables 命令来验证表是否已成功创建，该命令用于列出附加数据库中的所有表。",
      "",
      "sqlite>.tables",
      "COMPANY     DEPARTMENT",
      "在这里，可以看到我们刚创建的两张表 COMPANY、 DEPARTMENT。",
      "",
      "您可以使用 SQLite .schema 命令得到表的完整信息，如下所示：",
      "",
      "sqlite>.schema COMPANY",
      "CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL",
      ");"
    ]
  },
  "sql- 删除表": {
    "prefix": "sql-删除表",
    "body": [
      "SQLite 的 DROP TABLE 语句用来删除表定义及其所有相关数据、索引、触发器、约束和该表的权限规范。",
      "",
      "使用此命令时要特别注意，因为一旦一个表被删除，表中所有信息也将永远丢失。",
      "语法",
      "DROP TABLE 语句的基本语法如下。您可以选择指定带有表名的数据库名称，如下所示：",
      "",
      "DROP TABLE database_name.table_name;",
      "实例",
      "让我们先确认 COMPANY 表已经存在，然后我们将其从数据库中删除。",
      "",
      "sqlite>.tables",
      "COMPANY       test.COMPANY",
      "这意味着 COMPANY 表已存在数据库中，接下来让我们把它从数据库中删除，如下：",
      "",
      "sqlite>DROP TABLE COMPANY;",
      "sqlite>",
      "现在，如果尝试 .TABLES 命令，那么将无法找到 COMPANY 表了：",
      "",
      "sqlite>.tables",
      "sqlite>",
      "显示结果为空，意味着已经成功从数据库删除表。"
    ]
  },
  "sql-INSERT INTO": {
    "prefix": "sql-INSERT INTO",
    "body": [
      "SQLite 的 INSERT INTO 语句用于向数据库的某个表中添加新的数据行。",
      "",
      "语法",
      "INSERT INTO 语句有两种基本语法，如下所示：",
      "",
      "INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)]  ",
      "VALUES (value1, value2, value3,...valueN);",
      "在这里，column1, column2,...columnN 是要插入数据的表中的列的名称。",
      "",
      "如果要为表中的所有列添加值，您也可以不需要在 SQLite 查询中指定列名称。但要确保值的顺序与列在表中的顺序一致。SQLite 的 INSERT INTO 语法如下：",
      "",
      "INSERT INTO TABLE_NAME VALUES (value1,value2,value3,...valueN);",
      "实例",
      "假设您已经在 testDB.db 中创建了 COMPANY表，如下所示：",
      "",
      "sqlite> CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL",
      ");",
      "现在，下面的语句将在 COMPANY 表中创建六个记录：",
      "",
      "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)",
      "VALUES (1, 'Paul', 32, 'California', 20000.00 );",
      "",
      "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)",
      "VALUES (2, 'Allen', 25, 'Texas', 15000.00 );",
      "",
      "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)",
      "VALUES (3, 'Teddy', 23, 'Norway', 20000.00 );",
      "",
      "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)",
      "VALUES (4, 'Mark', 25, 'Rich-Mond ', 65000.00 );",
      "",
      "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)",
      "VALUES (5, 'David', 27, 'Texas', 85000.00 );",
      "",
      "INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY)",
      "VALUES (6, 'Kim', 22, 'South-Hall', 45000.00 );",
      "您也可以使用第二种语法在 COMPANY 表中创建一个记录，如下所示：",
      "",
      "INSERT INTO COMPANY VALUES (7, 'James', 24, 'Houston', 10000.00 );",
      "上面的所有语句将在 COMPANY 表中创建下列记录。下一章会教您如何从一个表中显示所有这些记录。",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0"
    ]
  },
  "sql-使用一个表来填充另一个表": {
    "prefix": "sql-使用一个表来填充另一个表",
    "body": [
      "您可以通过在一个有一组字段的表上使用 select 语句，填充数据到另一个表中。下面是语法：",
      "",
      "INSERT INTO first_table_name [(column1, column2, ... columnN)] ",
      "   SELECT column1, column2, ...columnN ",
      "   FROM second_table_name",
      "   [WHERE condition];",
      "您暂时可以先跳过上面的语句，可以先学习后面章节中介绍的 SELECT 和 WHERE 子句。"
    ]
  },
  "sql-Select 语句": {
    "prefix": "sql-Select 语句",
    "body": [
      "SQLite 的 SELECT 语句用于从 SQLite 数据库表中获取数据，以结果表的形式返回数据。这些结果表也被称为结果集。",
      "",
      "语法",
      "SQLite 的 SELECT 语句的基本语法如下：",
      "",
      "SELECT column1, column2, columnN FROM table_name;",
      "在这里，column1, column2...是表的字段，他们的值即是您要获取的。如果您想获取所有可用的字段，那么可以使用下面的语法：",
      "",
      "SELECT * FROM table_name;",
      "实例",
      "假设 COMPANY 表有以下记录：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "下面是一个实例，使用 SELECT 语句获取并显示所有这些记录。在这里，前三个命令被用来设置正确格式化的输出。",
      "",
      "sqlite>.header on",
      "sqlite>.mode column",
      "sqlite> SELECT * FROM COMPANY;",
      "最后，将得到以下的结果：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "如果只想获取 COMPANY 表中指定的字段，则使用下面的查询：",
      "",
      "sqlite> SELECT ID, NAME, SALARY FROM COMPANY;",
      "上面的查询会产生以下结果：",
      "",
      "ID          NAME        SALARY",
      "----------  ----------  ----------",
      "1           Paul        20000.0",
      "2           Allen       15000.0",
      "3           Teddy       20000.0",
      "4           Mark        65000.0",
      "5           David       85000.0",
      "6           Kim         45000.0",
      "7           James       10000.0"
    ]
  },
  "sql-设置输出列的宽度": {
    "prefix": "sql-设置输出列的宽度",
    "body": [
      "有时，由于要显示的列的默认宽度导致 .mode column，这种情况下，输出被截断。此时，您可以使用 .width num, num.... 命令设置显示列的宽度，如下所示：",
      "",
      "sqlite>.width 10, 20, 10",
      "sqlite>SELECT * FROM COMPANY;",
      "上面的 .width 命令设置第一列的宽度为 10，第二列的宽度为 20，第三列的宽度为 10。因此上述 SELECT 语句将得到以下结果：",
      "",
      "ID          NAME                  AGE         ADDRESS     SALARY",
      "----------  --------------------  ----------  ----------  ----------",
      "1           Paul                  32          California  20000.0",
      "2           Allen                 25          Texas       15000.0",
      "3           Teddy                 23          Norway      20000.0",
      "4           Mark                  25          Rich-Mond   65000.0",
      "5           David                 27          Texas       85000.0",
      "6           Kim                   22          South-Hall  45000.0",
      "7           James                 24          Houston     10000.0"
    ]
  },
  "sql-SQLite 算术运算符": {
    "prefix": "sql-SQLite 算术运算符",
    "body": [
      "假设变量 a=10，变量 b=20，则：",
      "",
      "运算符	描述	实例",
      "+	加法 - 把运算符两边的值相加	a + b 将得到 30",
      "-	减法 - 左操作数减去右操作数	a - b 将得到 -10",
      "*	乘法 - 把运算符两边的值相乘	a * b 将得到 200",
      "/	除法 - 左操作数除以右操作数	b / a 将得到 2",
      "%	取模 - 左操作数除以右操作数后得到的余数	b % a will give 0",
      "实例",
      "下面是 SQLite 算术运算符的简单实例：",
      "",
      "sqlite> .mode line",
      "sqlite> select 10 + 20;",
      "10 + 20 = 30",
      "",
      "",
      "sqlite> select 10 - 20;",
      "10 - 20 = -10",
      "",
      "",
      "sqlite> select 10 * 20;",
      "10 * 20 = 200",
      "",
      "",
      "sqlite> select 10 / 5;",
      "10 / 5 = 2",
      "",
      "",
      "sqlite> select 12 %  5;",
      "12 %  5 = 2"
    ]
  },
  "sql-SQLite 比较运算符": {
    "prefix": "sql-SQLite 比较运算符",
    "body": [
      "假设变量 a=10，变量 b=20，则：",
      "",
      "运算符描述实例",
      "==检查两个操作数的值是否相等，如果相等则条件为真。(a == b) 不为真。",
      "=检查两个操作数的值是否相等，如果相等则条件为真。(a = b) 不为真。",
      "!=检查两个操作数的值是否相等，如果不相等则条件为真。(a != b) 为真。",
      "<>检查两个操作数的值是否相等，如果不相等则条件为真。(a <> b) 为真。",
      ">检查左操作数的值是否大于右操作数的值，如果是则条件为真。(a > b) 不为真。",
      "<检查左操作数的值是否小于右操作数的值，如果是则条件为真。(a < b) 为真。",
      ">=检查左操作数的值是否大于等于右操作数的值，如果是则条件为真。(a >= b) 不为真。",
      "<=检查左操作数的值是否小于等于右操作数的值，如果是则条件为真。(a <= b) 为真。",
      "!<检查左操作数的值是否不小于右操作数的值，如果是则条件为真。(a !< b) 为假。",
      "!>检查左操作数的值是否不大于右操作数的值，如果是则条件为真(a !> b) 为真。",
      "实例",
      "假设 COMPANY 表有以下记录：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "下面的实例演示了各种 SQLite 比较运算符的用法。",
      "",
      "在这里，我们使用 WHERE 子句，这将会在后边单独的一个章节中讲解，但现在您需要明白，WHERE 子句是用来设置 SELECT 语句的条件语句。",
      "下面的 SELECT 语句列出了 SALARY 大于 50,000.00 的所有记录：",
      "",
      "sqlite> SELECT * FROM COMPANY WHERE SALARY > 50000;",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "下面的 SELECT 语句列出了 SALARY 等于 20,000.00 的所有记录：",
      "",
      "sqlite>  SELECT * FROM COMPANY WHERE SALARY = 20000;",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "3           Teddy       23          Norway      20000.0",
      "下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录：",
      "",
      "sqlite>  SELECT * FROM COMPANY WHERE SALARY != 20000;",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "2           Allen       25          Texas       15000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "下面的 SELECT 语句列出了 SALARY 不等于 20,000.00 的所有记录：",
      "",
      "sqlite> SELECT * FROM COMPANY WHERE SALARY <> 20000;",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "2           Allen       25          Texas       15000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "下面的 SELECT 语句列出了 SALARY 大于等于 65,000.00 的所有记录：",
      "",
      "sqlite> SELECT * FROM COMPANY WHERE SALARY >= 65000;",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0"
    ]
  },
  "sql-SQLite 逻辑运算符": {
    "prefix": "sql-SQLite 逻辑运算符",
    "body": [
      "下面是 SQLite 中所有的逻辑运算符列表。",
      "",
      "运算符描述",
      "AND AND 运算符允许在一个 SQL 语句的 WHERE 子句中的多个条件的存在。",
      "BETWEEN BETWEEN 运算符用于在给定最小值和最大值范围内的一系列值中搜索值。",
      "EXISTS EXISTS 运算符用于在满足一定条件的指定表中搜索行的存在。",
      "IN IN 运算符用于把某个值与一系列指定列表的值进行比较。",
      "NOT IN    IN 运算符的对立面，用于把某个值与不在一系列指定列表的值进行比较。",
      "LIKE LIKE 运算符用于把某个值与使用通配符运算符的相似值进行比较。",
      "GLOB GLOB 运算符用于把某个值与使用通配符运算符的相似值进行比较。GLOB 与 LIKE 不同之处在于，它是大小写敏感的。",
      "NOT NOT 运算符是所用的逻辑运算符的对立面。比如 NOT EXISTS、NOT BETWEEN、NOT IN，等等。它是否定运算符。",
      "OR OR 运算符用于结合一个 SQL 语句的 WHERE 子句中的多个条件。",
      "IS NULL    NULL 运算符用于把某个值与 NULL 值进行比较。",
      "IS     IS 运算符与 = 相似。",
      "IS NOT     IS NOT 运算符与 != 相似。",
      "||   连接两个不同的字符串，得到一个新的字符串。",
      "UNIQUE    UNIQUE 运算符搜索指定表中的每一行，确保唯一性（无重复）。"
    ]
  },
  "sql-布尔表达式": {
    "prefix": "sql-布尔表达式",
    "body": [
      "sqlite> SELECT * FROM COMPANY WHERE SALARY = 10000;",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "4           James        24          Houston   10000.0"
    ]
  },
  "sql- 数值表达式": {
    "prefix": "sql- 数值表达式",
    "body": [
      "在这里，numerical_expression 用于数学表达式或任何公式。下面的实例演示了 SQLite 数值表达式的用法：",
      "",
      "sqlite> SELECT (15 + 6) AS ADDITION",
      "ADDITION = 21",
      "有几个内置的函数，比如 avg()、sum()、count()，等等，执行被称为对一个表或一个特定的表列的汇总数据计算。",
      "",
      "sqlite> SELECT COUNT(*) AS \"RECORDS\" FROM COMPANY; ",
      "RECORDS = 7"
    ]
  },
  "sql-日期表达式": {
    "prefix": "sql-日期表达式",
    "body": [
      "sqlite>  SELECT CURRENT_TIMESTAMP;",
      "CURRENT_TIMESTAMP = 2013-03-17 10:43:35"
    ]
  },
  "sql-Where": {
    "prefix": "sql-Where",
    "body": [
      "sqlite> SELECT AGE FROM COMPANY ",
      "        WHERE EXISTS (SELECT AGE FROM COMPANY WHERE SALARY > 65000);",
      "sqlite> SELECT * FROM COMPANY WHERE AGE BETWEEN 25 AND 27;",
      "sqlite> SELECT * FROM COMPANY WHERE AGE NOT IN ( 25, 27 );",
      "sqlite> SELECT * FROM COMPANY WHERE AGE IN ( 25, 27 );",
      "sqlite> SELECT * FROM COMPANY WHERE NAME GLOB 'Ki*';",
      "sqlite> SELECT * FROM COMPANY WHERE NAME LIKE 'Ki%';",
      "sqlite>  SELECT * FROM COMPANY WHERE AGE IS NOT NULL;",
      "sqlite> SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000;",
      "sqlite> SELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;"
    ]
  },
  "sql-and": {
    "prefix": "sql-and",
    "body": [
      "sqlite> SELECT * FROM COMPANY WHERE AGE >= 25 AND SALARY >= 65000;"
    ]
  },
  "sql-OR 运算符": {
    "prefix": "sql-OR 运算符",
    "body": [
      "sqlite> SELECT * FROM COMPANY WHERE AGE >= 25 OR SALARY >= 65000;"
    ]
  },
  "sql-Update": {
    "prefix": "sql-Update",
    "body": [
      "sqlite> UPDATE COMPANY SET ADDRESS = 'Texas', SALARY = 20000.00;",
      "sqlite> UPDATE COMPANY SET ADDRESS = 'Texas' WHERE ID = 6;"
    ]
  },
  "sql-Delete 语句": {
    "prefix": "sql-Delete",
    "body": [
      "sqlite> DELETE FROM COMPANY;",
      "sqlite> DELETE FROM COMPANY WHERE ID = 7;"
    ]
  },
  "sql-Like 子句": {
    "prefix": "sql-Like",
    "body": [
      "SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用：",
      "",
      "百分号 （%）",
      "",
      "下划线 （_）",
      "",
      "百分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。",
      "SELECT column_list ",
      "FROM table_name",
      "WHERE column LIKE 'XXXX%'",
      "",
      "or ",
      "",
      "SELECT column_list ",
      "FROM table_name",
      "WHERE column LIKE '%XXXX%'",
      "",
      "or",
      "",
      "SELECT column_list ",
      "FROM table_name",
      "WHERE column LIKE 'XXXX_'",
      "",
      "or",
      "",
      "SELECT column_list ",
      "FROM table_name",
      "WHERE column LIKE '_XXXX'",
      "",
      "or",
      "",
      "SELECT column_list ",
      "FROM table_name",
      "WHERE column LIKE '_XXXX_'",
      "您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。",
      "下面一些实例演示了 带有 '%' 和 '_' 运算符的 LIKE 子句不同的地方：",
      "",
      "语句 描述",
      "WHERE SALARY LIKE '200%' 查找以 200 开头的任意值",
      "WHERE SALARY LIKE '%200%' 查找任意位置包含 200 的任意值",
      "WHERE SALARY LIKE '_00%' 查找第二位和第三位为 00 的任意值",
      "WHERE SALARY LIKE '2_%_%'  查找以 2 开头，且长度至少为 3 个字符的任意值",
      "WHERE SALARY LIKE '%2' 查找以 2 结尾的任意值",
      "WHERE SALARY LIKE '_2%3' 查找第二位为 2，且以 3 结尾的任意值",
      "WHERE SALARY LIKE '2___3' 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值",
      "下面是一个实例，它显示 COMPANY 表中 AGE 以 2 开头的所有记录：",
      "",
      "sqlite> SELECT * FROM COMPANY WHERE AGE  LIKE '2%';"
    ]
  },
  "sql-Glob": {
    "prefix": "sql-Glob",
    "body": [
      "SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。",
      "",
      "星号 （*）",
      "",
      "问号 （?）",
      "",
      "星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。",
      "",
      "语法",
      "* 和 ? 的基本语法如下：",
      "",
      "SELECT FROM table_name",
      "WHERE column GLOB 'XXXX*'",
      "",
      "or ",
      "",
      "SELECT FROM table_name",
      "WHERE column GLOB '*XXXX*'",
      "",
      "or",
      "",
      "SELECT FROM table_name",
      "WHERE column GLOB 'XXXX?'",
      "",
      "or",
      "",
      "SELECT FROM table_name",
      "WHERE column GLOB '?XXXX'",
      "",
      "or",
      "",
      "SELECT FROM table_name",
      "WHERE column GLOB '?XXXX?'",
      "",
      "or",
      "",
      "SELECT FROM table_name",
      "WHERE column GLOB '????'",
      "您可以使用 AND 或 OR 运算符来结合 N 个数量的条件。在这里，XXXX 可以是任何数字或字符串值。",
      "",
      "实例",
      "下面一些实例演示了 带有 '*' 和 '?' 运算符的 GLOB 子句不同的地方：",
      "",
      "语句描述",
      "WHERE SALARY GLOB '200*' 查找以 200 开头的任意值",
      "WHERE SALARY GLOB '*200*' 查找任意位置包含 200 的任意值",
      "WHERE SALARY GLOB '?00*' 查找第二位和第三位为 00 的任意值",
      "WHERE SALARY GLOB '2??' 查找以 2 开头，且长度至少为 3 个字符的任意值",
      "WHERE SALARY GLOB '*2' 查找以 2 结尾的任意值",
      "WHERE SALARY GLOB '?2*3' 查找第二位为 2，且以 3 结尾的任意值",
      "WHERE SALARY GLOB '2???3' 查找长度为 5 位数，且以 2 开头以 3 结尾的任意值"
    ]
  },
  "sql-Limit 子句": {
    "prefix": "sql-Limit 子句",
    "body": [
      "SQLite 的 LIMIT 子句用于限制由 SELECT 语句返回的数据数量。",
      "",
      "语法",
      "带有 LIMIT 子句的 SELECT 语句的基本语法如下：",
      "",
      "SELECT column1, column2, columnN ",
      "FROM table_name",
      "LIMIT [no of rows]",
      "下面是 LIMIT 子句与 OFFSET 子句一起使用时的语法：",
      "",
      "SELECT column1, column2, columnN ",
      "FROM table_name",
      "LIMIT [no of rows] OFFSET [row num]",
      "SQLite 引擎将返回从下一行开始直到给定的 OFFSET 为止的所有行，如下面的最后一个实例所示。",
      "",
      "实例",
      "假设 COMPANY 表有以下记录：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "下面是一个实例，它限制了您想要从表中提取的行数：",
      "",
      "sqlite> SELECT * FROM COMPANY LIMIT 6;"
    ]
  },
  "sql-limit2": {
    "prefix": "sql-limit2",
    "body": [
      "但是，在某些情况下，可能需要从一个特定的偏移开始提取记录。下面是一个实例，从第三位开始提取 3 个记录：",
      "",
      "sqlite> SELECT * FROM COMPANY LIMIT 3 OFFSET 2;"
    ]
  },
  "sql-ORDER BY": {
    "prefix": "sql-ORDER BY",
    "body": [
      "下面是一个实例，它会将结果按 NAME 降序排序：",
      "",
      "sqlite> SELECT * FROM COMPANY ORDER BY NAME DESC;",
      "下面是一个实例，它会将结果按 NAME 和 SALARY 升序排序：",
      "",
      "sqlite> SELECT * FROM COMPANY ORDER BY NAME, SALARY ASC;",
      "SQLite 的 ORDER BY 子句是用来基于一个或多个列按升序或降序顺序排列数据。",
      "",
      "语法",
      "ORDER BY 子句的基本语法如下：",
      "",
      "SELECT column-list ",
      "FROM table_name ",
      "[WHERE condition] ",
      "[ORDER BY column1, column2, .. columnN] [ASC | DESC];",
      "您可以在 ORDER BY 子句中使用多个列。确保您使用的排序列在列清单中。",
      "下面是一个实例，它会将结果按 SALARY 升序排序：",
      "",
      "sqlite> SELECT * FROM COMPANY ORDER BY SALARY ASC;"
    ]
  },
  "sql- GROUP BY": {
    "prefix": "sql- GROUP BY",
    "body": [
      "SQLite Group By",
      "SQLite 的 GROUP BY 子句用于与 SELECT 语句一起使用，来对相同的数据进行分组。",
      "",
      "在 SELECT 语句中，GROUP BY 子句放在 WHERE 子句之后，放在 ORDER BY 子句之前。",
      "",
      "语法",
      "下面给出了 GROUP BY 子句的基本语法。GROUP BY 子句必须放在 WHERE 子句中的条件之后，必须放在 ORDER BY 子句之前。",
      "",
      "SELECT column-list",
      "FROM table_name",
      "WHERE [ conditions ]",
      "GROUP BY column1, column2....columnN",
      "ORDER BY column1, column2....columnN",
      "您可以在 GROUP BY 子句中使用多个列。确保您使用的分组列在列清单中。",
      "",
      "实例",
      "假设 COMPANY 表有以下记录：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "如果您想了解每个客户的工资总额，则可使用 GROUP BY 查询，如下所示：",
      "",
      "sqlite> SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME;",
      "这将产生以下结果：",
      "",
      "NAME        SUM(SALARY)",
      "----------  -----------",
      "Allen       15000.0",
      "David       85000.0",
      "James       10000.0",
      "Kim         45000.0",
      "Mark        65000.0",
      "Paul        20000.0",
      "Teddy       20000.0",
      "现在，让我们使用下面的 INSERT 语句在 COMPANY 表中另外创建三个记录：",
      "",
      "INSERT INTO COMPANY VALUES (8, 'Paul', 24, 'Houston', 20000.00 );",
      "INSERT INTO COMPANY VALUES (9, 'James', 44, 'Norway', 5000.00 );",
      "INSERT INTO COMPANY VALUES (10, 'James', 45, 'Texas', 5000.00 );",
      "现在，我们的表具有重复名称的记录，如下所示：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "8           Paul        24          Houston     20000.0",
      "9           James       44          Norway      5000.0",
      "10          James       45          Texas       5000.0",
      "让我们用同样的 GROUP BY 语句来对所有记录按 NAME 列进行分组，如下所示：",
      "",
      "sqlite> SELECT NAME, SUM(SALARY) FROM COMPANY GROUP BY NAME ORDER BY NAME;",
      "这将产生以下结果：",
      "",
      "NAME        SUM(SALARY)",
      "----------  -----------",
      "Allen       15000",
      "David       85000",
      "James       20000",
      "Kim         45000",
      "Mark        65000",
      "Paul        40000",
      "Teddy       20000",
      "让我们把 ORDER BY 子句与 GROUP BY 子句一起使用，如下所示：",
      "",
      "sqlite>  SELECT NAME, SUM(SALARY) ",
      "         FROM COMPANY GROUP BY NAME ORDER BY NAME DESC;",
      "这将产生以下结果：",
      "",
      "NAME        SUM(SALARY)",
      "----------  -----------",
      "Teddy       20000",
      "Paul        40000",
      "Mark        65000",
      "Kim         45000",
      "James       20000",
      "David       85000",
      "Allen       15000"
    ]
  },
  "sql-Having": {
    "prefix": "sql-Having",
    "body": [
      "SQLite Having 子句",
      "HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。",
      "",
      "WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。",
      "",
      "语法",
      "下面是 HAVING 子句在 SELECT 查询中的位置：",
      "",
      "SELECT",
      "FROM",
      "WHERE",
      "GROUP BY",
      "HAVING",
      "ORDER BY",
      "在一个查询中，HAVING 子句必须放在 GROUP BY 子句之后，必须放在 ORDER BY 子句之前。下面是包含 HAVING 子句的 SELECT 语句的语法：",
      "",
      "SELECT column1, column2",
      "FROM table1, table2",
      "WHERE [ conditions ]",
      "GROUP BY column1, column2",
      "HAVING [ conditions ]",
      "ORDER BY column1, column2",
      "实例",
      "假设 COMPANY 表有以下记录：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "8           Paul        24          Houston     20000.0",
      "9           James       44          Norway      5000.0",
      "10          James       45          Texas       5000.0",
      "下面是一个实例，它将显示名称计数小于 2 的所有记录：",
      "",
      "sqlite > SELECT * FROM COMPANY GROUP BY name HAVING count(name) < 2;",
      "这将产生以下结果：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "2           Allen       25          Texas       15000",
      "5           David       27          Texas       85000",
      "6           Kim         22          South-Hall  45000",
      "4           Mark        25          Rich-Mond   65000",
      "3           Teddy       23          Norway      20000",
      "下面是一个实例，它将显示名称计数大于 2 的所有记录：",
      "",
      "sqlite > SELECT * FROM COMPANY GROUP BY name HAVING count(name) > 2;",
      "这将产生以下结果：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "10          James       45          Texas       5000"
    ]
  },
  "sql-Distinct": {
    "prefix": "sql-Distinct",
    "body": [
      "SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。",
      "",
      "有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。",
      "",
      "语法",
      "用于消除重复记录的 DISTINCT 关键字的基本语法如下：",
      "",
      "SELECT DISTINCT column1, column2,.....columnN ",
      "FROM table_name",
      "WHERE [condition]",
      "实例",
      "假设 COMPANY 表有以下记录：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "8           Paul        24          Houston     20000.0",
      "9           James       44          Norway      5000.0",
      "10          James       45          Texas       5000.0",
      "首先，让我们来看看下面的 SELECT 查询，它将返回重复的工资记录：",
      "",
      "sqlite> SELECT name FROM COMPANY;",
      "这将产生以下结果：",
      "",
      "NAME",
      "----------",
      "Paul",
      "Allen",
      "Teddy",
      "Mark",
      "David",
      "Kim",
      "James",
      "Paul",
      "James",
      "James",
      "现在，让我们在上述的 SELECT 查询中使用 DISTINCT 关键字：",
      "",
      "sqlite> SELECT DISTINCT name FROM COMPANY;",
      "这将产生以下结果，没有任何重复的条目：",
      "",
      "NAME",
      "----------",
      "Paul",
      "Allen",
      "Teddy",
      "Mark",
      "David",
      "Kim",
      "James"
    ]
  },
  "sql-约束": {
    "prefix": "sql-约束",
    "body": [
      "约束是在表的数据列上强制执行的规则。这些是用来限制可以插入到表中的数据类型。这确保了数据库中数据的准确性和可靠性。",
      "",
      "约束可以是列级或表级。列级约束仅适用于列，表级约束被应用到整个表。",
      "",
      "以下是在 SQLite 中常用的约束。",
      "",
      "NOT NULL 约束：确保某列不能有 NULL 值。",
      "",
      "DEFAULT 约束：当某列没有指定值时，为该列提供默认值。",
      "",
      "UNIQUE 约束：确保某列中的所有值是不同的。",
      "",
      "PRIMARY Key 约束：唯一标识数据库表中的各行/记录。",
      "",
      "CHECK 约束：CHECK 约束确保某列中的所有值满足一定条件。",
      "",
      "NOT NULL 约束",
      "默认情况下，列可以保存 NULL 值。如果您不想某列有 NULL 值，那么需要在该列上定义此约束，指定在该列上不允许 NULL 值。",
      "",
      "NULL 与没有数据是不一样的，它代表着未知的数据。",
      "",
      "实例",
      "例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列，其中 ID、NAME 和 AGE 三列指定不接受 NULL 值：",
      "",
      "CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL",
      ");",
      "DEFAULT 约束",
      "DEFAULT 约束在 INSERT INTO 语句没有提供一个特定的值时，为列提供一个默认值。",
      "",
      "实例",
      "例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列。在这里，SALARY 列默认设置为 5000.00。所以当 INSERT INTO 语句没有为该列提供值时，该列将被设置为 5000.00。",
      "",
      "CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL    DEFAULT 50000.00",
      ");",
      "UNIQUE 约束",
      "UNIQUE 约束防止在一个特定的列存在两个记录具有相同的值。在 COMPANY 表中，例如，您可能要防止两个或两个以上的人具有相同的年龄。",
      "",
      "实例",
      "例如，下面的 SQLite 语句创建一个新的表 COMPANY，并增加了五列。在这里，AGE 列设置为 UNIQUE，所以不能有两个相同年龄的记录：",
      "",
      "CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL UNIQUE,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL    DEFAULT 50000.00",
      ");",
      "PRIMARY KEY 约束",
      "PRIMARY KEY 约束唯一标识数据库表中的每个记录。在一个表中可以有多个 UNIQUE 列，但只能有一个主键。在设计数据库表时，主键是很重要的。主键是唯一的 ID。",
      "",
      "我们使用主键来引用表中的行。可通过把主键设置为其他表的外键，来创建表之间的关系。由于\"长期存在编码监督\"，在 SQLite 中，主键可以是 NULL，这是与其他数据库不同的地方。",
      "",
      "主键是表中的一个字段，唯一标识数据库表中的各行/记录。主键必须包含唯一值。主键列不能有 NULL 值。",
      "",
      "一个表只能有一个主键，它可以由一个或多个字段组成。当多个字段作为主键，它们被称为复合键。",
      "",
      "如果一个表在任何字段上定义了一个主键，那么在这些字段上不能有两个记录具有相同的值。",
      "",
      "实例",
      "已经看到了我们创建以 ID 作为主键的 COMAPNY 表的各种实例：",
      "",
      "CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL",
      ");",
      "CHECK 约束",
      "CHECK 约束启用输入一条记录要检查值的条件。如果条件值为 false，则记录违反了约束，且不能输入到表。",
      "",
      "实例",
      "例如，下面的 SQLite 创建一个新的表 COMPANY，并增加了五列。在这里，我们为 SALARY 列添加 CHECK，所以工资不能为零：",
      "",
      "CREATE TABLE COMPANY3(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL    CHECK(SALARY > 0)",
      ");",
      "删除约束",
      "SQLite 支持 ALTER TABLE 的有限子集。在 SQLite 中，ALTER TABLE 命令允许用户重命名表，或向现有表添加一个新的列。重命名列，删除一列，或从一个表中添加或删除约束都是不可能的。"
    ]
  },
  "sql-Join": {
    "prefix": "sql-Join",
    "body": [
      "SQLite 的 Join 子句用于结合两个或多个数据库中表的记录。JOIN 是一种通过共同值来结合两个表中字段的手段。",
      "",
      "SQL 定义了三种主要类型的连接：",
      "",
      "交叉连接 - CROSS JOIN",
      "",
      "内连接 - INNER JOIN",
      "",
      "外连接 - OUTER JOIN",
      "",
      "在我们继续之前，让我们假设有两个表 COMPANY 和 DEPARTMENT。我们已经看到了用来填充 COMPANY 表的 INSERT 语句。现在让我们假设 COMPANY 表的记录列表如下：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "另一个表是 DEPARTMENT，定义如下：",
      "",
      "CREATE TABLE DEPARTMENT(",
      "   ID INT PRIMARY KEY      NOT NULL,",
      "   DEPT           CHAR(50) NOT NULL,",
      "   EMP_ID         INT      NOT NULL",
      ");",
      "下面是填充 DEPARTMENT 表的 INSERT 语句：",
      "",
      "INSERT INTO DEPARTMENT (ID, DEPT, EMP_ID)",
      "VALUES (1, 'IT Billing', 1 );",
      "",
      "INSERT INTO DEPARTMENT (ID, DEPT, EMP_ID)",
      "VALUES (2, 'Engineering', 2 );",
      "",
      "INSERT INTO DEPARTMENT (ID, DEPT, EMP_ID)",
      "VALUES (3, 'Finance', 7 );",
      "最后，我们在 DEPARTMENT 表中有下列的记录列表：",
      "",
      "ID          DEPT        EMP_ID",
      "----------  ----------  ----------",
      "1           IT Billing  1",
      "2           Engineerin  2",
      "3           Finance     7",
      "交叉连接 - CROSS JOIN",
      "交叉连接（CROSS JOIN）把第一个表的每一行与第二个表的每一行进行匹配。如果两个输入表分别有 x 和 y 行，则结果表有 x*y 行。由于交叉连接（CROSS JOIN）有可能产生非常大的表，使用时必须谨慎，只在适当的时候使用它们。",
      "",
      "交叉连接的操作，它们都返回被连接的两个表所有数据行的笛卡尔积，返回到的数据行数等于第一个表中符合查询条件的数据行数乘以第二个表中符合查询条件的数据行数。",
      "",
      "下面是交叉连接（CROSS JOIN）的语法：",
      "",
      "SELECT ... FROM table1 CROSS JOIN table2 ...",
      "基于上面的表，我们可以写一个交叉连接（CROSS JOIN），如下所示：",
      "",
      "sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY CROSS JOIN DEPARTMENT;",
      "上面的查询会产生以下结果：",
      "",
      "EMP_ID      NAME        DEPT",
      "----------  ----------  ----------",
      "1           Paul        IT Billing",
      "2           Paul        Engineerin",
      "7           Paul        Finance",
      "1           Allen       IT Billing",
      "2           Allen       Engineerin",
      "7           Allen       Finance",
      "1           Teddy       IT Billing",
      "2           Teddy       Engineerin",
      "7           Teddy       Finance",
      "1           Mark        IT Billing",
      "2           Mark        Engineerin",
      "7           Mark        Finance",
      "1           David       IT Billing",
      "2           David       Engineerin",
      "7           David       Finance",
      "1           Kim         IT Billing",
      "2           Kim         Engineerin",
      "7           Kim         Finance",
      "1           James       IT Billing",
      "2           James       Engineerin",
      "7           James       Finance",
      "内连接 - INNER JOIN",
      "内连接（INNER JOIN）根据连接谓词结合两个表（table1 和 table2）的列值来创建一个新的结果表。查询会把 table1 中的每一行与 table2 中的每一行进行比较，找到所有满足连接谓词的行的匹配对。当满足连接谓词时，A 和 B 行的每个匹配对的列值会合并成一个结果行。",
      "",
      "内连接（INNER JOIN）是最常见的连接类型，是默认的连接类型。INNER 关键字是可选的。",
      "",
      "下面是内连接（INNER JOIN）的语法：",
      "",
      "SELECT ... FROM table1 [INNER] JOIN table2 ON conditional_expression ...",
      "为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明内连接（INNER JOIN）条件。这个表达式指定一个或多个列的列表：",
      "",
      "SELECT ... FROM table1 JOIN table2 USING ( column1 ,... ) ...",
      "自然连接（NATURAL JOIN）类似于 JOIN...USING，只是它会自动测试存在两个表中的每一列的值之间相等值：",
      "",
      "SELECT ... FROM table1 NATURAL JOIN table2...",
      "基于上面的表，我们可以写一个内连接（INNER JOIN），如下所示：",
      "",
      "sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT",
      "        ON COMPANY.ID = DEPARTMENT.EMP_ID;",
      "上面的查询会产生以下结果：",
      "",
      "EMP_ID      NAME        DEPT",
      "----------  ----------  ----------",
      "1           Paul        IT Billing",
      "2           Allen       Engineerin",
      "7           James       Finance",
      "外连接 - OUTER JOIN",
      "外连接（OUTER JOIN）是内连接（INNER JOIN）的扩展。虽然 SQL 标准定义了三种类型的外连接：LEFT、RIGHT、FULL，但 SQLite 只支持 左外连接（LEFT OUTER JOIN）。",
      "",
      "外连接（OUTER JOIN）声明条件的方法与内连接（INNER JOIN）是相同的，使用 ON、USING 或 NATURAL 关键字来表达。最初的结果表以相同的方式进行计算。一旦主连接计算完成，外连接（OUTER JOIN）将从一个或两个表中任何未连接的行合并进来，外连接的列使用 NULL 值，将它们附加到结果表中。",
      "",
      "下面是左外连接（LEFT OUTER JOIN）的语法：",
      "",
      "SELECT ... FROM table1 LEFT OUTER JOIN table2 ON conditional_expression ...",
      "为了避免冗余，并保持较短的措辞，可以使用 USING 表达式声明外连接（OUTER JOIN）条件。这个表达式指定一个或多个列的列表：",
      "",
      "SELECT ... FROM table1 LEFT OUTER JOIN table2 USING ( column1 ,... ) ...",
      "基于上面的表，我们可以写一个外连接（OUTER JOIN），如下所示：",
      "",
      "sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT",
      "        ON COMPANY.ID = DEPARTMENT.EMP_ID;",
      "上面的查询会产生以下结果：",
      "",
      "EMP_ID      NAME        DEPT",
      "----------  ----------  ----------",
      "1           Paul        IT Billing",
      "2           Allen       Engineerin",
      "            Teddy",
      "            Mark",
      "            David",
      "            Kim",
      "7           James       Finance"
    ]
  },
  "sql-Unions": {
    "prefix": "sql-Unions",
    "body": [
      "SQLite Unions 子句",
      "SQLite的 UNION 子句/运算符用于合并两个或多个 SELECT 语句的结果，不返回任何重复的行。",
      "",
      "为了使用 UNION，每个 SELECT 被选择的列数必须是相同的，相同数目的列表达式，相同的数据类型，并确保它们有相同的顺序，但它们不必具有相同的长度。",
      "",
      "语法",
      "UNION 的基本语法如下：",
      "",
      "SELECT column1 [, column2 ]",
      "FROM table1 [, table2 ]",
      "[WHERE condition]",
      "",
      "UNION",
      "",
      "SELECT column1 [, column2 ]",
      "FROM table1 [, table2 ]",
      "[WHERE condition]",
      "这里给定的条件根据需要可以是任何表达式。",
      "",
      "实例",
      "假设有下面两个表，（1）COMPANY 表如下所示：",
      "",
      "sqlite> select * from COMPANY;",
      "ID          NAME                  AGE         ADDRESS     SALARY",
      "----------  --------------------  ----------  ----------  ----------",
      "1           Paul                  32          California  20000.0",
      "2           Allen                 25          Texas       15000.0",
      "3           Teddy                 23          Norway      20000.0",
      "4           Mark                  25          Rich-Mond   65000.0",
      "5           David                 27          Texas       85000.0",
      "6           Kim                   22          South-Hall  45000.0",
      "7           James                 24          Houston     10000.0",
      "（2）另一个表是 DEPARTMENT，如下所示：",
      "",
      "ID          DEPT                  EMP_ID",
      "----------  --------------------  ----------",
      "1           IT Billing            1",
      "2           Engineering           2",
      "3           Finance               7",
      "4           Engineering           3",
      "5           Finance               4",
      "6           Engineering           5",
      "7           Finance               6",
      "现在，让我们使用 SELECT 语句及 UNION 子句来连接两个表，如下所示：",
      "",
      "sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT",
      "        ON COMPANY.ID = DEPARTMENT.EMP_ID",
      "   UNION",
      "     SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT",
      "        ON COMPANY.ID = DEPARTMENT.EMP_ID;",
      "这将产生以下结果：",
      "",
      "EMP_ID      NAME                  DEPT",
      "----------  --------------------  ----------",
      "1           Paul                  IT Billing",
      "2           Allen                 Engineerin",
      "3           Teddy                 Engineerin",
      "4           Mark                  Finance",
      "5           David                 Engineerin",
      "6           Kim                   Finance",
      "7           James                 Finance",
      "UNION ALL 子句",
      "UNION ALL 运算符用于结合两个 SELECT 语句的结果，包括重复行。",
      "",
      "适用于 UNION 的规则同样适用于 UNION ALL 运算符。",
      "",
      "语法",
      "UNION ALL 的基本语法如下：",
      "",
      "SELECT column1 [, column2 ]",
      "FROM table1 [, table2 ]",
      "[WHERE condition]",
      "",
      "UNION ALL",
      "",
      "SELECT column1 [, column2 ]",
      "FROM table1 [, table2 ]",
      "[WHERE condition]",
      "这里给定的条件根据需要可以是任何表达式。",
      "",
      "实例",
      "现在，让我们使用 SELECT 语句及 UNION ALL 子句来连接两个表，如下所示：",
      "",
      "sqlite> SELECT EMP_ID, NAME, DEPT FROM COMPANY INNER JOIN DEPARTMENT",
      "        ON COMPANY.ID = DEPARTMENT.EMP_ID",
      "   UNION ALL",
      "     SELECT EMP_ID, NAME, DEPT FROM COMPANY LEFT OUTER JOIN DEPARTMENT",
      "        ON COMPANY.ID = DEPARTMENT.EMP_ID;",
      "这将产生以下结果：",
      "",
      "EMP_ID      NAME                  DEPT",
      "----------  --------------------  ----------",
      "1           Paul                  IT Billing",
      "2           Allen                 Engineerin",
      "3           Teddy                 Engineerin",
      "4           Mark                  Finance",
      "5           David                 Engineerin",
      "6           Kim                   Finance",
      "7           James                 Finance",
      "1           Paul                  IT Billing",
      "2           Allen                 Engineerin",
      "3           Teddy                 Engineerin",
      "4           Mark                  Finance",
      "5           David                 Engineerin",
      "6           Kim                   Finance",
      "7           James                 Finance"
    ]
  },
  "sql-NULL": {
    "prefix": "sql-NULL",
    "body": [
      "SQLite 的 NULL 是用来表示一个缺失值的项。表中的一个 NULL 值是在字段中显示为空白的一个值。",
      "",
      "带有 NULL 值的字段是一个不带有值的字段。NULL 值与零值或包含空格的字段是不同的，理解这点是非常重要的。",
      "",
      "语法",
      "创建表时使用 NULL 的基本语法如下：",
      "",
      "SQLite> CREATE TABLE COMPANY(",
      "   ID INT PRIMARY KEY     NOT NULL,",
      "   NAME           TEXT    NOT NULL,",
      "   AGE            INT     NOT NULL,",
      "   ADDRESS        CHAR(50),",
      "   SALARY         REAL",
      ");",
      "在这里，NOT NULL 表示列总是接受给定数据类型的显式值。这里有两个列我们没有使用 NOT NULL，这意味着这两个列可以为 NULL。",
      "",
      "带有 NULL 值的字段在记录创建的时候可以保留为空。",
      "",
      "实例",
      "NULL 值在选择数据时会引起问题，因为当把一个未知的值与另一个值进行比较时，结果总是未知的，且不会包含在最后的结果中。假设有下面的表，COMPANY 的记录如下所示：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22          South-Hall  45000.0",
      "7           James       24          Houston     10000.0",
      "让我们使用 UPDATE 语句来设置一些允许空值的值为 NULL，如下所示：",
      "",
      "sqlite> UPDATE COMPANY SET ADDRESS = NULL, SALARY = NULL where ID IN(6,7);",
      "现在，COMPANY 表的记录如下所示：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "6           Kim         22",
      "7           James       24",
      "接下来，让我们看看 IS NOT NULL 运算符的用法，它用来列出所有 SALARY 不为 NULL 的记录：",
      "",
      "sqlite> SELECT  ID, NAME, AGE, ADDRESS, SALARY",
      "        FROM COMPANY",
      "        WHERE SALARY IS NOT NULL;",
      "上面的 SQLite 语句将产生下面的结果：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "1           Paul        32          California  20000.0",
      "2           Allen       25          Texas       15000.0",
      "3           Teddy       23          Norway      20000.0",
      "4           Mark        25          Rich-Mond   65000.0",
      "5           David       27          Texas       85000.0",
      "下面是 IS NULL 运算符的用法，将列出所有 SALARY 为 NULL 的记录：",
      "",
      "sqlite> SELECT  ID, NAME, AGE, ADDRESS, SALARY",
      "        FROM COMPANY",
      "        WHERE SALARY IS NULL;",
      "上面的 SQLite 语句将产生下面的结果：",
      "",
      "ID          NAME        AGE         ADDRESS     SALARY",
      "----------  ----------  ----------  ----------  ----------",
      "6           Kim         22",
      "7           James       24"
    ]
  },
  "sql-别名": {
    "prefix": "sql-别名",
    "body": [
      "SQLite 别名",
      "您可以暂时把表或列重命名为另一个名字，这被称为别名。使用表别名是指在一个特定的 SQLite 语句中重命名表。重命名是临时的改变，在数据库中实际的表的名称不会改变。",
      "",
      "列别名用来为某个特定的 SQLite 语句重命名表中的列。",
      "",
      "语法",
      "表 别名的基本语法如下：",
      "",
      "SELECT column1, column2....",
      "FROM table_name AS alias_name",
      "WHERE [condition];",
      "列 别名的基本语法如下：",
      "",
      "SELECT column_name AS alias_name",
      "FROM table_name",
      "WHERE [condition];",
      "实例",
      "假设有下面两个表，（1）COMPANY 表如下所示：",
      "",
      "sqlite> select * from COMPANY;",
      "ID          NAME                  AGE         ADDRESS     SALARY",
      "----------  --------------------  ----------  ----------  ----------",
      "1           Paul                  32          California  20000.0",
      "2           Allen                 25          Texas       15000.0",
      "3           Teddy                 23          Norway      20000.0",
      "4           Mark                  25          Rich-Mond   65000.0",
      "5           David                 27          Texas       85000.0",
      "6           Kim                   22          South-Hall  45000.0",
      "7           James                 24          Houston     10000.0",
      "（2）另一个表是 DEPARTMENT，如下所示：",
      "",
      "ID          DEPT                  EMP_ID",
      "----------  --------------------  ----------",
      "1           IT Billing            1",
      "2           Engineering           2",
      "3           Finance               7",
      "4           Engineering           3",
      "5           Finance               4",
      "6           Engineering           5",
      "7           Finance               6",
      "现在，下面是 表别名 的用法，在这里我们使用 C 和 D 分别作为 COMPANY 和 DEPARTMENT 表的别名：",
      "",
      "sqlite> SELECT C.ID, C.NAME, C.AGE, D.DEPT",
      "        FROM COMPANY AS C, DEPARTMENT AS D",
      "        WHERE  C.ID = D.EMP_ID;",
      "上面的 SQLite 语句将产生下面的结果：",
      "",
      "ID          NAME        AGE         DEPT",
      "----------  ----------  ----------  ----------",
      "1           Paul        32          IT Billing",
      "2           Allen       25          Engineerin",
      "3           Teddy       23          Engineerin",
      "4           Mark        25          Finance",
      "5           David       27          Engineerin",
      "6           Kim         22          Finance",
      "7           James       24          Finance",
      "让我们看一个 列别名 的实例，在这里 COMPANY_ID 是 ID 列的别名，COMPANY_NAME 是 name 列的别名：",
      "",
      "sqlite> SELECT C.ID AS COMPANY_ID, C.NAME AS COMPANY_NAME, C.AGE, D.DEPT",
      "        FROM COMPANY AS C, DEPARTMENT AS D",
      "        WHERE  C.ID = D.EMP_ID;",
      "上面的 SQLite 语句将产生下面的结果：",
      "",
      "COMPANY_ID  COMPANY_NAME  AGE         DEPT",
      "----------  ------------  ----------  ----------",
      "1           Paul          32          IT Billing",
      "2           Allen         25          Engineerin",
      "3           Teddy         23          Engineerin",
      "4           Mark          25          Finance",
      "5           David         27          Engineerin",
      "6           Kim           22          Finance",
      "7           James         24          Finance"
    ]
  },
  "sql-IN 操作符": {
    "prefix": "sql-IN 操作符",
    "body": [
      "IN 操作符",
      "IN 操作符允许您在 WHERE 子句中规定多个值。",
      "",
      "SQL IN 语法",
      "SELECT column_name(s)",
      "FROM table_name",
      "WHERE column_name IN (value1,value2,...);",
      "",
      "演示数据库",
      "在本教程中，我们将使用 RUNOOB 样本数据库。",
      "",
      "下面是选自 \"Websites\" 表的数据：",
      "",
      "+----+--------------+---------------------------+-------+---------+",
      "| id | name         | url                       | alexa | country |",
      "+----+--------------+---------------------------+-------+---------+",
      "| 1  | Google       | https://www.google.cm/    | 1     | USA     |",
      "| 2  | 淘宝          | https://www.taobao.com/   | 13    | CN      |",
      "| 3  | 菜鸟教程      | http://www.runoob.com/    | 4689  | CN      |",
      "| 4  | 微博          | http://weibo.com/         | 20    | CN      |",
      "| 5  | Facebook     | https://www.facebook.com/ | 3     | USA     |",
      "| 7  | stackoverflow | http://stackoverflow.com/ |   0 | IND     |",
      "+----+---------------+---------------------------+-------+---------+",
    ]
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  },
  "sql-": {
    "prefix": "sql-",
    "body": []
  }
}