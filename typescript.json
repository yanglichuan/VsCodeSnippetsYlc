{
  // Place your snippets for typescript here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  "ts-boolean": {
    "prefix": "ts-boolean",
    "body": [
      "最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。",
      "",
      "let isDone: boolean = false;"
    ]
  },
  "ts-number": {
    "prefix": "ts-number",
    "body": [
      "和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。",
      "",
      "let decLiteral: number = 6;",
      "let hexLiteral: number = 0xf00d;",
      "let binaryLiteral: number = 0b1010;",
      "let octalLiteral: number = 0o744;",
      "字符串"
    ]
  },
  "ts-string": {
    "prefix": "ts-string",
    "body": [
      "JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ \"）或单引号（'）表示字符串。",
      "",
      "let name: string = \"bob\";",
      "name = \"smith\";",
      "你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式",
      "",
      "let name: string = `Gene`;",
      "let age: number = 37;",
      "let sentence: string = `Hello, my name is ${ name }.",
      "",
      "I'll be ${ age + 1 } years old next month.`;",
      "这与下面定义sentence的方式效果相同：",
      "",
      "let sentence: string = \"Hello, my name is \" + name + \".\n\n\" +",
      "    \"I'll be \" + (age + 1) + \" years old next month.\";"
    ]
  },
  "ts-数组": {
    "prefix": "ts-数组",
    "body": [
      "TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：",
      "",
      "let list: number[] = [1, 2, 3];",
      "第二种方式是使用数组泛型，Array<元素类型>：",
      "",
      "let list: Array<number> = [1, 2, 3];"
    ]
  },
  "ts-元组 Tuple": {
    "prefix": "ts-元组 Tuple",
    "body": [
      "元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。",
      "",
      "// Declare a tuple type",
      "let x: [string, number];",
      "// Initialize it",
      "x = ['hello', 10]; // OK",
      "// Initialize it incorrectly",
      "x = [10, 'hello']; // Error",
      "当访问一个已知索引的元素，会得到正确的类型：",
      "",
      "console.log(x[0].substr(1)); // OK",
      "console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'",
      "当访问一个越界的元素，会使用联合类型替代：",
      "",
      "x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型",
      "",
      "console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString",
      "",
      "x[6] = true; // Error, 布尔不是(string | number)类型",
      "联合类型是高级主题，我们会在以后的章节里讨论它。"
    ]
  },
  "ts-enum": {
    "prefix": "ts-enum",
    "body": [
      "enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。",
      "",
      "enum Color {Red, Green, Blue}",
      "let c: Color = Color.Green;",
      "默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：",
      "",
      "enum Color {Red = 1, Green, Blue}",
      "let c: Color = Color.Green;",
      "或者，全部都采用手动赋值：",
      "",
      "enum Color {Red = 1, Green = 2, Blue = 4}",
      "let c: Color = Color.Green;",
      "枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：",
      "",
      "enum Color {Red = 1, Green, Blue}",
      "let colorName: string = Color[2];",
      "",
      "console.log(colorName);  // 显示'Green'因为上面代码里它的值是2"
    ]
  },
  "ts-Any": {
    "prefix": "ts-Any",
    "body": [
      "有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：",
      "",
      "let notSure: any = 4;",
      "notSure = \"maybe a string instead\";",
      "notSure = false; // okay, definitely a boolean",
      "在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：",
      "",
      "let notSure: any = 4;",
      "notSure.ifItExists(); // okay, ifItExists might exist at runtime",
      "notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)",
      "",
      "let prettySure: Object = 4;",
      "prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.",
      "当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：",
      "",
      "let list: any[] = [1, true, \"free\"];",
      "",
      "list[1] = 100;"
    ]
  },
  "ts-Void": {
    "prefix": "ts-Void",
    "body": [
      "某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：",
      "",
      "function warnUser(): void {",
      "    console.log(\"This is my warning message\");",
      "}",
      "声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：",
      "",
      "let unusable: void = undefined;"
    ]
  },
  "ts-Never": {
    "prefix": "ts-Never",
    "body": [
      "never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。",
      "",
      "never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。",
      "",
      "下面是一些返回never类型的函数：",
      "",
      "// 返回never的函数必须存在无法达到的终点",
      "function error(message: string): never {",
      "    throw new Error(message);",
      "}",
      "",
      "// 推断的返回值类型为never",
      "function fail() {",
      "    return error(\"Something failed\");",
      "}",
      "",
      "// 返回never的函数必须存在无法达到的终点",
      "function infiniteLoop(): never {",
      "    while (true) {",
      "    }",
      "}"
    ]
  },
  "ts-Object": {
    "prefix": "ts-Object",
    "body": [
      "object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。",
      "",
      "使用object类型，就可以更好的表示像Object.create这样的API。例如：",
      "",
      "declare function create(o: object | null): void;",
      "",
      "create({ prop: 0 }); // OK",
      "create(null); // OK",
      "",
      "create(42); // Error",
      "create(\"string\"); // Error",
      "create(false); // Error",
      "create(undefined); // Error"
    ]
  },
  "ts-类型断言": {
    "prefix": "ts-类型断言",
    "body": [
      "有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。",
      "",
      "通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。",
      "",
      "类型断言有两种形式。 其一是“尖括号”语法：",
      "",
      "let someValue: any = \"this is a string\";",
      "",
      "let strLength: number = (<string>someValue).length;",
      "另一个为as语法：",
      "",
      "let someValue: any = \"this is a string\";",
      "",
      "let strLength: number = (someValue as string).length;",
      "两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。"
    ]
  },
  "ts-var": {
    "prefix": "ts-var",
    "body": [
      "一直以来我们都是通过var关键字定义JavaScript变量。",
      "",
      "var a = 10;",
      "大家都能理解，这里定义了一个名为a值为10的变量。",
      "",
      "我们也可以在函数内部定义变量：",
      "",
      "function f() {",
      "    var message = \"Hello, world!\";",
      "",
      "    return message;",
      "}",
      "并且我们也可以在其它函数内部访问相同的变量。",
      "",
      "function f() {",
      "    var a = 10;",
      "    return function g() {",
      "        var b = a + 1;",
      "        return b;",
      "    }",
      "}",
      "",
      "var g = f();",
      "g(); // returns 11;",
      "上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。",
      "",
      "function f() {",
      "    var a = 1;",
      "",
      "    a = 2;",
      "    var b = g();",
      "    a = 3;",
      "",
      "    return b;",
      "",
      "    function g() {",
      "        return a;",
      "    }",
      "}",
      "",
      "f(); // returns 2"
    ]
  },
  "ts-let": {
    "prefix": "ts-let",
    "body": [
      "现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。",
      "",
      "let hello = \"Hello!\";",
      "主要的区别不在语法上，而是语义，我们接下来会深入研究。",
      "",
      "块作用域",
      "当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。",
      "",
      "function f(input: boolean) {",
      "    let a = 100;",
      "",
      "    if (input) {",
      "        // Still okay to reference 'a'",
      "        let b = a + 1;",
      "        return b;",
      "    }",
      "",
      "    // Error: 'b' doesn't exist here",
      "    return b;",
      "}"
    ]
  },
  "ts-const": {
    "prefix": "ts-const",
    "body": [
      "const 声明是声明变量的另一种方式。",
      "",
      "const numLivesForCat = 9;",
      "它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。",
      "",
      "这很好理解，它们引用的值是不可变的。",
      "",
      "const numLivesForCat = 9;",
      "const kitty = {",
      "    name: \"Aurora\",",
      "    numLives: numLivesForCat,",
      "}",
      "",
      "// Error",
      "kitty = {",
      "    name: \"Danielle\",",
      "    numLives: numLivesForCat",
      "};",
      "",
      "// all \"okay\"",
      "kitty.name = \"Rory\";",
      "kitty.name = \"Kitty\";",
      "kitty.name = \"Cat\";",
      "kitty.numLives--;",
      "除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。"
    ]
  },
  "ts-解构数组": {
    "prefix": "ts-解构数组",
    "body": [
      "最简单的解构莫过于数组的解构赋值了：",
      "",
      "let input = [1, 2];",
      "let [first, second] = input;",
      "console.log(first); // outputs 1",
      "console.log(second); // outputs 2",
      "这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：",
      "",
      "first = input[0];",
      "second = input[1];",
      "解构作用于已声明的变量会更好：",
      "",
      "// swap variables",
      "[first, second] = [second, first];",
      "作用于函数参数：",
      "",
      "function f([first, second]: [number, number]) {",
      "    console.log(first);",
      "    console.log(second);",
      "}",
      "f(input);",
      "你可以在数组里使用...语法创建剩余变量：",
      "",
      "let [first, ...rest] = [1, 2, 3, 4];",
      "console.log(first); // outputs 1",
      "console.log(rest); // outputs [ 2, 3, 4 ]",
      "当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：",
      "",
      "let [first] = [1, 2, 3, 4];",
      "console.log(first); // outputs 1",
      "或其它元素：",
      "",
      "let [, second, , fourth] = [1, 2, 3, 4];"
    ]
  },
  "ts-解构对象": {
    "prefix": "ts-解构对象",
    "body": [
      "你也可以解构对象：",
      "",
      "let o = {",
      "    a: \"foo\",",
      "    b: 12,",
      "    c: \"bar\"",
      "};",
      "let { a, b } = o;",
      "这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。",
      "",
      "就像数组解构，你可以用没有声明的赋值：",
      "",
      "({ a, b } = { a: \"baz\", b: 101 });",
      "注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。",
      "",
      "你可以在对象里使用...语法创建剩余变量：",
      "",
      "let { a, ...passthrough } = o;",
      "let total = passthrough.b + passthrough.c.length;"
    ]
  },
  "ts-展开": {
    "prefix": "ts-展开",
    "body": [
      "展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：",
      "",
      "let first = [1, 2];",
      "let second = [3, 4];",
      "let bothPlus = [0, ...first, ...second, 5];",
      "这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。",
      "",
      "你还可以展开对象：",
      "",
      "let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };",
      "let search = { ...defaults, food: \"rich\" };",
      "search的值为{ food: \"rich\", price: \"$$\", ambiance: \"noisy\" }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：",
      "",
      "let defaults = { food: \"spicy\", price: \"$$\", ambiance: \"noisy\" };",
      "let search = { food: \"rich\", ...defaults };"
    ]
  },
  "ts-安装和运行": {
    "prefix": "ts-安装和运行",
    "body": [
      "针对使用npm的用户：",
      "",
      "> npm install -g typescript",
      "构建你的第一个TypeScript文件",
      "在编辑器，将下面的代码输入到greeter.ts文件里：",
      "",
      "function greeter(person) {",
      "    return \"Hello, \" + person;",
      "}",
      "",
      "let user = \"Jane User\";",
      "",
      "document.body.innerHTML = greeter(user);",
      "编译代码",
      "我们使用了.ts扩展名，但是这段代码仅仅是JavaScript而已。 你可以直接从现有的JavaScript应用里复制/粘贴这段代码。",
      "",
      "在命令行上，运行TypeScript编译器：",
      "",
      "tsc greeter.ts",
      "输出结果为一个greeter.js文件，它包含了和输入文件中相同的JavsScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了！",
    ]
  },
  "ts-接口初识": {
    "prefix": "ts-接口初识",
    "body": [
      "让我们开发这个示例应用。这里我们使用接口来描述一个拥有firstName和lastName字段的对象。 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。",
      "",
      "interface Person {",
      "    firstName: string;",
      "    lastName: string;",
      "}",
      "",
      "function greeter(person: Person) {",
      "    return \"Hello, \" + person.firstName + \" \" + person.lastName;",
      "}",
      "",
      "let user = { firstName: \"Jane\", lastName: \"User\" };",
      "",
      "document.body.innerHTML = greeter(user);",
    ]
  },
  "ts-类初识": {
    "prefix": "ts-类初识",
    "body": [
      "最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。",
      "",
      "让我们创建一个Student类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。",
      "",
      "还要注意的是，在构造函数的参数上使用public等同于创建了同名的成员变量。",
      "",
      "class Student {",
      "    fullName: string;",
      "    constructor(public firstName, public middleInitial, public lastName) {",
      "        this.fullName = firstName + \" \" + middleInitial + \" \" + lastName;",
      "    }",
      "}",
      "",
      "interface Person {",
      "    firstName: string;",
      "    lastName: string;",
      "}",
      "",
      "function greeter(person : Person) {",
      "    return \"Hello, \" + person.firstName + \" \" + person.lastName;",
      "}",
      "",
      "let user = new Student(\"Jane\", \"M.\", \"User\");",
      "",
      "document.body.innerHTML = greeter(user);",
      "重新运行tsc greeter.ts，你会看到生成的JavaScript代码和原先的一样。 TypeScript里的类只是JavaScript里常用的基于原型面向对象编程的简写。",
    ]
  },
  "ts-interface初探": {
    "prefix": "ts-interface初探",
    "body": [
      "下面通过一个简单示例来观察接口是如何工作的：",
      "",
      "function printLabel(labelledObj: { label: string }) {",
      "  console.log(labelledObj.label);",
      "}",
      "",
      "let myObj = { size: 10, label: \"Size 10 Object\" };",
      "printLabel(myObj);",
      "类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 然而，有些时候TypeScript却并不会这么宽松，我们下面会稍做讲解。",
      "",
      "下面我们重写上面的例子，这次使用接口来描述：必须包含一个label属性且类型为string：",
      "",
      "interface LabelledValue {",
      "  label: string;",
      "}",
      "",
      "function printLabel(labelledObj: LabelledValue) {",
      "  console.log(labelledObj.label);",
      "}",
      "",
      "let myObj = {size: 10, label: \"Size 10 Object\"};",
      "printLabel(myObj);",
      "LabelledValue接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label属性且类型为string的对象。 需要注意的是，我们在这里并不能像在其它语言里一样，说传给 printLabel的对象实现了这个接口。我们只会去关注值的外形。 只要传入的对象满足上面提到的必要条件，那么它就是被允许的。",
      "",
      "还有一点值得提的是，类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以",
    ]
  },
  "ts-interface可选属性": {
    "prefix": "ts-interface可选属性",
    "body": [
      "接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。",
      "",
      "下面是应用了“option bags”的例子：",
      "",
      "interface SquareConfig {",
      "  color?: string;",
      "  width?: number;",
      "}",
      "",
      "function createSquare(config: SquareConfig): {color: string; area: number} {",
      "  let newSquare = {color: \"white\", area: 100};",
      "  if (config.color) {",
      "    newSquare.color = config.color;",
      "  }",
      "  if (config.width) {",
      "    newSquare.area = config.width * config.width;",
      "  }",
      "  return newSquare;",
      "}",
      "",
      "let mySquare = createSquare({color: \"black\"});",
      "带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。",
      "",
      "可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 比如，我们故意将 createSquare里的color属性名拼错，就会得到一个错误提示：",
      "",
      "interface SquareConfig {",
      "  color?: string;",
      "  width?: number;",
      "}",
      "",
      "function createSquare(config: SquareConfig): { color: string; area: number } {",
      "  let newSquare = {color: \"white\", area: 100};",
      "  if (config.clor) {",
      "    // Error: Property 'clor' does not exist on type 'SquareConfig'",
      "    newSquare.color = config.clor;",
      "  }",
      "  if (config.width) {",
      "    newSquare.area = config.width * config.width;",
      "  }",
      "  return newSquare;",
      "}",
      "",
      "let mySquare = createSquare({color: \"black\"});",
    ]
  },
  "ts-interface只读属性": {
    "prefix": "ts-interface只读属性",
    "body": [
      "一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:",
      "",
      "interface Point {",
      "    readonly x: number;",
      "    readonly y: number;",
      "}",
      "你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。",
      "",
      "let p1: Point = { x: 10, y: 20 };",
      "p1.x = 5; // error!",
      "TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：",
      "",
      "",
      " ",
      "let a: number[] = [1, 2, 3, 4];",
      "let ro: ReadonlyArray<number> = a;",
      "ro[0] = 12; // error!",
      "ro.push(5); // error!",
      "ro.length = 100; // error!",
      "a = ro; // error!",
      "上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：",
      "",
      "a = ro as number[];",
    ]
  },
  "ts-readonly vs const": {
    "prefix": "ts-readonly vs const",
    "body": [
      "最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。",
    ]
  },
  "ts-interface函数类型": {
    "prefix": "ts-interface函数类型",
    "body": [
      "接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。",
      "",
      "为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。",
      "",
      "",
      " ",
      "interface SearchFunc {",
      "  (source: string, subString: string): boolean;",
      "}",
      "这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。",
      "",
      "let mySearch: SearchFunc;",
      "mySearch = function(source: string, subString: string) {",
      "  let result = source.search(subString);",
      "  return result > -1;",
      "}",
      "对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：",
      "",
      "let mySearch: SearchFunc;",
      "mySearch = function(src: string, sub: string): boolean {",
      "  let result = src.search(sub);",
      "  return result > -1;",
      "}",
      "函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。",
      "",
      "",
      " ",
      "let mySearch: SearchFunc;",
      "mySearch = function(src, sub) {",
      "    let result = src.search(sub);",
      "    return result > -1;",
      "}",
    ]
  },
  "ts-interface可索引的类型": {
    "prefix": "ts-interface可索引的类型",
    "body": [
      "与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[\"daniel\"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：",
      "",
      "interface StringArray {",
      "  [index: number]: string;",
      "}",
      "",
      "let myArray: StringArray;",
      "myArray = [\"Bob\", \"Fred\"];",
      "",
      "let myStr: string = myArray[0];",
      "上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。",
      "",
      "TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用\"100\"（一个string）去索引，因此两者需要保持一致。",
      "",
      "class Animal {",
      "    name: string;",
      "}",
      "class Dog extends Animal {",
      "    breed: string;",
      "}",
      "",
      "// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!",
      "interface NotOkay {",
      "    [x: number]: Animal;",
      "    [x: string]: Dog;",
      "}",
      "",
      " ",
      "字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[\"property\"]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：",
      "",
      "interface NumberDictionary {",
      "  [index: string]: number;",
      "  length: number;    // 可以，length是number类型",
      "  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配",
      "}",
      "最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：",
      "",
      "interface ReadonlyStringArray {",
      "    readonly [index: number]: string;",
      "}",
      "let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"];",
      "myArray[2] = \"Mallory\"; // error!",
      "你不能设置myArray[2]，因为索引签名是只读的。",
    ]
  },
  "ts-interface实现接口": {
    "prefix": "ts-interface实现接口",
    "body": [
      "与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。",
      "",
      "interface ClockInterface {",
      "    currentTime: Date;",
      "}",
      "",
      "class Clock implements ClockInterface {",
      "    currentTime: Date;",
      "    constructor(h: number, m: number) { }",
      "}",
      "你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：",
      "",
      "interface ClockInterface {",
      "    currentTime: Date;",
      "    setTime(d: Date);",
      "}",
      "",
      "class Clock implements ClockInterface {",
      "    currentTime: Date;",
      "    setTime(d: Date) {",
      "        this.currentTime = d;",
      "    }",
      "    constructor(h: number, m: number) { }",
      "}",
      "接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。",
    ]
  },
  "ts-interface继承接口": {
    "prefix": "ts-interface继承接口",
    "body": [
      "和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。",
      "",
      "interface Shape {",
      "    color: string;",
      "}",
      "",
      "interface Square extends Shape {",
      "    sideLength: number;",
      "}",
      "",
      "let square = <Square>{};",
      "square.color = \"blue\";",
      "square.sideLength = 10;",
      "一个接口可以继承多个接口，创建出多个接口的合成接口。",
      "",
      "interface Shape {",
      "    color: string;",
      "}",
      "",
      "interface PenStroke {",
      "    penWidth: number;",
      "}",
      "",
      "interface Square extends Shape, PenStroke {",
      "    sideLength: number;",
      "}",
      "",
      "let square = <Square>{};",
      "square.color = \"blue\";",
      "square.sideLength = 10;",
      "square.penWidth = 5.0;",
    ]
  },
  "ts-interface混合类型": {
    "prefix": "ts-interface混合类型",
    "body": [
      "先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。",
      "",
      "一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。",
      "",
      "interface Counter {",
      "    (start: number): string;",
      "    interval: number;",
      "    reset(): void;",
      "}",
      "",
      "function getCounter(): Counter {",
      "    let counter = <Counter>function (start: number) { };",
      "    counter.interval = 123;",
      "    counter.reset = function () { };",
      "    return counter;",
      "}",
      "",
      "let c = getCounter();",
      "c(10);",
      "c.reset();",
      "c.interval = 5.0;",
      "在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。",
    ]
  },
  "ts-interface接口继承类": {
    "prefix": "ts-interface接口继承类",
    "body": [
      "当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。",
      "",
      "当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：",
      "",
      "class Control {",
      "    private state: any;",
      "}",
      "",
      "interface SelectableControl extends Control {",
      "    select(): void;",
      "}",
      "",
      "class Button extends Control implements SelectableControl {",
      "    select() { }",
      "}",
      "",
      "class TextBox extends Control {",
      "    select() { }",
      "}",
      "",
      "// 错误：“Image”类型缺少“state”属性。",
      "class Image implements SelectableControl {",
      "    select() { }",
      "}",
      "",
      "class Location {",
      "",
      "}",
      "在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。",
      "",
      "在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。",
    ]
  },
  "ts-class": {
    "prefix": "ts-class",
    "body": [
      "下面看一个使用类的例子：",
      "",
      "class Greeter {",
      "    greeting: string;",
      "    constructor(message: string) {",
      "        this.greeting = message;",
      "    }",
      "    greet() {",
      "        return \"Hello, \" + this.greeting;",
      "    }",
      "}",
      "",
      "let greeter = new Greeter(\"world\");",
      "如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。",
      "",
      "你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。",
      "",
      "最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它",
    ]
  },
  "ts-class继承": {
    "prefix": "ts-class继承",
    "body": [
      "在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。",
      "",
      "看下面的例子：",
      "",
      "class Animal {",
      "    move(distanceInMeters: number = 0) {",
      "        console.log(`Animal moved ${distanceInMeters}m.`);",
      "    }",
      "}",
      "",
      "class Dog extends Animal {",
      "    bark() {",
      "        console.log('Woof! Woof!');",
      "    }",
      "}",
      "",
      "const dog = new Dog();",
      "dog.bark();",
      "dog.move(10);",
      "dog.bark();",
      "这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。",
      "",
      "",
      " ",
      "因为 Dog继承了 Animal的功能，因此我们可以创建一个 Dog的实例，它能够 bark()和 move()。",
      "",
      "下面我们来看个更加复杂的例子。",
      "",
      "class Animal {",
      "    name: string;",
      "    constructor(theName: string) { this.name = theName; }",
      "    move(distanceInMeters: number = 0) {",
      "        console.log(`${this.name} moved ${distanceInMeters}m.`);",
      "    }",
      "}",
      "",
      "class Snake extends Animal {",
      "    constructor(name: string) { super(name); }",
      "    move(distanceInMeters = 5) {",
      "        console.log(\"Slithering...\");",
      "        super.move(distanceInMeters);",
      "    }",
      "}",
      "",
      "class Horse extends Animal {",
      "    constructor(name: string) { super(name); }",
      "    move(distanceInMeters = 45) {",
      "        console.log(\"Galloping...\");",
      "        super.move(distanceInMeters);",
      "    }",
      "}",
      "",
      "let sam = new Snake(\"Sammy the Python\");",
      "let tom: Animal = new Horse(\"Tommy the Palomino\");",
      "",
      "sam.move();",
      "tom.move(34);",
      "这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。",
      "",
      "",
      " ",
      "与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。",
      "",
      "这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：",
      "",
      "Slithering...",
      "Sammy the Python moved 5m.",
      "Galloping...",
      "Tommy the Palomino moved 34m.",
    ]
  },
  "ts-class默认为 public": {
    "prefix": "ts-class默认为 public",
    "body": [
      "在上面的例子里，我们可以自由的访问程序里定义的成员。 如果你对其它语言中的类比较了解，就会注意到我们在之前的代码里并没有使用 public来做修饰；例如，C#要求必须明确地使用 public指定成员是可见的。 在TypeScript里，成员都默认为 public。",
      "",
      "你也可以明确的将一个成员标记成 public。 我们可以用下面的方式来重写上面的 Animal类：",
      "",
      "class Animal {",
      "    public name: string;",
      "    public constructor(theName: string) { this.name = theName; }",
      "    public move(distanceInMeters: number) {",
      "        console.log(`${this.name} moved ${distanceInMeters}m.`);",
      "    }",
      "}",
    ]
  },
  "ts-class理解 private": {
    "prefix": "ts-class理解 private",
    "body": [
      "当成员被标记成 private时，它就不能在声明它的类的外部访问。比如：",
      "",
      "class Animal {",
      "    private name: string;",
      "    constructor(theName: string) { this.name = theName; }",
      "}",
      "",
      "new Animal(\"Cat\").name; // 错误: 'name' 是私有的.",
      "TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。",
      "",
      "",
      " ",
      "然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。",
      "",
      "下面来看一个例子，更好地说明了这一点：",
      "",
      "class Animal {",
      "    private name: string;",
      "    constructor(theName: string) { this.name = theName; }",
      "}",
      "",
      "class Rhino extends Animal {",
      "    constructor() { super(\"Rhino\"); }",
      "}",
      "",
      "class Employee {",
      "    private name: string;",
      "    constructor(theName: string) { this.name = theName; }",
      "}",
      "",
      "let animal = new Animal(\"Goat\");",
      "let rhino = new Rhino();",
      "let employee = new Employee(\"Bob\");",
      "",
      "animal = rhino;",
      "animal = employee; // 错误: Animal 与 Employee 不兼容.",
      "这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。",
    ]
  },
  "ts-class理解 protected": {
    "prefix": "ts-class理解 protected",
    "body": [
      "protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如：",
      "",
      "class Person {",
      "    protected name: string;",
      "    constructor(name: string) { this.name = name; }",
      "}",
      "",
      "class Employee extends Person {",
      "    private department: string;",
      "",
      "    constructor(name: string, department: string) {",
      "        super(name)",
      "        this.department = department;",
      "    }",
      "",
      "    public getElevatorPitch() {",
      "        return `Hello, my name is ${this.name} and I work in ${this.department}.`;",
      "    }",
      "}",
      "",
      "let howard = new Employee(\"Howard\", \"Sales\");",
      "console.log(howard.getElevatorPitch());",
      "console.log(howard.name); // 错误",
      "",
      " ",
      "注意，我们不能在 Person类外使用 name，但是我们仍然可以通过 Employee类的实例方法访问，因为 Employee是由 Person派生而来的。",
      "",
      "构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，",
      "",
      "class Person {",
      "    protected name: string;",
      "    protected constructor(theName: string) { this.name = theName; }",
      "}",
      "",
      "// Employee 能够继承 Person",
      "class Employee extends Person {",
      "    private department: string;",
      "",
      "    constructor(name: string, department: string) {",
      "        super(name);",
      "        this.department = department;",
      "    }",
      "",
      "    public getElevatorPitch() {",
      "        return `Hello, my name is ${this.name} and I work in ${this.department}.`;",
      "    }",
      "}",
      "",
      "let howard = new Employee(\"Howard\", \"Sales\");",
      "let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的.",
    ]
  },
  "ts-classreadonly修饰符": {
    "prefix": "ts-classreadonly修饰符",
    "body": [
      "你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。",
      "",
      "class Octopus {",
      "    readonly name: string;",
      "    readonly numberOfLegs: number = 8;",
      "    constructor (theName: string) {",
      "        this.name = theName;",
      "    }",
      "}",
      "let dad = new Octopus(\"Man with the 8 strong legs\");",
      "dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的.",
    ]
  },
  "ts-class参数属性": {
    "prefix": "ts-class参数属性",
    "body": [
      "在上面的例子中，我们必须在Octopus类里定义一个只读成员 name和一个参数为 theName的构造函数，并且立刻将 theName的值赋给 name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性：",
      "",
      "class Octopus {",
      "    readonly numberOfLegs: number = 8;",
      "    constructor(readonly name: string) {",
      "    }",
      "}",
      "",
      " ",
      "注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处。",
      "",
      "参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。",
    ]
  },
  "ts-class存取器": {
    "prefix": "ts-class存取器",
    "body": [
      "TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。",
      "",
      "下面来看如何把一个简单的类改写成使用 get和 set。 首先，我们从一个没有使用存取器的例子开始。",
      "",
      "class Employee {",
      "    fullName: string;",
      "}",
      "",
      "let employee = new Employee();",
      "employee.fullName = \"Bob Smith\";",
      "if (employee.fullName) {",
      "    console.log(employee.fullName);",
      "}",
      "我们可以随意的设置 fullName，这是非常方便的，但是这也可能会带来麻烦。",
      "",
      "下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。",
      "",
      "let passcode = \"secret passcode\";",
      "",
      "class Employee {",
      "    private _fullName: string;",
      "",
      "    get fullName(): string {",
      "        return this._fullName;",
      "    }",
      "",
      "    set fullName(newName: string) {",
      "        if (passcode && passcode == \"secret passcode\") {",
      "            this._fullName = newName;",
      "        }",
      "        else {",
      "            console.log(\"Error: Unauthorized update of employee!\");",
      "        }",
      "    }",
      "}",
      "",
      "let employee = new Employee();",
      "employee.fullName = \"Bob Smith\";",
      "if (employee.fullName) {",
      "    alert(employee.fullName);",
      "}",
      "我们可以修改一下密码，来验证一下存取器是否是工作的。当密码不对时，会提示我们没有权限去修改员工。",
      "",
      "对于存取器有下面几点需要注意的：",
      "",
      "首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。",
    ]
  },
  "ts-class静态属性": {
    "prefix": "ts-class静态属性",
    "body": [
      "到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。",
      "",
      "class Grid {",
      "    static origin = {x: 0, y: 0};",
      "    calculateDistanceFromOrigin(point: {x: number; y: number;}) {",
      "        let xDist = (point.x - Grid.origin.x);",
      "        let yDist = (point.y - Grid.origin.y);",
      "        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;",
      "    }",
      "    constructor (public scale: number) { }",
      "}",
      "",
      "let grid1 = new Grid(1.0);  // 1x scale",
      "let grid2 = new Grid(5.0);  // 5x scale",
      "",
      "console.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10}));",
      "console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10}));",
    ]
  },
  "ts-class抽象类": {
    "prefix": "ts-class抽象类",
    "body": [
      "抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。",
      "",
      "abstract class Animal {",
      "    abstract makeSound(): void;",
      "    move(): void {",
      "        console.log('roaming the earch...');",
      "    }",
      "}",
      "",
      " ",
      "抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。",
      "",
      "abstract class Department {",
      "",
      "    constructor(public name: string) {",
      "    }",
      "",
      "    printName(): void {",
      "        console.log('Department name: ' + this.name);",
      "    }",
      "",
      "    abstract printMeeting(): void; // 必须在派生类中实现",
      "}",
      "",
      "class AccountingDepartment extends Department {",
      "",
      "    constructor() {",
      "        super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super()",
      "    }",
      "",
      "    printMeeting(): void {",
      "        console.log('The Accounting Department meets each Monday at 10am.');",
      "    }",
      "",
      "    generateReports(): void {",
      "        console.log('Generating accounting reports...');",
      "    }",
      "}",
      "",
      "let department: Department; // 允许创建一个对抽象类型的引用",
      "department = new Department(); // 错误: 不能创建一个抽象类的实例",
      "department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值",
      "department.printName();",
      "department.printMeeting();",
      "department.generateReports(); // 错误: 方法在声明的抽象类中不存在",
    ]
  },
  "ts-class把类当做接口使用": {
    "prefix": "ts-class把类当做接口使用",
    "body": [
      "如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。",
      "",
      "class Point {",
      "    x: number;",
      "    y: number;",
      "}",
      "",
      "interface Point3d extends Point {",
      "    z: number;",
      "}",
      "",
      "let point3d: Point3d = {x: 1, y: 2, z: 3};",
    ]
  },
  "ts-函数-为函数定义类型": {
    "prefix": "ts-函数-为函数定义类型",
    "body": [
      "让我们为上面那个函数添加类型：",
      "",
      "function add(x: number, y: number): number {",
      "    return x + y;",
      "}",
      "",
      "let myAdd = function(x: number, y: number): number { return x + y; };",
      "我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。",
      "",
      "书写完整函数类型",
      "现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。",
      "",
      "let myAdd: (x: number, y: number) => number =",
      "    function(x: number, y: number): number { return x + y; };",
      "函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型。 这个名字只是为了增加可读性。 我们也可以这么写：",
      "",
      "let myAdd: (baseValue: number, increment: number) => number =",
      "    function(x: number, y: number): number { return x + y; };",
      "只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。",
      "",
      "第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用( =>)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。",
      "",
      "函数的类型只是由参数类型和返回值组成的。 函数中使用的捕获变量不会体现在类型里。 实际上，这些变量是函数的隐藏状态并不是组成API的一部分。",
    ]
  },
  "ts-函数推断类型": {
    "prefix": "ts-函数推断类型",
    "body": [
      "尝试这个例子的时候，你会发现如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：",
      "",
      "// myAdd has the full function type",
      "let myAdd = function(x: number, y: number): number { return x + y; };",
      "",
      "// The parameters `x` and `y` have the type number",
      "let myAdd: (baseValue: number, increment: number) => number =",
      "    function(x, y) { return x + y; };",
      "这叫做“按上下文归类”，是类型推论的一种。 它帮助我们更好地为程序指定类型。",
    ]
  },
  "ts-函数可选参数和默认参数": {
    "prefix": "ts-函数可选参数和默认参数",
    "body": [
      "TypeScript里的每个函数参数都是必须的。 这不是指不能传递 null或undefined作为参数，而是说编译器检查用户是否为每个参数都传入了值。 编译器还会假设只有这些参数会被传递进函数。 简短地说，传递给一个函数的参数个数必须与函数期望的参数个数一致。",
      "",
      "function buildName(firstName: string, lastName: string) {",
      "    return firstName + \" \" + lastName;",
      "}",
      "",
      "let result1 = buildName(\"Bob\");                  // error, too few parameters",
      "let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters",
      "let result3 = buildName(\"Bob\", \"Adams\");         // ah, just right",
      "JavaScript里，每个参数都是可选的，可传可不传。 没传参的时候，它的值就是undefined。 在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。 比如，我们想让last name是可选的：",
      "",
      "function buildName(firstName: string, lastName?: string) {",
      "    if (lastName)",
      "        return firstName + \" \" + lastName;",
      "    else",
      "        return firstName;",
      "}",
      "",
      "let result1 = buildName(\"Bob\");  // works correctly now",
      "let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters",
      "let result3 = buildName(\"Bob\", \"Adams\");  // ah, just right",
      "可选参数必须跟在必须参数后面。 如果上例我们想让first name是可选的，那么就必须调整它们的位置，把first name放在后面。",
      "",
      "在TypeScript里，我们也可以为参数提供一个默认值当用户没有传递这个参数或传递的值是undefined时。 它们叫做有默认初始化值的参数。 让我们修改上例，把last name的默认值设置为\"Smith\"。",
      "",
      "function buildName(firstName: string, lastName = \"Smith\") {",
      "    return firstName + \" \" + lastName;",
      "}",
      "",
      "let result1 = buildName(\"Bob\");                  // works correctly now, returns \"Bob Smith\"",
      "let result2 = buildName(\"Bob\", undefined);       // still works, also returns \"Bob Smith\"",
      "let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters",
      "let result4 = buildName(\"Bob\", \"Adams\");         // ah, just right",
      "在所有必须参数后面的带默认初始化的参数都是可选的，与可选参数一样，在调用函数的时候可以省略。 也就是说可选参数与末尾的默认参数共享参数类型。",
      "",
      "function buildName(firstName: string, lastName?: string) {",
      "    // ...",
      "}",
      "和",
      "",
      "function buildName(firstName: string, lastName = \"Smith\") {",
      "    // ...",
      "}",
      "共享同样的类型(firstName: string, lastName?: string) => string。 默认参数的默认值消失了，只保留了它是一个可选参数的信息。",
      "",
      "与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined值来获得默认值。 例如，我们重写最后一个例子，让 firstName是带默认值的参数：",
      "",
      "function buildName(firstName = \"Will\", lastName: string) {",
      "    return firstName + \" \" + lastName;",
      "}",
      "",
      "let result1 = buildName(\"Bob\");                  // error, too few parameters",
      "let result2 = buildName(\"Bob\", \"Adams\", \"Sr.\");  // error, too many parameters",
      "let result3 = buildName(\"Bob\", \"Adams\");         // okay and returns \"Bob Adams\"",
      "let result4 = buildName(undefined, \"Adams\");     // okay and returns \"Will Adams\"",
    ]
  },
  "ts-函数剩余参数": {
    "prefix": "ts-函数剩余参数",
    "body": [
      "必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。",
      "",
      "在TypeScript里，你可以把所有参数收集到一个变量里：",
      "",
      "function buildName(firstName: string, ...restOfName: string[]) {",
      "  return firstName + \" \" + restOfName.join(\" \");",
      "}",
      "",
      "let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\");",
      "剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ ...）后面给定的名字，你可以在函数体内使用这个数组。",
      "",
      "这个省略号也会在带有剩余参数的函数类型定义上使用到：",
      "",
      "function buildName(firstName: string, ...restOfName: string[]) {",
      "  return firstName + \" \" + restOfName.join(\" \");",
      "}",
      "",
      "let buildNameFun: (fname: string, ...rest: string[]) => string = buildName;",
    ]
  },
  "ts-函数this参数": {
    "prefix": "ts-函数this参数",
    "body": [
      "不幸的是，this.suits[pickedSuit]的类型依旧为any。 这是因为 this来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this参数。 this参数是个假的参数，它出现在参数列表的最前面：",
      "",
      "function f(this: void) {",
      "    // make sure `this` is unusable in this standalone function",
      "}",
      "让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些：",
      "",
      "interface Card {",
      "    suit: string;",
      "    card: number;",
      "}",
      "interface Deck {",
      "    suits: string[];",
      "    cards: number[];",
      "    createCardPicker(this: Deck): () => Card;",
      "}",
      "let deck: Deck = {",
      "    suits: [\"hearts\", \"spades\", \"clubs\", \"diamonds\"],",
      "    cards: Array(52),",
      "    // NOTE: The function now explicitly specifies that its callee must be of type Deck",
      "    createCardPicker: function(this: Deck) {",
      "        return () => {",
      "            let pickedCard = Math.floor(Math.random() * 52);",
      "            let pickedSuit = Math.floor(pickedCard / 13);",
      "",
      "            return {suit: this.suits[pickedSuit], card: pickedCard % 13};",
      "        }",
      "    }",
      "}",
      "",
      "let cardPicker = deck.createCardPicker();",
      "let pickedCard = cardPicker();",
      "",
      "alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit);",
      "现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此--noImplicitThis不会报错了。",
      "",
      "this参数在回调函数里",
      "你可以也看到过在回调函数里的this报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， this将为undefined。 稍做改动，你就可以通过 this参数来避免错误。 首先，库函数的作者要指定 this的类型：",
      "",
      "interface UIElement {",
      "    addClickListener(onclick: (this: void, e: Event) => void): void;",
      "}",
      "this: void means that addClickListener expects onclick to be a function that does not require a this type. Second, annotate your calling code with this:",
      "",
      "class Handler {",
      "    info: string;",
      "    onClickBad(this: Handler, e: Event) {",
      "        // oops, used this here. using this callback would crash at runtime",
      "        this.info = e.message;",
      "    }",
      "}",
      "let h = new Handler();",
      "uiElement.addClickListener(h.onClickBad); // error!",
      "指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到 addClickListener要求函数带有this: void。 改变 this类型来修复这个错误：",
      "",
      "class Handler {",
      "    info: string;",
      "    onClickGood(this: void, e: Event) {",
      "        // can't use this here because it's of type void!",
      "        console.log('clicked!');",
      "    }",
      "}",
      "let h = new Handler();",
      "uiElement.addClickListener(h.onClickGood);",
      "因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用 this.info. 如果你两者都想要，你不得不使用箭头函数了：",
      "",
      "class Handler {",
      "    info: string;",
      "    onClickGood = (e: Event) => { this.info = e.message }",
      "}",
      "这是可行的因为箭头函数不会捕获this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个 Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 Handler的原型链上。 它们在不同 Handler对象间是共享的。",
    ]
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  },
  "ts-": {
    "prefix": "ts-",
    "body": []
  }
}