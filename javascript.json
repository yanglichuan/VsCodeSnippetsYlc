{
  "js-let1": {
    "prefix": "js-let1",
    "body": [
      "or循环的计数器，就很合适使用let命令。",
      "",
      "for (let i = 0; i < 10; i++) {",
      "  // ...",
      "}",
      "",
      "console.log(i);",
      "// ReferenceError: i is not defined"
    ]
  },

  "js-数组的扩展": {
    "prefix": "js-数组的扩展",
    "body": [
      "扩展运算符",
      "Array.from()",
      "Array.of()",
      "数组实例的 copyWithin()",
      "数组实例的 find() 和 findIndex()",
      "数组实例的 fill()",
      "数组实例的 entries()，keys() 和 values()",
      "数组实例的 includes()",
      "数组实例的 flat()，flatMap()",
      "数组的空位",
      "Array.prototype.sort() 的排序稳定性"
    ]
  },
  "js-扩展运算符（spread）": {
    "prefix": "js-扩展运算符（spread）",
    "body": [
      "扩展运算符（spread）是三个点（...）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。",
      "",
      "console.log(...[1, 2, 3])",
      "// 1 2 3",
      "",
      "console.log(1, ...[2, 3, 4], 5)",
      "// 1 2 3 4 5",
      "",
      "[...document.querySelectorAll('div')]",
      "// [<div>, <div>, <div>]"
    ]
  },
  "js-spread替代函数的 apply 方法 ": {
    "prefix": "js-js-spread替代函数的 apply 方法 ",
    "body": [
      "由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。",
      "",
      "// ES5 的写法",
      "function f(x, y, z) {",
      "  // ...",
      "}",
      "var args = [0, 1, 2];",
      "f.apply(null, args);",
      "",
      "// ES6的写法",
      "function f(x, y, z) {",
      "  // ...",
      "}",
      "let args = [0, 1, 2];",
      "f(...args);",
      "",
      "下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。",
      "",
      "// ES5 的写法",
      "Math.max.apply(null, [14, 3, 77])",
      "",
      "// ES6 的写法",
      "Math.max(...[14, 3, 77])",
      "",
      "// 等同于",
      "Math.max(14, 3, 77);",
      "// ES5的 写法",
      "var arr1 = [0, 1, 2];",
      "var arr2 = [3, 4, 5];",
      "Array.prototype.push.apply(arr1, arr2);",
      "",
      "// ES6 的写法",
      "let arr1 = [0, 1, 2];",
      "let arr2 = [3, 4, 5];",
      "arr1.push(...arr2);",
      "// ES5",
      "new (Date.bind.apply(Date, [null, 2015, 1, 1]))",
      "// ES6",
      "new Date(...[2015, 1, 1]);"
    ]
  },
  "js-spread扩展运算符提供了复制数组": {
    "prefix": "js-spread扩展运算符提供了复制数组",
    "body": [
      "ES5 只能用变通方法来复制数组。",
      "",
      "const a1 = [1, 2];",
      "const a2 = a1.concat();",
      "",
      "a2[0] = 2;",
      "a1 // [1, 2]",
      "上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。",
      "",
      "扩展运算符提供了复制数组的简便写法。",
      "",
      "const a1 = [1, 2];",
      "// 写法一",
      "const a2 = [...a1];",
      "// 写法二",
      "const [...a2] = a1;"
    ]
  },
  "js-spread合并数组": {
    "prefix": "js-spread合并数组",
    "body": [
      "扩展运算符提供了数组合并的新写法。",
      "",
      "const arr1 = ['a', 'b'];",
      "const arr2 = ['c'];",
      "const arr3 = ['d', 'e'];",
      "",
      "// ES5 的合并数组",
      "arr1.concat(arr2, arr3);",
      "// [ 'a', 'b', 'c', 'd', 'e' ]",
      "",
      "// ES6 的合并数组",
      "[...arr1, ...arr2, ...arr3]",
      "// [ 'a', 'b', 'c', 'd', 'e' ]",
      "不过，这两种方法都是浅拷贝，使用的时候需要注意。"
    ]
  },
  "js-spread与解构赋值结合": {
    "prefix": "js-spread与解构赋值结合",
    "body": [
      "扩展运算符可以与解构赋值结合起来，用于生成数组。",
      "",
      "// ES5",
      "a = list[0], rest = list.slice(1)",
      "// ES6",
      "[a, ...rest] = list",
      "下面是另外一些例子。",
      "",
      "const [first, ...rest] = [1, 2, 3, 4, 5];",
      "first // 1",
      "rest  // [2, 3, 4, 5]",
      "",
      "const [first, ...rest] = [];",
      "first // undefined",
      "rest  // []",
      "",
      "const [first, ...rest] = [\"foo\"];",
      "first  // \"foo\"",
      "rest   // []",
      "如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。",
      "",
      "const [...butLast, last] = [1, 2, 3, 4, 5];",
      "// 报错",
      "",
      "const [first, ...middle, last] = [1, 2, 3, 4, 5];",
      "// 报错"
    ]
  },
  "js-spread字符串": {
    "prefix": "js-spread字符串",
    "body": [
      "扩展运算符还可以将字符串转为真正的数组。",
      "",
      "[...'hello']",
      "// [ \"h\", \"e\", \"l\", \"l\", \"o\" ]"
    ]
  },
  "js-Array.from": {
    "prefix": "js-Array.from",
    "body": [
      "Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。",
      "",
      "下面是一个类似数组的对象，Array.from将它转为真正的数组。",
      "",
      "let arrayLike = {",
      "    '0': 'a',",
      "    '1': 'b',",
      "    '2': 'c',",
      "    length: 3",
      "};",
      "",
      "// ES5的写法",
      "var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']",
      "",
      "// ES6的写法",
      "let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']",
      "实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。",
      "",
      "// NodeList对象",
      "let ps = document.querySelectorAll('p');",
      "Array.from(ps).filter(p => {",
      "  return p.textContent.length > 100;",
      "});",
      "",
      "// arguments对象",
      "function foo() {",
      "  var args = Array.from(arguments);",
      "  // ...",
      "}"
    ]
  },
  "js-Array.of()": {
    "prefix": "js-Array.of()",
    "body": [
      "Array.of方法用于将一组值，转换为数组。",
      "",
      "Array.of(3, 11, 8) // [3,11,8]",
      "Array.of(3) // [3]",
      "Array.of(3).length // 1",
      "这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。",
      "",
      "Array() // []",
      "Array(3) // [, , ,]",
      "Array(3, 11, 8) // [3, 11, 8]",
      "上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。"
    ]
  },
  "js-flat": {
    "prefix": "js-flat",
    "body": [
      "数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。",
      "",
      "[1, 2, [3, 4]].flat()",
      "// [1, 2, 3, 4]",
      "上面代码中，原数组的成员里面有一个数组，flat()方法将子数组的成员取出来，添加在原来的位置。",
      "",
      "flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。",
      "",
      "[1, 2, [3, [4, 5]]].flat()",
      "// [1, 2, 3, [4, 5]]",
      "",
      "[1, 2, [3, [4, 5]]].flat(2)",
      "// [1, 2, 3, 4, 5]",
      "上面代码中，flat()的参数为2，表示要“拉平”两层的嵌套数组。"
    ]
  },
  "js-join": {
    "prefix": "js-join",
    "body": [
      "// forEach方法",
      "[,'a'].forEach((x,i) => console.log(i)); // 1",
      "",
      "// filter方法",
      "['a',,'b'].filter(x => true) // ['a','b']",
      "",
      "// every方法",
      "[,'a'].every(x => x==='a') // true",
      "",
      "// reduce方法",
      "[1,,2].reduce((x,y) => x+y) // 3",
      "",
      "// some方法",
      "[,'a'].some(x => x !== 'a') // false",
      "",
      "// map方法",
      "[,'a'].map(x => 1) // [,1]",
      "",
      "// join方法",
      "[,'a',undefined,null].join('#') // \"#a##\"",
      "",
      "// toString方法",
      "[,'a',undefined,null].toString() // \",a,,\""
    ]
  },
  "js-对象的扩展": {
    "prefix": "js-对象的扩展",
    "body": [
      "属性的简洁表示法",
      "属性名表达式",
      "方法的 name 属性",
      "属性的可枚举性和遍历",
      "super 关键字",
      "对象的扩展运算符",
      "链判断运算符",
      "Null 判断运算符"
    ]
  },
  "js-属性的简洁表示法": {
    "prefix": "js-属性的简洁表示法",
    "body": [
      "S6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。",
      "",
      "const foo = 'bar';",
      "const baz = {foo};",
      "baz // {foo: \"bar\"}",
      "",
      "// 等同于",
      "const baz = {foo: foo};",
      "上面代码中，变量foo直接写在大括号里面。这时，属性名就是变量名, 属性值就是变量值。下面是另一个例子。",
      "",
      "function f(x, y) {",
      "  return {x, y};",
      "}",
      "",
      "// 等同于",
      "",
      "function f(x, y) {",
      "  return {x: x, y: y};",
      "}",
      "",
      "f(1, 2) // Object {x: 1, y: 2}"
    ]
  },
  "js-除了属性简写，方法也可以简写": {
    "prefix": "js-除了属性简写，方法也可以简写",
    "body": [
      "除了属性简写，方法也可以简写。",
      "",
      "const o = {",
      "  method() {",
      "    return \"Hello!\";",
      "  }",
      "};",
      "",
      "// 等同于",
      "",
      "const o = {",
      "  method: function() {",
      "    return \"Hello!\";",
      "  }",
      "};",
      "下面是一个实际的例子。",
      "",
      "let birth = '2000/01/01';",
      "",
      "const Person = {",
      "",
      "  name: '张三',",
      "",
      "  //等同于birth: birth",
      "  birth,",
      "",
      "  // 等同于hello: function ()...",
      "  hello() { console.log('我的名字是', this.name); }",
      "",
      "};"
    ]
  },
  "js-属性名表达式": {
    "prefix": "js-属性名表达式",
    "body": [
      "JavaScript 定义对象的属性，有两种方法。",
      "",
      "// 方法一",
      "obj.foo = true;",
      "",
      "// 方法二",
      "obj['a' + 'bc'] = 123;",
      "上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。",
      "",
      "但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。",
      "",
      "var obj = {",
      "  foo: true,",
      "  abc: 123",
      "};",
      "ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。",
      "",
      "let propKey = 'foo';",
      "",
      "let obj = {",
      "  [propKey]: true,",
      "  ['a' + 'bc']: 123",
      "};",
      "下面是另一个例子。",
      "",
      "let lastWord = 'last word';",
      "",
      "const a = {",
      "  'first word': 'hello',",
      "  [lastWord]: 'world'",
      "};",
      "",
      "a['first word'] // \"hello\"",
      "a[lastWord] // \"world\"",
      "a['last word'] // \"world\""
    ]
  },
  "js-链判断运算符": {
    "prefix": "js-链判断运算符",
    "body": [
      "下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。",
      "",
      "a?.b",
      "// 等同于",
      "a == null ? undefined : a.b",
      "",
      "a?.[x]",
      "// 等同于",
      "a == null ? undefined : a[x]",
      "",
      "a?.b()",
      "// 等同于",
      "a == null ? undefined : a.b()",
      "",
      "a?.()",
      "// 等同于",
      "a == null ? undefined : a()",
      "上面代码中，特别注意后两种形式，如果a?.b()里面的a.b不是函数，不可调用，那么a?.b()是会报错的。a?.()也是如此，如果a不是null或undefined，但也不是函数，那么a?.()会报错。"
    ]
  },
  "js-对象的新增方法": {
    "prefix": "js-对象的新增方法",
    "body": [
      "Object.is()",
      "Object.assign()",
      "Object.getOwnPropertyDescriptors()",
      "__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()",
      "Object.keys()，Object.values()，Object.entries()",
      "Object.fromEntries()"
    ]
  },
  "js-Object.is1": {
    "prefix": "js-Object.is1",
    "body": [
      "ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。",
      "",
      "Object.is('foo', 'foo')",
      "// true",
      "Object.is({}, {})",
      "// false",
      "不同之处只有两个：一是+0不等于-0，二是NaN等于自身。",
      "",
      "+0 === -0 //true",
      "NaN === NaN // false",
      "",
      "Object.is(+0, -0) // false",
      "Object.is(NaN, NaN) // true",
      "ES5 可以通过下面的代码，部署Object.is。",
      "",
      "Object.defineProperty(Object, 'is', {",
      "  value: function(x, y) {",
      "    if (x === y) {",
      "      // 针对+0 不等于 -0的情况",
      "      return x !== 0 || 1 / x === 1 / y;",
      "    }",
      "    // 针对NaN的情况",
      "    return x !== x && y !== y;",
      "  },",
      "  configurable: true,",
      "  enumerable: false,",
      "  writable: true",
      "});"
    ]
  },
  "js-Object.assign2": {
    "prefix": "js-Object.assign2",
    "body": [
      "Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。",
      "",
      "const target = { a: 1 };",
      "",
      "const source1 = { b: 2 };",
      "const source2 = { c: 3 };",
      "",
      "Object.assign(target, source1, source2);",
      "target // {a:1, b:2, c:3}",
      "Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。",
      "",
      "注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。",
      "",
      "const target = { a: 1, b: 1 };",
      "",
      "const source1 = { b: 2, c: 2 };",
      "const source2 = { c: 3 };",
      "",
      "Object.assign(target, source1, source2);",
      "target // {a:1, b:2, c:3}",
      "如果只有一个参数，Object.assign会直接返回该参数。",
      "",
      "const obj = {a: 1};",
      "Object.assign(obj) === obj // true",
      "如果该参数不是对象，则会先转成对象，然后返回。",
      "",
      "typeof Object.assign(2) // \"object\"",
      "由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。",
      "",
      "Object.assign(undefined) // 报错",
      "Object.assign(null) // 报错",
      "如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。",
      "",
      "let obj = {a: 1};",
      "Object.assign(obj, undefined) === obj // true",
      "Object.assign(obj, null) === obj // true",
      "其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。",
      "",
      "const v1 = 'abc';",
      "const v2 = true;",
      "const v3 = 10;",
      "",
      "const obj = Object.assign({}, v1, v2, v3);",
      "console.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }",
      "上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。",
      "",
      "Object(true) // {[[PrimitiveValue]]: true}",
      "Object(10)  //  {[[PrimitiveValue]]: 10}",
      "Object('abc') // {0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"}",
      "上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。"
    ]
  },
  "js-Object.assign方法有很多用处": {
    "prefix": "js-Object.assign方法有很多用处",
    "body": [
      "常见用途",
      "Object.assign方法有很多用处。",
      "",
      "（1）为对象添加属性",
      "",
      "class Point {",
      "  constructor(x, y) {",
      "    Object.assign(this, {x, y});",
      "  }",
      "}",
      "上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。",
      "",
      "（2）为对象添加方法",
      "",
      "Object.assign(SomeClass.prototype, {",
      "  someMethod(arg1, arg2) {",
      "    ···",
      "  },",
      "  anotherMethod() {",
      "    ···",
      "  }",
      "});",
      "",
      "// 等同于下面的写法",
      "SomeClass.prototype.someMethod = function (arg1, arg2) {",
      "  ···",
      "};",
      "SomeClass.prototype.anotherMethod = function () {",
      "  ···",
      "};",
      "上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。",
      "",
      "（3）克隆对象",
      "",
      "function clone(origin) {",
      "  return Object.assign({}, origin);",
      "}",
      "上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。",
      "",
      "不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。",
      "",
      "function clone(origin) {",
      "  let originProto = Object.getPrototypeOf(origin);",
      "  return Object.assign(Object.create(originProto), origin);",
      "}",
      "（4）合并多个对象",
      "",
      "将多个对象合并到某个对象。",
      "",
      "const merge =",
      "  (target, ...sources) => Object.assign(target, ...sources);",
      "如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。",
      "",
      "const merge =",
      "  (...sources) => Object.assign({}, ...sources);",
      "（5）为属性指定默认值",
      "",
      "const DEFAULTS = {",
      "  logLevel: 0,",
      "  outputFormat: 'html'",
      "};",
      "",
      "function processContent(options) {",
      "  options = Object.assign({}, DEFAULTS, options);",
      "  console.log(options);",
      "  // ...",
      "}",
      "上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则options的属性值会覆盖DEFAULTS的属性值。",
      "",
      "注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。",
      "",
      "const DEFAULTS = {",
      "  url: {",
      "    host: 'example.com',",
      "    port: 7070",
      "  },",
      "};",
      "",
      "processContent({ url: {port: 8000} })",
      "// {",
      "//   url: {port: 8000}",
      "// }",
      "上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了"
    ]
  },
  "js-Object.getPrototypeOf": {
    "prefix": "js-Object.getPrototypeOf",
    "body": [
      "该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。",
      "",
      "Object.getPrototypeOf(obj);",
      "下面是一个例子。",
      "",
      "function Rectangle() {",
      "  // ...",
      "}",
      "",
      "const rec = new Rectangle();",
      "",
      "Object.getPrototypeOf(rec) === Rectangle.prototype",
      "// true",
      "",
      "Object.setPrototypeOf(rec, Object.prototype);",
      "Object.getPrototypeOf(rec) === Rectangle.prototype",
      "// false",
      "如果参数不是对象，会被自动转为对象。",
      "",
      "// 等同于 Object.getPrototypeOf(Number(1))",
      "Object.getPrototypeOf(1)",
      "// Number {[[PrimitiveValue]]: 0}",
      "",
      "// 等同于 Object.getPrototypeOf(String('foo'))",
      "Object.getPrototypeOf('foo')",
      "// String {length: 0, [[PrimitiveValue]]: \"\"}",
      "",
      "// 等同于 Object.getPrototypeOf(Boolean(true))",
      "Object.getPrototypeOf(true)",
      "// Boolean {[[PrimitiveValue]]: false}",
      "",
      "Object.getPrototypeOf(1) === Number.prototype // true",
      "Object.getPrototypeOf('foo') === String.prototype // true",
      "Object.getPrototypeOf(true) === Boolean.prototype // true",
      "如果参数是undefined或null，它们无法转为对象，所以会报错。",
      "",
      "Object.getPrototypeOf(null)",
      "// TypeError: Cannot convert undefined or null to object",
      "",
      "Object.getPrototypeOf(undefined)",
      "// TypeError: Cannot convert undefined or null to object"
    ]
  },
  "js-set": {
    "prefix": "js-set2",
    "body": [
      "Set函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。",
      "",
      "// 例一",
      "const set = new Set([1, 2, 3, 4, 4]);",
      "[...set]",
      "// [1, 2, 3, 4]",
      "",
      "// 例二",
      "const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);",
      "items.size // 5",
      "",
      "// 例三",
      "const set = new Set(document.querySelectorAll('div'));",
      "set.size // 56",
      "",
      "// 类似于",
      "const set = new Set();",
      "document",
      " .querySelectorAll('div')",
      " .forEach(div => set.add(div));",
      "set.size // 56",
      "上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。",
      "s.add(1).add(2).add(2);",
      "// 注意2被加入了两次",
      "",
      "s.size // 2",
      "",
      "s.has(1) // true",
      "s.has(2) // true",
      "s.has(3) // false",
      "",
      "s.delete(2);",
      "s.has(2) // false"
    ]
  },
  "js-Array.from方法可以将 Set 结构转为数组": {
    "prefix": "js-Array.from方法可以将 Set 结构转为数组",
    "body": [
      "Array.from方法可以将 Set 结构转为数组。",
      "",
      "const items = new Set([1, 2, 3, 4, 5]);",
      "const array = Array.from(items);",
      "这就提供了去除数组重复成员的另一种方法。",
      "",
      "function dedupe(array) {",
      "  return Array.from(new Set(array));",
      "}",
      "",
      "dedupe([1, 1, 2, 3]) // [1, 2, 3]"
    ]
  },
  "js-set2": {
    "prefix": "js-set3",
    "body": [
      "keys()，values()，entries()",
      "",
      "keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。",
      "",
      "let set = new Set(['red', 'green', 'blue']);",
      "",
      "for (let item of set.keys()) {",
      "  console.log(item);",
      "}",
      "// red",
      "// green",
      "// blue",
      "",
      "for (let item of set.values()) {",
      "  console.log(item);",
      "}",
      "// red",
      "// green",
      "// blue",
      "",
      "for (let item of set.entries()) {",
      "  console.log(item);",
      "}",
      "// [\"red\", \"red\"]",
      "// [\"green\", \"green\"]",
      "// [\"blue\", \"blue\"]",
      "上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。",
      "",
      "Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。",
      "",
      "Set.prototype[Symbol.iterator] === Set.prototype.values",
      "// true",
      "这意味着，可以省略values方法，直接用for...of循环遍历 Set。",
      "",
      "let set = new Set(['red', 'green', 'blue']);",
      "",
      "for (let x of set) {",
      "  console.log(x);",
      "}",
      "// red",
      "// green",
      "// blue",
      "（2）forEach()",
      "",
      "Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。",
      "",
      "let set = new Set([1, 4, 9]);",
      "set.forEach((value, key) => console.log(key + ' : ' + value))",
      "// 1 : 1",
      "// 4 : 4",
      "// 9 : 9",
      "上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数与数组的forEach一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。",
      "",
      "另外，forEach方法还可以有第二个参数，表示绑定处理函数内部的this对象。",
      "",
      "（3）遍历的应用",
      "",
      "扩展运算符（...）内部使用for...of循环，所以也可以用于 Set 结构。",
      "",
      "let set = new Set(['red', 'green', 'blue']);",
      "let arr = [...set];",
      "// ['red', 'green', 'blue']",
      "扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。",
      "",
      "let arr = [3, 5, 2, 2, 5, 5];",
      "let unique = [...new Set(arr)];",
      "// [3, 5, 2]",
      "而且，数组的map和filter方法也可以间接用于 Set 了。",
      "",
      "let set = new Set([1, 2, 3]);",
      "set = new Set([...set].map(x => x * 2));",
      "// 返回Set结构：{2, 4, 6}",
      "",
      "let set = new Set([1, 2, 3, 4, 5]);",
      "set = new Set([...set].filter(x => (x % 2) == 0));",
      "// 返回Set结构：{2, 4}",
      "因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。",
      "",
      "let a = new Set([1, 2, 3]);",
      "let b = new Set([4, 3, 2]);",
      "",
      "// 并集",
      "let union = new Set([...a, ...b]);",
      "// Set {1, 2, 3, 4}",
      "",
      "// 交集",
      "let intersect = new Set([...a].filter(x => b.has(x)));",
      "// set {2, 3}",
      "",
      "// （a 相对于 b 的）差集",
      "let difference = new Set([...a].filter(x => !b.has(x)));",
      "// Set {1}",
      "如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用Array.from方法。",
      "",
      "// 方法一",
      "let set = new Set([1, 2, 3]);",
      "set = new Set([...set].map(val => val * 2));",
      "// set的值是2, 4, 6",
      "",
      "// 方法二",
      "let set = new Set([1, 2, 3]);",
      "set = new Set(Array.from(set, val => val * 2));",
      "// set的值是2, 4, 6"
    ]
  },
  "js-WeakSet": {
    "prefix": "js-WeakSet",
    "body": [
      "const ws = new WeakSet();",
      "ws.add(1)",
      "// TypeError: Invalid value used in weak set",
      "ws.add(Symbol())",
      "// TypeError: invalid value used in weak set",
      "const ws = new WeakSet();",
      "const obj = {};",
      "const foo = {};",
      "",
      "ws.add(window);",
      "ws.add(obj);",
      "",
      "ws.has(window); // true",
      "ws.has(foo);    // false",
      "",
      "ws.delete(window);",
      "ws.has(window);    // false"
    ]
  },
  "js-Map2": {
    "prefix": "js-Map2",
    "body": [
      "const map = new Map([",
      "  ['name', '张三'],",
      "  ['title', 'Author']",
      "]);",
      "",
      "map.size // 2",
      "map.has('name') // true",
      "map.get('name') // \"张三\"",
      "map.has('title') // true",
      "map.get('title') // \"Author\"",
      "上面代码在新建 Map 实例时，就指定了两个键name和title。",
      "",
      "Map构造函数接受数组作为参数，实际上执行的是下面的算法。",
      "",
      "const items = [",
      "  ['name', '张三'],",
      "  ['title', 'Author']",
      "];",
      "",
      "const map = new Map();",
      "",
      "items.forEach(",
      "  ([key, value]) => map.set(key, value)",
      ");",
      "事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作Map构造函数的参数。这就是说，Set和Map都可以用来生成新的 Map。",
      "",
      "const set = new Set([",
      "  ['foo', 1],",
      "  ['bar', 2]",
      "]);",
      "const m1 = new Map(set);",
      "m1.get('foo') // 1",
      "",
      "const m2 = new Map([['baz', 3]]);",
      "const m3 = new Map(m2);",
      "m3.get('baz') // 3",
      "上面代码中，我们分别使用 Set 对象和 Map 对象，当作Map构造函数的参数，结果都生成了新的 Map 对象。",
      "",
      "如果对同一个键多次赋值，后面的值将覆盖前面的值。",
      "",
      "const map = new Map();",
      "",
      "map",
      ".set(1, 'aaa')",
      ".set(1, 'bbb');",
      "",
      "map.get(1) // \"bbb\"",
      "上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。",
      "",
      "如果读取一个未知的键，则返回undefined。",
      "",
      "new Map().get('asfddfsasadf')",
      "// undefined",
      "注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。",
      "",
      "const map = new Map();",
      "",
      "map.set(['a'], 555);",
      "map.get(['a']) // undefined",
      "上面代码的set和get方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此get方法无法读取该键，返回undefined。",
      "",
      "同理，同样的值的两个实例，在 Map 结构中被视为两个键。",
      "",
      "const map = new Map();",
      "",
      "const k1 = ['a'];",
      "const k2 = ['a'];",
      "",
      "map",
      ".set(k1, 111)",
      ".set(k2, 222);",
      "",
      "map.get(k1) // 111",
      "map.get(k2) // 222",
      "上面代码中，变量k1和k2的值是一样的，但是它们在 Map 结构中被视为两个键。",
      "",
      "由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。",
      "",
      "如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如0和-0就是一个键，布尔值true和字符串true则是两个不同的键。另外，undefined和null也是两个不同的键。虽然NaN不严格相等于自身，但 Map 将其视为同一个键。",
      "",
      "let map = new Map();",
      "",
      "map.set(-0, 123);",
      "map.get(+0) // 123",
      "",
      "map.set(true, 1);",
      "map.set('true', 2);",
      "map.get(true) // 1",
      "",
      "map.set(undefined, 3);",
      "map.set(null, 4);",
      "map.get(undefined) // 3",
      "",
      "map.set(NaN, 123);",
      "map.get(NaN) // 123",
      "实例的属性和操作方"
    ]
  },
  "js-对象转为 Map": {
    "prefix": "js-对象转为 Map",
    "body": [
      "对象转为 Map",
      "",
      "对象转为 Map 可以通过Object.entries()。",
      "",
      "let obj = {\"a\":1, \"b\":2};",
      "let map = new Map(Object.entries(obj));",
      "此外，也可以自己实现一个转换函数。",
      "",
      "function objToStrMap(obj) {",
      "  let strMap = new Map();",
      "  for (let k of Object.keys(obj)) {",
      "    strMap.set(k, obj[k]);",
      "  }",
      "  return strMap;",
      "}",
      "",
      "objToStrMap({yes: true, no: false})",
      "// Map {\"yes\" => true, \"no\" => false}"
    ]
  },
  "js-Promise.race": {
    "prefix": "js-Promise.race",
    "body": [
      "Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。",
      "",
      "const p = Promise.race([p1, p2, p3]);",
      "上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。",
      "",
      "Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。",
      "",
      "下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。",
      "",
      "const p = Promise.race([",
      "  fetch('/resource-that-may-take-a-while'),",
      "  new Promise(function (resolve, reject) {",
      "    setTimeout(() => reject(new Error('request timeout')), 5000)",
      "  })",
      "]);",
      "",
      "p",
      ".then(console.log)",
      ".catch(console.error);",
      "上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数"
    ]
  },
  "js-Promise.any": {
    "prefix": "js-Promise.any",
    "body": [
      "Promise.any()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。该方法目前是一个第三阶段的提案 。",
      "",
      "Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。",
      "",
      "const promises = [",
      "  fetch('/endpoint-a').then(() => 'a'),",
      "  fetch('/endpoint-b').then(() => 'b'),",
      "  fetch('/endpoint-c').then(() => 'c'),",
      "];",
      "try {",
      "  const first = await Promise.any(promises);",
      "  console.log(first);",
      "} catch (error) {",
      "  console.log(error);",
      "}",
      "上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。",
      "",
      "Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。",
      "",
      "new AggregateError() extends Array -> AggregateError",
      "",
      "const err = new AggregateError();",
      "err.push(new Error(\"first error\"));",
      "err.push(new Error(\"second error\"));",
      "throw err;",
      "捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。",
      "",
      "Promise.any(promises).then(",
      "  (first) => {",
      "    // Any of the promises was fulfilled.",
      "  },",
      "  (error) => {",
      "    // All of the promises were rejected.",
      "  }",
      ");",
      "下面是一个例子。",
      "",
      "var resolved = Promise.resolve(42);",
      "var rejected = Promise.reject(-1);",
      "var alsoRejected = Promise.reject(Infinity);",
      "",
      "Promise.any([resolved, rejected, alsoRejected]).then(function (result) {",
      "  console.log(result); // 42",
      "});",
      "",
      "Promise.any([rejected, alsoRejected]).catch(function (results) {",
      "  console.log(results); // [-1, Infinity]",
      "});"
    ]
  },
  "js-Promise.resolve": {
    "prefix": "js-Promise.resolve",
    "body": [
      "有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。",
      "",
      "const jsPromise = Promise.resolve($.ajax('/whatever.json'));",
      "上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。",
      "",
      "Promise.resolve()等价于下面的写法。",
      "",
      "Promise.resolve('foo')",
      "// 等价于",
      "new Promise(resolve => resolve('foo'))",
      "Promise.resolve方法的参数分成四种情况",
      "Promise.resolve方法的参数分成四种情况。",
      "",
      "（1）参数是一个 Promise 实例",
      "",
      "如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。",
      "",
      "（2）参数是一个thenable对象",
      "",
      "thenable对象指的是具有then方法的对象，比如下面这个对象。",
      "",
      "let thenable = {",
      "  then: function(resolve, reject) {",
      "    resolve(42);",
      "  }",
      "};",
      "Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。",
      "",
      "let thenable = {",
      "  then: function(resolve, reject) {",
      "    resolve(42);",
      "  }",
      "};",
      "",
      "let p1 = Promise.resolve(thenable);",
      "p1.then(function(value) {",
      "  console.log(value);  // 42",
      "});",
      "上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出 42。",
      "",
      "（3）参数不是具有then方法的对象，或根本就不是对象",
      "",
      "如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的 Promise 对象，状态为resolved。",
      "",
      "const p = Promise.resolve('Hello');",
      "",
      "p.then(function (s){",
      "  console.log(s)",
      "});",
      "// Hello",
      "上面代码生成一个新的 Promise 对象的实例p。由于字符串Hello不属于异步操作（判断方法是字符串对象不具有 then 方法），返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。",
      "",
      "（4）不带有任何参数",
      "",
      "Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。",
      "",
      "所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。",
      "",
      "const p = Promise.resolve();",
      "",
      "p.then(function () {",
      "  // ...",
      "});",
      "上面代码的变量p就是一个 Promise 对象。",
      "",
      "需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时。",
      "",
      "setTimeout(function () {",
      "  console.log('three');",
      "}, 0);",
      "",
      "Promise.resolve().then(function () {",
      "  console.log('two');",
      "});",
      "",
      "console.log('one');",
      "",
      "// one",
      "// two",
      "// three",
      "上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。"
    ]
  },
  "js-Promise.reject": {
    "prefix": "js-Promise.reject",
    "body": [
      "Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。",
      "",
      "const p = Promise.reject('出错了');",
      "// 等同于",
      "const p = new Promise((resolve, reject) => reject('出错了'))",
      "",
      "p.then(null, function (s) {",
      "  console.log(s)",
      "});",
      "// 出错了",
      "上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。",
      "",
      "注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。",
      "",
      "const thenable = {",
      "  then(resolve, reject) {",
      "    reject('出错了');",
      "  }",
      "};",
      "",
      "Promise.reject(thenable)",
      ".catch(e => {",
      "  console.log(e === thenable)",
      "})",
      "// true",
      "上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象"
    ]
  },
  "js-async": {
    "prefix": "js-async3",
    "body": [
      "async 函数有多种使用形式。",
      "",
      "// 函数声明",
      "async function foo() {}",
      "",
      "// 函数表达式",
      "const foo = async function () {};",
      "",
      "// 对象的方法",
      "let obj = { async foo() {} };",
      "obj.foo().then(...)",
      "",
      "// Class 的方法",
      "class Storage {",
      "  constructor() {",
      "    this.cachePromise = caches.open('avatars');",
      "  }",
      "",
      "  async getAvatar(name) {",
      "    const cache = await this.cachePromise;",
      "    return cache.match(`/avatars/${name}.jpg`);",
      "  }",
      "}",
      "",
      "const storage = new Storage();",
      "storage.getAvatar('jake').then(…);",
      "",
      "// 箭头函数",
      "const foo = async () => {};",
      "返回 Promise 对象 § ⇧",
      "async函数返回一个 Promise 对象。",
      "",
      "async函数内部return语句返回的值，会成为then方法回调函数的参数。",
      "",
      "async function f() {",
      "  return 'hello world';",
      "}",
      "",
      "f().then(v => console.log(v))",
      "// \"hello world\"",
      "上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。",
      "",
      "async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。",
      "",
      "async function f() {",
      "  throw new Error('出错了');",
      "}",
      "",
      "f().then(",
      "  v => console.log(v),",
      "  e => console.log(e)",
      ")",
      "// Error: 出错了"
    ]
  },
  "js-await 命令": {
    "prefix": "js-await 命令",
    "body": ["正常情况下，await命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。",
		"",
		"async function f() {",
		"  // 等同于",
		"  // return 123;",
		"  return await 123;",
		"}",
		"",
		"f().then(v => console.log(v))",
		"// 123",
		"上面代码中，await命令的参数是数值123，这时等同于return 123。",
		"",
		"另一种情况是，await命令后面是一个thenable对象（即定义了then方法的对象），那么await会将其等同于 Promise 对象。",
		"",
		"class Sleep {",
		"  constructor(timeout) {",
		"    this.timeout = timeout;",
		"  }",
		"  then(resolve, reject) {",
		"    const startTime = Date.now();",
		"    setTimeout(",
		"      () => resolve(Date.now() - startTime),",
		"      this.timeout",
		"    );",
		"  }",
		"}",
		"",
		"(async () => {",
		"  const sleepTime = await new Sleep(1000);",
		"  console.log(sleepTime);",
		"})();",
		"// 1000",
		]
  },
  "js-forlet": {
    "prefix": "js-forlet",
    "body": [
      "for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。",
      "",
      "for (let i = 0; i < 3; i++) {",
      "  let i = 'abc';",
      "  console.log(i);",
      "}",
      "// abc",
      "// abc",
      "// abc",
      "上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。"
    ]
  },
  "js-deadArea": {
    "prefix": "js-deadArea",
    "body": [
      "var tmp = 123;",
      "",
      "if (true) {",
      "  tmp = 'abc'; // ReferenceError",
      "  let tmp;",
      "}"
    ]
  },
  "js-TDZ": {
    "prefix": "js-TDZ",
    "body": [
      "在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。",
      "",
      "if (true) {",
      "  // TDZ开始",
      "  tmp = 'abc'; // ReferenceError",
      "  console.log(tmp); // ReferenceError",
      "",
      "  let tmp; // TDZ结束",
      "  console.log(tmp); // undefined",
      "",
      "  tmp = 123;",
      "  console.log(tmp); // 123",
      "}",
      "上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。"
    ]
  },
  "js-const1": {
    "prefix": "js-const1",
    "body": [
      "const的作用域与let命令相同：只在声明所在的块级作用域内有效。",
      "",
      "if (true) {",
      "  const MAX = 5;",
      "}",
      "",
      "MAX // Uncaught ReferenceError: MAX is not defined",
      "",
      "const声明一个只读的常量。一旦声明，常量的值就不能改变。",
      "",
      "const PI = 3.1415;",
      "PI // 3.1415",
      "",
      "PI = 3;",
      "// TypeError: Assignment to constant variable."
    ]
  },
  "js-jiegou1": {
    "prefix": "js-jiegou1",
    "body": [
      "let [foo, [[bar], baz]] = [1, [[2], 3]];",
      "foo // 1",
      "bar // 2",
      "baz // 3",
      "",
      "let [ , , third] = [\"foo\", \"bar\", \"baz\"];",
      "third // \"baz\"",
      "",
      "let [x, , y] = [1, 2, 3];",
      "x // 1",
      "y // 3",
      "",
      "let [head, ...tail] = [1, 2, 3, 4];",
      "head // 1",
      "tail // [2, 3, 4]",
      "",
      "let [x, y, ...z] = ['a'];",
      "x // \"a\"",
      "y // undefined",
      "z // []"
    ]
  },
  "js-不完全解构": {
    "prefix": "js-不完全解构",
    "body": [
      "let [x, y] = [1, 2, 3];",
      "x // 1",
      "y // 2",
      "",
      "let [a, [b], d] = [1, [2, 3], 4];",
      "a // 1",
      "b // 2",
      "d // 4",
      "上面两个例子，都属于不完全解构，但是可以成功。"
    ]
  },
  "js-Set 结构，也可以使用数组的解构赋值": {
    "prefix": "js-Set 结构，也可以使用数组的解构赋值",
    "body": ["let [x, y, z] = new Set(['a', 'b', 'c']);", "x // \"a\""]
  },
  "js-解构赋值允许指定默认": {
    "prefix": "js-解构赋值允许指定默认",
    "body": [
      "let [foo = true] = [];",
      "foo // true",
      "",
      "let [x, y = 'b'] = ['a']; // x='a', y='b'",
      "let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'"
    ]
  },
  "js-对象的解构赋值": {
    "prefix": "js-对象的解构赋值",
    "body": [
      "let { foo, bar } = { foo: 'aaa', bar: 'bbb' };",
      "foo // \"aaa\"",
      "bar // \"bbb\""
    ]
  },
  "js-对象的解构也可以指定默认值": {
    "prefix": "js-对象的解构也可以指定默认值",
    "body": [
      "var {x = 3} = {};",
      "x // 3",
      "",
      "var {x, y = 5} = {x: 1};",
      "x // 1",
      "y // 5",
      "",
      "var {x: y = 3} = {};",
      "y // 3",
      "",
      "var {x: y = 3} = {x: 5};",
      "y // 5",
      "",
      "var { message: msg = 'Something went wrong' } = {};",
      "msg // \"Something went wrong\""
    ]
  },
  "js-对数组进行对象属性的解构": {
    "prefix": "js-对数组进行对象属性的解构",
    "body": [
      "let arr = [1, 2, 3];",
      "let {0 : first, [arr.length - 1] : last} = arr;",
      "first // 1",
      "last // 3"
    ]
  },
  "js-字符串的解构赋值": {
    "prefix": "js-字符串的解构赋值",
    "body": [
      "const [a, b, c, d, e] = 'hello';",
      "a // \"h\"",
      "b // \"e\"",
      "c // \"l\"",
      "d // \"l\"",
      "e // \"o\"",
      "类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。",
      "",
      "let {length : len} = 'hello';",
      "len // 5"
    ]
  },
  "js-函数参数的解构赋值": {
    "prefix": "js-函数参数的解构赋值",
    "body": [
      "函数的参数也可以使用解构赋值。",
      "",
      "function add([x, y]){",
      "  return x + y;",
      "}",
      "",
      "add([1, 2]); // 3"
    ]
  },
  "js-解构用途1交换变量的值": {
    "prefix": "js-解构用途1交换变量的值",
    "body": ["let x = 1;", "let y = 2;", "", "[x, y] = [y, x];"]
  },
  "js-解构用途2从函数返回多个值": {
    "prefix": "js-解构用途2从函数返回多个值",
    "body": [
      "// 返回一个数组",
      "",
      "function example() {",
      "  return [1, 2, 3];",
      "}",
      "let [a, b, c] = example();",
      "",
      "// 返回一个对象",
      "",
      "function example() {",
      "  return {",
      "    foo: 1,",
      "    bar: 2",
      "  };",
      "}",
      "let { foo, bar } = example();"
    ]
  },
  "js-解构用途3": {
    "prefix": "js-解构用途3",
    "body": [
      "解构赋值可以方便地将一组参数与变量名对应起来。",
      "",
      "// 参数是一组有次序的值",
      "function f([x, y, z]) { ... }",
      "f([1, 2, 3]);",
      "",
      "// 参数是一组无次序的值",
      "function f({x, y, z}) { ... }",
      "f({z: 3, y: 2, x: 1});"
    ]
  },
  "js-解构用途4": {
    "prefix": "js-解构用途4",
    "body": [
      "let jsonData = {",
      "  id: 42,",
      "  status: \"OK\",",
      "  data: [867, 5309]",
      "};",
      "",
      "let { id, status, data: number } = jsonData;",
      "",
      "console.log(id, status, number);",
      "// 42, \"OK\", [867, 5309]",
      "上面代码可以快速提取 JSON 数据的值。"
    ]
  },
  "js-解构用途5": {
    "prefix": "js-解构用途5",
    "body": [
      "函数参数的默认值",
      "",
      "jQuery.ajax = function (url, {",
      "  async = true,",
      "  beforeSend = function () {},",
      "  cache = true,",
      "  complete = function () {},",
      "  crossDomain = false,",
      "  global = true,",
      "  // ... more config",
      "} = {}) {",
      "  // ... do stuff",
      "};",
      "指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || 'default foo';这样的语句。"
    ]
  },
  "js-解构用途6": {
    "prefix": "js-解构用途6",
    "body": [
      "const map = new Map();",
      "map.set('first', 'hello');",
      "map.set('second', 'world');",
      "",
      "for (let [key, value] of map) {",
      "  console.log(key + \" is \" + value);",
      "}",
      "// first is hello",
      "// second is world",
      "如果只想获取键名，或者只想获取键值，可以写成下面这样。",
      "",
      "// 获取键名",
      "for (let [key] of map) {",
      "  // ...",
      "}",
      "",
      "// 获取键值",
      "for (let [,value] of map) {",
      "  // ...",
      "}"
    ]
  },
  "js-模板字符串": {
    "prefix": "js-模板字符串",
    "body": [
      "// 普通字符串",
      "`In JavaScript '\n' is a line-feed.`",
      "",
      "// 多行字符串",
      "`In JavaScript this is",
      " not legal.`",
      "",
      "console.log(`string text line 1",
      "string text line 2`);",
      "",
      "// 字符串中嵌入变量",
      "let name = \"Bob\", time = \"today\";",
      "`Hello ${name}, how are you ${time}?`",
      "let x = 1;",
      "let y = 2;",
      "",
      "`${x} + ${y} = ${x + y}`",
      "// \"1 + 2 = 3\"",
      "",
      "`${x} + ${y * 2} = ${x + y * 2}`",
      "// \"1 + 4 = 5\"",
      "",
      "let obj = {x: 1, y: 2};",
      "`${obj.x + obj.y}`",
      "// \"3\"",
      "模板字符串之中还能调用函数。",
      "",
      "function fn() {",
      "  return \"Hello World\";",
      "}",
      "",
      "`foo ${fn()} bar`",
      "// foo Hello World bar"
    ]
  },
  "js-string方法": {
    "prefix": "js-string方法",
    "body": [
      "String.fromCodePoint()",
      "String.raw()",
      "实例方法：codePointAt()",
      "实例方法：normalize()",
      "实例方法：includes(), startsWith(), endsWith()",
      "实例方法：repeat()",
      "实例方法：padStart()，padEnd()",
      "实例方法：trimStart()，trimEnd()",
      "实例方法：matchAll()"
    ]
  },
  "js-数值的扩展": {
    "prefix": "js-数值的扩展",
    "body": [
      "二进制和八进制表示法",
      "Number.isFinite(), Number.isNaN()",
      "Number.parseInt(), Number.parseFloat()",
      "Number.isInteger()",
      "Number.EPSILON",
      "安全整数和 Number.isSafeInteger()",
      "Math 对象的扩展",
      "指数运算符",
      "BigInt 数据类型"
    ]
  },
  "js-函数参数的默认值": {
    "prefix": "js-函数参数的默认值",
    "body": [
      "ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。",
      "",
      "function log(x, y) {",
      "  y = y || 'World';",
      "  console.log(x, y);",
      "}",
      "",
      "log('Hello') // Hello World",
      "log('Hello', 'China') // Hello China",
      "log('Hello', '') // Hello World",
      "ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。",
      "",
      "function log(x, y = 'World') {",
      "  console.log(x, y);",
      "}",
      "",
      "log('Hello') // Hello World",
      "log('Hello', 'China') // Hello China",
      "log('Hello', '') // Hello"
    ]
  },
  "js-参数默认值的位置": {
    "prefix": "js-参数默认值的位置",
    "body": [
      "// 例一",
      "function f(x = 1, y) {",
      "  return [x, y];",
      "}",
      "",
      "f() // [1, undefined]",
      "f(2) // [2, undefined]",
      "f(, 1) // 报错",
      "f(undefined, 1) // [1, 1]",
      "",
      "// 例二",
      "function f(x, y = 5, z) {",
      "  return [x, y, z];",
      "}",
      "",
      "f() // [undefined, 5, undefined]",
      "f(1) // [1, 5, undefined]",
      "f(1, ,2) // 报错",
      "f(1, undefined, 2) // [1, 5, 2]",
      "上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。"
    ]
  },
  "js-函数的 length 属性": {
    "prefix": "js-函数的 length 属性",
    "body": [
      "指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。",
      "",
      "(function (a) {}).length // 1",
      "(function (a = 5) {}).length // 0",
      "(function (a, b, c = 5) {}).length // 2",
      "上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。"
    ]
  },
  "js-函数的rest 参数": {
    "prefix": "js-函数的rest 参数",
    "body": [
      "ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。",
      "",
      "function add(...values) {",
      "  let sum = 0;",
      "",
      "  for (var val of values) {",
      "    sum += val;",
      "  }",
      "",
      "  return sum;",
      "}",
      "",
      "add(2, 5, 3) // 10"
    ]
  },
  "js-rest 参数代替arguments": {
    "prefix": "js-rest 参数代替arguments",
    "body": [
      "下面是一个 rest 参数代替arguments变量的例子。",
      "",
      "// arguments变量的写法",
      "function sortNumbers() {",
      "  return Array.prototype.slice.call(arguments).sort();",
      "}",
      "",
      "// rest参数的写法",
      "const sortNumbers = (...numbers) => numbers.sort();",
      "上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。"
    ]
  },
  "js-arguments1": {
    "prefix": "js-arguments1",
    "body": [
      "arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组"
    ]
  },
  "js-rest 参数之后不能再有其他参数（即只能是最后一个参数": {
    "prefix": "js-rest 参数之后不能再有其他参数（即只能是最后一个参数",
    "body": ["// 报错", "function f(a, ...b, c) {", "  // ...", "}"]
  },
  "js-函数的length属性，不包括 rest 参数": {
    "prefix": "js-函数的length属性，不包括 rest 参数",
    "body": [
      "函数的length属性，不包括 rest 参数。",
      "",
      "(function(a) {}).length  // 1",
      "(function(...a) {}).length  // 0",
      "(function(a, ...b) {}).length  // 1"
    ]
  },
  "js-严格模式": {
    "prefix": "js-严格模式",
    "body": [
      "从 ES5 开始，函数内部可以设定为严格模式。",
      "",
      "function doSomething(a, b) {",
      "  'use strict';",
      "  // code",
      "}",

      "ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错"
    ]
  },
  "js-use strict": {
    "prefix": "js-use strict",
    "body": [
      "'use strict';",
      "",
      "function doSomething(a, b = a) {",
      "  // code",
      "}"
    ]
  },
  "js-函数的name属性": {
    "prefix": "js-函数的name属性",
    "body": [
      "ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。",
      "",
      "var f = function () {};",
      "",
      "// ES5",
      "f.name // \"\"",
      "",
      "// ES6",
      "f.name // \"f\""
    ]
  },
  "js-箭头函数可以与变量解构结合使用。": {
    "prefix": "js-箭头函数可以与变量解构结合使用。",
    "body": [
      "const full = ({ first, last }) => first + ' ' + last;",
      "",
      "// 等同于",
      "function full(person) {",
      "  return person.first + ' ' + person.last;",
      "}"
    ]
  },

  "js-Array": {
    "prefix": "js-Array",
    "body": ["[40, 100, 1, 5, 25, 10]"]
  },
  "js-export-import": {
    "prefix": "js-export-import",
    "body": [
      "/*-----export [test.js]-----*/",
      "let myName = \"Tom\";",
      "let myAge = 20;",
      "let myfn = function(){",
      "    return \"My name is\" + myName + \"! I'm '\" + myAge + \"years old.\"",
      "}",
      "let myClass =  class myClass {",
      "    static a = \"yeah!\";",
      "}",
      "export { myName, myAge, myfn, myClass }",
      " ",
      "/*-----import [xxx.js]-----*/",
      "import { myName, myAge, myfn, myClass } from \"./test.js\";",
      "console.log(myfn());// My name is Tom! I'm 20 years old.",
      "console.log(myAge);// 20",
      "console.log(myName);// Tom",
      "console.log(myClass.a );// yeah!"
    ]
  },
  "js-as": {
    "prefix": "js-as",
    "body": [
      "/*-----export [test.js]-----*/",
      "let myName = \"Tom\";",
      "export { myName as exportName }",
      " ",
      "/*-----import [xxx.js]-----*/",
      "import { exportName } from \"./test.js\";",
      "console.log(exportName);// Tom",
      "使用 as 重新定义导出的接口名称，隐藏模块内部的变量",
      "/*-----export [test1.js]-----*/",
      "let myName = \"Tom\";",
      "export { myName }",
      "/*-----export [test2.js]-----*/",
      "let myName = \"Jerry\";",
      "export { myName }",
      "/*-----import [xxx.js]-----*/",
      "import { myName as name1 } from \"./test1.js\";",
      "import { myName as name2 } from \"./test2.js\";",
      "console.log(name1);// Tom",
      "console.log(name2);// Jerry"
    ]
  },
  "js-import": {
    "prefix": "js-import",
    "body": [
      "静态执行特性：import 是静态执行，所以不能使用表达式和变量。",
      "",
      "import { \"f\" + \"oo\" } from \"methods\";",
      "// error",
      "let module = \"methods\";",
      "import { foo } from module;",
      "// error",
      "if (true) {",
      "  import { foo } from \"method1\";",
      "} else {",
      "  import { foo } from \"method2\";",
      "}",
      "// error",

      "import {a} from \"./xxx.js\"",
      "a = {}; // error",
      " ",
      "import {a} from \"./xxx.js\"",
      "a.foo = \"hello\"; // a = { foo : 'hello' }"
    ]
  },
  "js-export default": {
    "prefix": "js-export default",
    "body": [
      "var a = \"My name is Tom!\";",
      "export default a; // 仅有一个",
      "export default var c = \"error\"; ",
      "// error，default 已经是对应的导出变量，不能跟着变量声明语句",
      " ",
      "import b from \"./xxx.js\"; // 不需要加{}， 使用任意变量接收"
    ]
  },
  "js-export 与 import": {
    "prefix": "js-export=import",
    "body": [
      "export { foo, bar } from \"methods\";",
      " ",
      "// 约等于下面两段语句，不过上面导入导出方式该模块没有导入 foo 与 bar",
      "import { foo, bar } from \"methods\";",
      "export { foo, bar };",
      " ",
      "/* ------- 特点 1 --------*/",
      "// 普通改名",
      "export { foo as bar } from \"methods\";",
      "// 将 foo 转导成 default",
      "export { foo as default } from \"methods\";",
      "// 将 default 转导成 foo",
      "export { default as foo } from \"methods\";",
      " ",
      "/* ------- 特点 2 --------*/",
      "export * from \"methods\";"
    ]
  },
  "js-Promise": {
    "prefix": "js-Promise",
    "body": [
      "const p = new Promise(function(resolve,reject){",
      "  resolve('success');",
      "});",
      " ",
      "p.then(function(value){",
      "  console.log(value);",
      "});",
      " ",
      "console.log('first');",
      "// first",
      "// success"
    ]
  },
  "js-Generator": {
    "prefix": "js-Generator",
    "body": [
      "Generator 有两个区分于普通函数的部分：",
      "",
      "一是在 function 后面，函数名之前有个 * ；",
      "",
      "函数内部有 yield 表达式。",
      "",
      "其中 * 用来表示函数为 Generator 函数，yield 用来定义函数内部的状态。",
      "",
      "function* func(){",
      " console.log(\"one\");",
      " yield '1';",
      " console.log(\"two\");",
      " yield '2'; ",
      " console.log(\"three\");",
      " return '3';",
      "}"
    ]
  },

  "js-Object": {
    "prefix": "js-Object",
    "body": [
      "{firstName:\"John\", lastName:\"Doe\", age:50, eyeColor:\"blue\"}"
    ]
  },
  "js-Function": {
    "prefix": "js-Function",
    "body": ["\"function myFunction(a, b) { return a * b;}\","]
  },
  "js-var": {
    "prefix": "js-var",
    "body": ["var x, length", "", "x = 5", "", "length = 6"]
  },
  "js-datetype": {
    "prefix": "js-datetype",
    "body": [
      "var carname=new String;",
      "var x=      new Number;",
      "var y=      new Boolean;",
      "var cars=   new Array;",
      "var person= new Object;",
      "",
      "var length = 16;                                  // Number 通过数字字面量赋值",
      "var points = x * 10;                              // Number 通过表达式字面量赋值",
      "var lastName = \"Johnson\";                         // String 通过字符串字面量赋值",
      "var cars = [\"Saab\", \"Volvo\", \"BMW\"];              // Array  通过数组字面量赋值",
      "var person = {firstName:\"John\", lastName:\"Doe\"};  // Object 通过对象字面量赋值"
    ]
  },
  "js-var2": {
    "prefix": "js-var2",
    "body": ["var lastname=\"Doe\", age=30, job=\"carpenter\";"]
  },
  "js-Array1": {
    "prefix": "js-Array1",
    "body": [
      "var cars=new Array();",
      "cars[0]=\"Saab\";",
      "cars[1]=\"Volvo\";",
      "cars[2]=\"BMW\";",
      "var cars=new Array(\"Saab\",\"Volvo\",\"BMW\");"
    ]
  },
  "js-if": {
    "prefix": "js-if",
    "body": [
      "if (time<10)",
      "{",
      "    document.write(\"<b>早上好</b>\");",
      "}",
      "else if (time>=10 && time<20)",
      "{",
      "    document.write(\"<b>今天好</b>\");",
      "}",
      "else",
      "{",
      "    document.write(\"<b>晚上好!</b>\");",
      "}"
    ]
  },
  "js-switch": {
    "prefix": "js-switch",
    "body": [
      "var d=new Date().getDay(); ",
      "switch (d) ",
      "{ ",
      "  case 0:x=\"今天是星期日\"; ",
      "  break; ",
      "  case 1:x=\"今天是星期一\"; ",
      "  break; ",
      "  case 2:x=\"今天是星期二\"; ",
      "  break; ",
      "  case 3:x=\"今天是星期三\"; ",
      "  break; ",
      "  case 4:x=\"今天是星期四\"; ",
      "  break; ",
      "  case 5:x=\"今天是星期五\"; ",
      "  break; ",
      "  case 6:x=\"今天是星期六\"; ",
      "  break; ",
      "}"
    ]
  },
  "js-for": {
    "prefix": "js-for",
    "body": [
      "for (var i=0;i<cars.length;i++)",
      "{ ",
      "    document.write(cars[i] + \"<br>\");",
      "}"
    ]
  },
  "js-forin": {
    "prefix": "js-forin",
    "body": [
      "var person={fname:\"John\",lname:\"Doe\",age:25}; ",
      " ",
      "for (x in person)  // x 为属性名",
      "{",
      "    txt=txt + person[x];",
      "}"
    ]
  },
  "js-while": {
    "prefix": "js-while",
    "body": [
      "while (i<5)",
      "{",
      "    x=x + \"The number is \" + i + \"<br>\";",
      "    i++;",
      "}"
    ]
  },
  "js-do/while": {
    "prefix": "js-do/while",
    "body": [
      "do",
      "{",
      "    x=x + \"The number is \" + i + \"<br>\";",
      "    i++;",
      "}",
      "while (i<5);"
    ]
  },
  "js-typeof": {
    "prefix": "js-typeof",
    "body": [
      "undefined 和 null 的区别",
      "实例",
      "null 和 undefined 的值相等，但类型不等：",
      "",
      "typeof undefined             // undefined",
      "typeof null                  // object",
      "null === undefined           // false",
      "null == undefined            // true",

      "typeof \"John\"                // 返回 string",
      "typeof 3.14                  // 返回 number",
      "typeof false                 // 返回 boolean",
      "typeof [1,2,3,4]             // 返回 object",
      "typeof {name:'John', age:34} // 返回 object"
    ]
  },
  "js-constructor": {
    "prefix": "js-constructor",
    "body": [
      "你可以使用 constructor 属性来查看对象是否为数组 (包含字符串 \"Array\"):",
      "",
      "实例",
      "function isArray(myArray) {",
      "    return myArray.constructor.toString().indexOf(\"Array\") > -1;",
      "}",
      "",

      "constructor 属性返回所有 JavaScript 变量的构造函数。",
      "",
      "实例",
      "\"John\".constructor                 // 返回函数 String()  { [native code] }",
      "(3.14).constructor                 // 返回函数 Number()  { [native code] }",
      "false.constructor                  // 返回函数 Boolean() { [native code] }",
      "[1,2,3,4].constructor              // 返回函数 Array()   { [native code] }",
      "{name:'John', age:34}.constructor  // 返回函数 Object()  { [native code] }",
      "new Date().constructor             // 返回函数 Date()    { [native code] }",
      "function () {}.constructor         // 返回函数 Function(){ [native code] }"
    ]
  },
  "js-Stringto": {
    "prefix": "js-Stringto",
    "body": [
      "5 + null    // 返回 5         null 转换为 0",
      "\"5\" + null  // 返回\"5null\"   null 转换为 \"null\"",
      "\"5\" + 1     // 返回 \"51\"      1 转换为 \"1\" ",
      "\"5\" - 1     // 返回 4         \"5\" 转换为 5",
      "",
      "全局方法 Number() 可将日期转换为数字。",
      "",
      "d = new Date();",
      "Number(d)          // 返回 1404568027739",
      "日期方法 getTime() 也有相同的效果。",
      "",
      "d = new Date();",
      "d.getTime()        // 返回 1404568027739",

      "Number(false)     // 返回 0",
      "Number(true)      // 返回 1",

      "Number(\"3.14\")    // 返回 3.14",
      "Number(\" \")       // 返回 0",
      "Number(\"\")        // 返回 0",
      "Number(\"99 88\")   // 返回 NaN",

      "obj = new Date()",
      "obj.toString()   ",

      "String(new Date())      // 返回 Thu Jul 17 2014 15:38:19 GMT+0200 (W. Europe Daylight Time)",

      "false.toString()     // 返回 \"false\"",
      "true.toString()      // 返回 \"true\"",

      "String(false)        // 返回 \"false\"",
      "String(true)         // 返回 \"true\"",

      "x.toString()",
      "(123).toString()",
      "(100 + 23).toString()",

      "String(x)         // 将变量 x 转换为字符串并返回",
      "String(123)       // 将数字 123 转换为字符串并返回",
      "String(100 + 23)  // 将数字表达式转换为字符串并返回"
    ]
  },
  "js-try": {
    "prefix": "js-try",
    "body": [
      "var txt=\"\"; ",
      "function message() ",
      "{ ",
      "    try { ",
      "        adddlert(\"Welcome guest!\"); ",
      "    } catch(err) { ",
      "        txt=\"本页有一个错误。\n\n\"; ",
      "        txt+=\"错误描述：\" + err.message + \"\n\n\"; ",
      "        txt+=\"点击确定继续。\n\n\"; ",
      "        alert(txt); ",
      "    } ",
      "}"
    ]
  },
  "js-throw": {
    "prefix": "js-throw",
    "body": [
      "function myFunction() {",
      "    var message, x;",
      "    message = document.getElementById(\"message\");",
      "    message.innerHTML = \"\";",
      "    x = document.getElementById(\"demo\").value;",
      "    try { ",
      "        if(x == \"\")  throw \"值为空\";",
      "        if(isNaN(x)) throw \"不是数字\";",
      "        x = Number(x);",
      "        if(x < 5)    throw \"太小\";",
      "        if(x > 10)   throw \"太大\";",
      "    }",
      "    catch(err) {",
      "        message.innerHTML = \"错误: \" + err;",
      "    }",
      "}"
    ]
  },
  "js-strict": {
    "prefix": "js-strict",
    "body": [
      "\"use strict\";",
      "myFunction();",
      "",
      "function myFunction() {",
      "    y = 3.14;   // 报错 (y 未定义)",
      "}"
    ]
  },
  "js-JSON": {
    "prefix": "js-JSON",
    "body": [
      "var obj = JSON.parse(text);",

      "var text = '{ \"sites\" : [' +",
      "'{ \"name\":\"Runoob\" , \"url\":\"www.runoob.com\" },' +",
      "'{ \"name\":\"Google\" , \"url\":\"www.google.com\" },' +",
      "'{ \"name\":\"Taobao\" , \"url\":\"www.taobao.com\" } ]}';"
    ]
  },
  "js-JSON.stringify": {
    "prefix": "js-JSON.stringify",
    "body": [
      "<script>",
      "var str = {\"name\":\"菜鸟教程\", \"site\":\"http://www.runoob.com\"}",
      "str_pretty1 = JSON.stringify(str)",
      "document.write( \"只有一个参数情况：\" );",
      "document.write( \"<br>\" );",
      "document.write(\"<pre>\" + str_pretty1 + \"</pre>\" );",
      "document.write( \"<br>\" );",
      "str_pretty2 = JSON.stringify(str, null, 4) //使用四个空格缩进",
      "document.write( \"使用参数情况：\" );",
      "document.write( \"<br>\" );",
      "document.write(\"<pre>\" + str_pretty2 + \"</pre>\" ); // pre 用于格式化输出",
      "</script>"
    ]
  },
  "js-void": {
    "prefix": "js-void",
    "body": ["<a href=\"javascript:void(alert('Warning!!!'))\">点我!</a>"]
  },
  "js-Function1": {
    "prefix": "js-Function1",
    "body": [
      "var myFunction = new Function(\"a\", \"b\", \"return a * b\");",
      "",
      "var x = myFunction(4, 3);"
    ]
  },
  "js-function()": {
    "prefix": "js-function()",
    "body": [
      "(function () {",
      "    var x = \"Hello!!\";      // 我将调用自己",
      "})();"
    ]
  },
  "js-arrowFun": {
    "prefix": "js-arrowFun",
    "body": [
      "(单一参数) => {函数声明}",
      "单一参数 => {函数声明}",
      "() => {函数声明}",

      "(参数1, 参数2, …, 参数N) => { 函数声明 }",
      "",
      "(参数1, 参数2, …, 参数N) => 表达式(单一)",
      "// 相当于：(参数1, 参数2, …, 参数N) =>{ return 表达式; }"
    ]
  },
  "js-functionDefault": {
    "prefix": "js-functionDefault",
    "body": [
      "function myFunction(x, y = 10) {",
      "    // y is 10 if not passed or undefined",
      "    return x + y;",
      "}",
      " ",
      "myFunction(0, 2) // 输出 2",
      "myFunction(5); // 输出 15, y 参数的默认值"
    ]
  },
  "js-arguments": {
    "prefix": "js-arguments",
    "body": [
      "x = findMax(1, 123, 500, 115, 44, 88);",
      " ",
      "function findMax() {",
      "    var i, max = arguments[0];",
      "    ",
      "    if(arguments.length < 2) return max;",
      " ",
      "    for (i = 0; i < arguments.length; i++) {",
      "        if (arguments[i] > max) {",
      "            max = arguments[i];",
      "        }",
      "    }",
      "    return max;",
      "}"
    ]
  },
  "js-getElementById": {
    "prefix": "js-getElementById",
    "body": [
      "<script>",
      "document.getElementById(\"p2\").style.color=\"blue\";",
      "document.getElementById(\"p2\").style.fontFamily=\"Arial\";",
      "document.getElementById(\"p2\").style.fontSize=\"larger\";",
      "</script>"
    ]
  },
  "js-createTextNode": {
    "prefix": "js-createTextNode",
    "body": [
      "<script>",
      "var para = document.createElement(\"p\");",
      "var node = document.createTextNode(\"这是一个新的段落。\");",
      "para.appendChild(node);",
      " ",
      "var element = document.getElementById(\"div1\");",
      "element.appendChild(para);",
      "</script>"
    ]
  },
  "js-functionClass": {
    "prefix": "js-functionClass",
    "body": [
      "function person(firstname,lastname,age,eyecolor)",
      "{",
      "    this.firstname=firstname;",
      "    this.lastname=lastname;",
      "    this.age=age;",
      "    this.eyecolor=eyecolor;",
      "",
      "    this.changeName=changeName;",
      "    function changeName(name)",
      "    {",
      "        this.lastname=name;",
      "    }",
      "}"
    ]
  },
  "js-prototype": {
    "prefix": "js-prototype",
    "body": [
      "function Person(first, last, age, eyecolor) {",
      "  this.firstName = first;",
      "  this.lastName = last;",
      "  this.age = age;",
      "  this.eyeColor = eyecolor;",
      "}",
      " ",
      "Person.prototype.name = function() {",
      "  return this.firstName + \" \" + this.lastName;",
      "};"
    ]
  },
  "js-toString": {
    "prefix": "js-toString",
    "body": [
      "var myNumber=128;",
      "myNumber.toString(16);   // 返回 80",
      "myNumber.toString(8);    // 返回 200",
      "myNumber.toString(2);    // 返回 10000000"
    ]
  },
  "js-window": {
    "prefix": "js-window",
    "body": [
      "window.open() - 打开新窗口",
      "window.close() - 关闭当前窗口",
      "window.moveTo() - 移动当前窗口",
      "window.resizeTo() - 调整当前窗口的尺寸"
    ]
  },
  "js-let": {
    "prefix": "js-let",
    "body": [
      "console.log(a);  //ReferenceError: a is not defined",
      "let a = \"apple\";",
      " ",
      "console.log(b);  //undefined",
      "var b = \"banana\";"
    ]
  },
  "js-const": {
    "prefix": "js-const",
    "body": [
      "const PI = \"3.1415926\";",
      "PI  // 3.1415926",
      "",
      "const MY_AGE;  // SyntaxError: Missing initializer in const declaration    "
    ]
  },
  "js-jiegou": {
    "prefix": "js-jiegou",
    "body": [
      "let [a, b, c, d, e] = 'hello';",
      "let [a, b, c] = [1, 2, 3];",
      "let [a, , b] = [1, 2, 3];",
      "",
      "let [a = 3, b = a] = [];     // a = 3, b = 3",
      "let [a = 3, b = a] = [1];    // a = 1, b = 1",
      "let [a = 3, b = a] = [1, 2]; // a = 1, b = 2"
    ]
  },
  "js-jiegouObj": {
    "prefix": "js-jiegouObj",
    "body": [
      "let { foo, bar } = { foo: 'aaa', bar: 'bbb' };",
      "// foo = 'aaa'",
      "// bar = 'bbb'",
      " ",
      "let { baz : foo } = { baz : 'ddd' };",
      "// foo = 'ddd'",
      "",
      "let {a = 10, b = 5} = {a: 3};",
      "// a = 3; b = 5;",
      "let {a: aa = 10, b: bb = 5} = {a: 3};",
      "// aa = 3; bb = 5;"
    ]
  },
  "js-Symbol": {
    "prefix": "js-Symbol",
    "body": [
      "let sy = Symbol(\"KK\");",
      "console.log(sy);   // Symbol(KK)",
      "typeof(sy);        // \"symbol\"",
      " ",
      "// 相同参数 Symbol() 返回的值不相等",
      "let sy1 = Symbol(\"kk\"); ",
      "sy === sy1;       // false",

      "",
      "let sy = Symbol(\"key1\");",
      " ",
      "// 写法1",
      "let syObject = {};",
      "syObject[sy] = \"kk\";",
      "console.log(syObject);    // {Symbol(key1): \"kk\"}",
      " ",
      "// 写法2",
      "let syObject = {",
      "  [sy]: \"kk\"",
      "};",
      "console.log(syObject);    // {Symbol(key1): \"kk\"}",
      " ",
      "// 写法3",
      "let syObject = {};",
      "Object.defineProperty(syObject, sy, {value: \"kk\"});",
      "console.log(syObject);   // {Symbol(key1): \"kk\"}"
    ]
  },
  "js-Symbol.for": {
    "prefix": "js-Symbol.for",
    "body": [
      "let yellow = Symbol(\"Yellow\");",
      "let yellow1 = Symbol.for(\"Yellow\");",
      "yellow === yellow1;      // false",
      " ",
      "let yellow2 = Symbol.for(\"Yellow\");",
      "yellow1 === yellow2;     // true"
    ]
  },
  "js-Map": {
    "prefix": "js-Map",
    "body": [
      "Map 中的 key",
      "key 是字符串",
      "",
      "var myMap = new Map();",
      "var keyString = \"a string\"; ",
      " ",
      "myMap.set(keyString, \"和键'a string'关联的值\");",
      " ",
      "myMap.get(keyString);    // \"和键'a string'关联的值\"",
      "myMap.get(\"a string\");   // \"和键'a string'关联的值\"",
      "                         // 因为 keyString === 'a string'",
      "key 是对象",
      "",
      "var myMap = new Map();",
      "var keyObj = {}, ",
      " ",
      "myMap.set(keyObj, \"和键 keyObj 关联的值\");",
      "﻿",
      "myMap.get(keyObj); // \"和键 keyObj 关联的值\"",
      "myMap.get({}); // undefined, 因为 keyObj !== {}",
      "key 是函数",
      "",
      "var myMap = new Map();",
      "var keyFunc = function () {}, // 函数",
      " ",
      "myMap.set(keyFunc, \"和键 keyFunc 关联的值\");",
      " ",
      "myMap.get(keyFunc); // \"和键 keyFunc 关联的值\"",
      "myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}",
      "key 是 NaN",
      "",
      "var myMap = new Map();",
      "myMap.set(NaN, \"not a number\");",
      " ",
      "myMap.get(NaN); // \"not a number\"",
      " ",
      "var otherNaN = Number(\"foo\");",
      "myMap.get(otherNaN); // \"not a number\""
    ]
  },
  "js-Mapfor": {
    "prefix": "js-Mapfor",
    "body": [
      "for...of",
      "var myMap = new Map();",
      "myMap.set(0, \"zero\");",
      "myMap.set(1, \"one\");",
      " ",
      "// 将会显示两个 log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"",
      "for (var [key, value] of myMap) {",
      "  console.log(key + \" = \" + value);",
      "}",
      "for (var [key, value] of myMap.entries()) {",
      "  console.log(key + \" = \" + value);",
      "}",
      "/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */",
      " ",
      "// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"",
      "for (var key of myMap.keys()) {",
      "  console.log(key);",
      "}",
      "/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */",
      " ",
      "// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"",
      "for (var value of myMap.values()) {",
      "  console.log(value);",
      "}",
      "/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */",
      "forEach()",
      "var myMap = new Map();",
      "myMap.set(0, \"zero\");",
      "myMap.set(1, \"one\");",
      " ",
      "// 将会显示两个 logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"",
      "myMap.forEach(function(value, key) {",
      "  console.log(key + \" = \" + value);",
      "}, myMap)"
    ]
  },
  "js-MapArray1": {
    "prefix": "js-MapArray1",
    "body": [
      "var kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];",
      " ",
      "// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象",
      "var myMap = new Map(kvArray);",
      " ",
      "// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组",
      "var outArray = Array.from(myMap);",
      "Map 的克隆",
      "",
      "var myMap1 = new Map([[\"key1\", \"value1\"], [\"key2\", \"value2\"]]);",
      "var myMap2 = new Map(myMap1);",
      " ",
      "console.log(original === clone); ",
      "// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。",
      "Map 的合并",
      "",
      "var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]);",
      "var second = new Map([[1, 'uno'], [2, 'dos']]);",
      " ",
      "// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three",
      "var merged = new Map([...first, ...second]);"
    ]
  },
  "js-Set": {
    "prefix": "js-Set",
    "body": [
      "let mySet = new Set();",
      " ",
      "mySet.add(1); // Set(1) {1}",
      "mySet.add(5); // Set(2) {1, 5}",
      "mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性",
      "mySet.add(\"some text\"); ",
      "// Set(3) {1, 5, \"some text\"} 这里体现了类型的多样性",
      "var o = {a: 1, b: 2}; ",
      "mySet.add(o);",
      "mySet.add({a: 1, b: 2}); ",
      "// Set(5) {1, 5, \"some text\", {…}, {…}} ",
      "// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储"
    ]
  },
  "js-ArraySet": {
    "prefix": "js-ArraySet",
    "body": [
      "// Array 转 Set",
      "var mySet = new Set([\"value1\", \"value2\", \"value3\"]);",
      "// 用...操作符，将 Set 转 Array",
      "var myArray = [...mySet];",
      "String",
      "// String 转 Set",
      "var mySet = new Set('hello');  // Set(4) {\"h\", \"e\", \"l\", \"o\"}",
      "// 注：Set 中 toString 方法是不能将 Set 转换成 String"
    ]
  },
  "js-Set2": {
    "prefix": "js-Set2",
    "body": [
      "数组去重",
      "",
      "var mySet = new Set([1, 2, 3, 4, 4]);",
      "[...mySet]; // [1, 2, 3, 4]",
      "并集",
      "",
      "var a = new Set([1, 2, 3]);",
      "var b = new Set([4, 3, 2]);",
      "var union = new Set([...a, ...b]); // {1, 2, 3, 4}",
      "交集",
      "",
      "var a = new Set([1, 2, 3]);",
      "var b = new Set([4, 3, 2]);",
      "var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3}",
      "差集",
      "",
      "var a = new Set([1, 2, 3]);",
      "var b = new Set([4, 3, 2]);",
      "var difference = new Set([...a].filter(x => !b.has(x))); // {1}"
    ]
  },
  "js-Proxy": {
    "prefix": "js-Proxy",
    "body": [
      "一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。",
      "",
      "let target = {",
      "    name: 'Tom',",
      "    age: 24",
      "}",
      "let handler = {",
      "    get: function(target, key) {",
      "        console.log('getting '+key);",
      "        return target[key]; // 不是target.key",
      "    },",
      "    set: function(target, key, value) {",
      "        console.log('setting '+key);",
      "        target[key] = value;",
      "    }",
      "}",
      "let proxy = new Proxy(target, handler)",
      "proxy.name     // 实际执行 handler.get",
      "proxy.age = 25 // 实际执行 handler.set",
      "// getting name",
      "// setting age",
      "// 25",
      " ",
      "// target 可以为空对象",
      "let targetEpt = {}",
      "let proxyEpt = new Proxy(targetEpt, handler)",
      "// 调用 get 方法，此时目标对象为空，没有 name 属性",
      "proxyEpt.name // getting name",
      "// 调用 set 方法，向目标对象中添加了 name 属性",
      "proxyEpt.name = 'Tom'",
      "// setting name",
      "// \"Tom\"",
      "// 再次调用 get ，此时已经存在 name 属性",
      "proxyEpt.name",
      "// getting name",
      "// \"Tom\"",
      " ",
      "// 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相",
      "// 影响",
      "targetEpt)",
      "// {name: \"Tom\"}",
      " ",
      "// handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象",
      "let targetEmpty = {}",
      "let proxyEmpty = new Proxy(targetEmpty,{})",
      "proxyEmpty.name = \"Tom\"",
      "targetEmpty) // {name: \"Tom\"}",
      "实例方法",
      "get(target, propKey, receiver)",
      "用于 target 对象上 propKey 的读取操作。",
      "",
      "let exam ={",
      "    name: \"Tom\",",
      "    age: 24",
      "}",
      "let proxy = new Proxy(exam, {",
      "  get(target, propKey, receiver) {",
      "    console.log('Getting ' + propKey);",
      "    return target[propKey];",
      "  }",
      "})",
      "proxy.name ",
      "// Getting name",
      "// \"Tom\""
    ]
  },
  "js-Reflect": {
    "prefix": "js-Reflect",
    "body": [
      "let exam = {",
      "    name: \"Tom\",",
      "    age: 24,",
      "    get info(){",
      "        return this.name + this.age;",
      "    }",
      "}",
      "Reflect.get(exam, 'name'); // \"Tom\"",
      " ",
      "// 当 target 对象中存在 name 属性的 getter 方法， getter 方法的 this 会绑定 // receiver",
      "let receiver = {",
      "    name: \"Jerry\",",
      "    age: 20",
      "}",
      "Reflect.get(exam, 'info', receiver); // Jerry20",
      " ",
      "// 当 name 为不存在于 target 对象的属性时，返回 undefined",
      "Reflect.get(exam, 'birth'); // undefined",
      " ",
      "// 当 target 不是对象时，会报错",
      "Reflect.get(1, 'name'); // TypeError"
    ]
  },
  "js-es6string": {
    "prefix": "js-es6string",
    "body": [
      "let string = \"apple,banana,orange\";",
      "string.includes(\"banana\");     // true",
      "string.startsWith(\"apple\");    // true",
      "string.endsWith(\"apple\");      // false",
      "string.startsWith(\"banana\",6)  // true"
    ]
  },
  "js-es6repeat": {
    "prefix": "js-es6repeat",
    "body": ["console.log(\"Hello,\".repeat(2));  // \"Hello,Hello,\""]
  },
  "js-padStart": {
    "prefix": "js-padStart",
    "body": [
      "console.log(\"h\".padStart(5,\"o\"));  // \"ooooh\"",
      "console.log(\"h\".padEnd(5,\"o\"));    // \"hoooo\"",
      "console.log(\"h\".padStart(5));      // \"    h\""
    ]
  },
  "js-templateString": {
    "prefix": "js-templateString",
    "body": [
      "let name = \"Mike\";",
      "let age = 27;",
      "let info = `My Name is ${name},I am ${age+1} years old next year.`",
      "console.log(info);",
      "// My Name is Mike,I am 28 years old next year."
    ]
  },
  "js-Number.EPSILON": {
    "prefix": "js-Number.EPSILON",
    "body": [
      "Number.EPSILON",
      "Number.EPSILON 属性表示 1 与大于 1 的最小浮点数之间的差。",
      "",
      "它的值接近于 2.2204460492503130808472633361816E-16，或者 2-52。",
      "",
      "测试数值是否在误差范围内:",
      "",
      "0.1 + 0.2 === 0.3; // false",
      "// 在误差范围内即视为相等",
      "equal = (Math.abs(0.1 - 0.3 + 0.2) < Number.EPSILON); // true"
    ]
  },
  "js-isFinite": {
    "prefix": "js-isFinite",
    "body": [
      "console.log( Number.isFinite(1));   // true",
      "console.log( Number.isFinite(0.1)); // true",
      " ",
      "// NaN 不是有限的",
      "console.log( Number.isFinite(NaN)); // false",
      " ",
      "console.log( Number.isFinite(Infinity));  // false",
      "console.log( Number.isFinite(-Infinity)); // false",
      " ",
      "// Number.isFinate 没有隐式的 Number() 类型转换，所有非数值都返回 false",
      "console.log( Number.isFinite('foo')); // false",
      "console.log( Number.isFinite('15'));  // false",
      "console.log( Number.isFinite(true));  // false",
      "Number.isNaN()",
      "用于检查一个值是否为 NaN 。",
      "console.log(Number.isNaN(NaN));      // true",
      "console.log(Number.isNaN('true'/0)); // true",
      " ",
      "// 在全局的 isNaN() 中，以下皆返回 true，因为在判断前会将非数值向数值转换",
      "// 而 Number.isNaN() 不存在隐式的 Number() 类型转换，非 NaN 全部返回 false",
      "Number.isNaN(\"NaN\");      // false",
      "Number.isNaN(undefined);  // false",
      "Number.isNaN({});         // false",
      "Number.isNaN(\"true\");     // false"
    ]
  },
  "js-Number.parseInt": {
    "prefix": "js-Number.parseInt",
    "body": [
      "// 不指定进制时默认为 10 进制",
      "Number.parseInt('12.34'); // 12",
      "Number.parseInt(12.34);   // 12",
      " ",
      "// 指定进制",
      "Number.parseInt('0011',2); // 3",
      " ",
      "// 与全局的 parseInt() 函数是同一个函数",
      "Number.parseInt === parseInt; // true",
      "Number.parseFloat()",
      "用于把一个字符串解析成浮点数。",
      "Number.parseFloat('123.45')    // 123.45",
      "Number.parseFloat('123.45abc') // 123.45",
      " ",
      "// 无法被解析成浮点数，则返回 NaN",
      "Number.parseFloat('abc') // NaN",
      " ",
      "// 与全局的 parseFloat() 方法是同一个方法",
      "Number.parseFloat === parseFloat // true",
      "Number.isInteger()",
      "用于判断给定的参数是否为整数。",
      "Number.isInteger(value)",
      "Number.isInteger(0); // true",
      "// JavaScript 内部，整数和浮点数采用的是同样的储存方法,因此 1 与 1.0 被视为相同的值",
      "Number.isInteger(1);   // true",
      "Number.isInteger(1.0); // true",
      " ",
      "Number.isInteger(1.1);     // false",
      "Number.isInteger(Math.PI); // false",
      " ",
      "// NaN 和正负 Infinity 不是整数",
      "Number.isInteger(NaN);       // false",
      "Number.isInteger(Infinity);  // false",
      "Number.isInteger(-Infinity); // false",
      " ",
      "Number.isInteger(\"10\");  // false",
      "Number.isInteger(true);  // false",
      "Number.isInteger(false); // false",
      "Number.isInteger([1]);   // false",
      " ",
      "// 数值的精度超过 53 个二进制位时，由于第 54 位及后面的位被丢弃，会产生误判",
      "Number.isInteger(1.0000000000000001) // true",
      " ",
      "// 一个数值的绝对值小于 Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨",
      "// 的最小值，会被自动转为 0，也会产生误判",
      "Number.isInteger(5E-324); // false",
      "Number.isInteger(5E-325); // true",
      "Number.isSafeInteger()",
      "用于判断数值是否在安全范围内。",
      "Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1); // false",
      "Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1); // false"
    ]
  },
  "js-combineObject": {
    "prefix": "js-combineObject",
    "body": [
      "let age = {age: 15};",
      "let name = {name: \"Amy\"};",
      "let person = {...age, ...name};",
      "person;  //{age: 15, name: \"Amy\"}"
    ]
  },
  "js-Object.assign": {
    "prefix": "js-Object.assign",
    "body": [
      "如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。",
      "如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。",
      "Object.assign(3);         // Number {3}",
      "typeof Object.assign(3);  // \"object\"",

      "",
      "Object.assign(target, source_1, ···)",
      "用于将源对象的所有可枚举属性复制到目标对象中。",
      "",
      "基本用法",
      "",
      "let target = {a: 1};",
      "let object2 = {b: 2};",
      "let object3 = {c: 3};",
      "Object.assign(target,object2,object3);  ",
      "// 第一个参数是目标对象，后面的参数是源对象",
      "target;  // {a: 1, b: 2, c: 3"
    ]
  },
  "js-Object.is": {
    "prefix": "js-Object.is",
    "body": [
      "用来比较两个值是否严格相等，与（===）基本类似。",
      "",
      "基本用法",
      "",
      "基本用法",
      "",
      "Object.is(\"q\",\"q\");      // true",
      "Object.is(1,1);          // true",
      "Object.is([1],[1]);      // false",
      "Object.is({q:1},{q:1});  // false",
      "与（===）的区别",
      "",
      "//一是+0不等于-0",
      "Object.is(+0,-0);  //false",
      "+0 === -0  //true",
      "//二是NaN等于本身",
      "Object.is(NaN,NaN); //true",
      "NaN === NaN  //false"
    ]
  },
  "js-Array.of": {
    "prefix": "js-Array.of",
    "body": [
      "Array.of()",
      "将参数中所有值作为元素形成数组。",
      "",
      "console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]",
      " ",
      "// 参数值可为不同类型",
      "console.log(Array.of(1, '2', true)); // [1, '2', true]",
      " ",
      "// 参数为空时返回空数组",
      "console.log(Array.of()); // []",
      "Array.from()",
      "将类数组对象或可迭代对象转化为数组。",
      "",
      "// 参数为数组,返回与原数组一样的数组",
      "console.log(Array.from([1, 2])); // [1, 2]",
      " ",
      "// 参数含空位",
      "console.log(Array.from([1, , 3])); // [1, undefined, 3]"
    ]
  },
  "js-...": {
    "prefix": "js-...",
    "body": [
      "function f(...values){",
      "    console.log(values.length);",
      "}",
      "f(1,2);      //2",
      "f(1,2,3,4);  //4"
    ]
  },
  "js-arrowThis": {
    "prefix": "js-arrowThis",
    "body": [
      "var func = () => {",
      "  // 箭头函数里面没有 this 对象，",
      "  // 此时的 this 是外层的 this 对象，即 Window ",
      "  console.log(this)",
      "}",
      "func(55)  // Window ",
      " ",
      "var func = () => {    ",
      "  console.log(arguments)",
      "}",
      "func(55);  // ReferenceError: arguments is not defined",

      "箭头函数体中的 this 对象，是定义函数时的对象，而不是使用函数时的对象。"
    ]
  },
  "js-this": {
    "prefix": "js-this",
    "body": [
      "适合使用的场景",
      "ES6 之前，JavaScript 的 this 对象一直很令人头大，回调函数，经常看到 var self = this 这样的代码，为了将外部 this 传递到回调函数中，那么有了箭头函数，就不需要这样做了，直接使用 this 就行。",
      "",
      "// 回调函数",
      "var Person = {",
      "    'age': 18,",
      "    'sayHello': function () {",
      "      setTimeout(function () {",
      "        console.log(this.age);",
      "      });",
      "    }",
      "};",
      "var age = 20;",
      "Person.sayHello();  // 20",
      " ",
      "var Person1 = {",
      "    'age': 18,",
      "    'sayHello': function () {",
      "      setTimeout(()=>{",
      "        console.log(this.age);",
      "      });",
      "    }",
      "};",
      "var age = 20;",
      "Person1.sayHello();  // 18",
      "所以，当我们需要维护一个 this 上下文的时候，就可以使用箭头函数。",
      "",
      "不适合使用的场景",
      "定义函数的方法，且该方法中包含 this",
      "",
      "var Person = {",
      "    'age': 18,",
      "    'sayHello': ()=>{",
      "        console.log(this.age);",
      "      }",
      "};",
      "var age = 20;",
      "Person.sayHello();  // 20",
      "// 此时 this 指向的是全局对象",
      " ",
      "var Person1 = {",
      "    'age': 18,",
      "    'sayHello': function () {",
      "        console.log(this.age);",
      "    }",
      "};",
      "var age = 20;",
      "Person1.sayHello();   // 18",
      "// 此时的 this 指向 Person1 对象",
      "需要动态 this 的时候",
      "",
      "var button = document.getElementById('userClick');",
      "button.addEventListener('click', () => {",
      "     this.classList.toggle('on');",
      "});",
      "button 的监听函数是箭头函数，所以监听函数里面的 this 指向的是定义的时候外层的 this 对象，即 Window，导致无法操作到被点击的按钮对象。"
    ]
  },
  "js-classStatic": {
    "prefix": "js-classStatic",
    "body": [
      "静态属性",
      "",
      "静态属性：class 本身的属性，即直接定义在类内部的属性（ Class.propname ），不需要实例化。 ES6 中规定，Class 内部只有静态方法，没有静态属性。",
      "",
      "class Example {",
      "// 新提案",
      "    static a = 2;",
      "}",
      "// 目前可行写法",
      "Example.b = 2;"
    ]
  },
  "js-constructor1": {
    "prefix": "js-constructor1",
    "body": [
      "class Example{",
      "    constructor(){",
      "      console.log('我是constructor');",
      "    }",
      "}",
      "new Example(); // 我是constructor"
    ]
  },
  "js-staticFun": {
    "prefix": "js-staticFun",
    "body": [
      "class Example{",
      "    static sum(a, b) {",
      "        console.log(a+b);",
      "    }",
      "}",
      "Example.sum(1, 2); // 3"
    ]
  },
  "js-class2": {
    "prefix": "js-class2",
    "body": [
      "class Example {",
      "    constructor(a, b) {",
      "        this.a = a;",
      "        this.b = b;",
      "        console.log('Example');",
      "    }",
      "    sum() {",
      "        return this.a + this.b;",
      "    }",
      "}",
      "let exam1 = new Example(2, 1);",
      "let exam2 = new Example(3, 1);",
      "console.log(exam1._proto_ == exam2._proto_); // true",
      " ",
      "exam1._proto_.sub = function() {",
      "    return this.a - this.b;",
      "}",
      "console.log(exam1.sub()); // 1",
      "console.log(exam2.sub()); // 2"
    ]
  },
  "js-get": {
    "prefix": "js-get",
    "body": [
      "class Example{",
      "    constructor(a, b) {",
      "        this.a = a; // 实例化时调用 set 方法",
      "        this.b = b;",
      "    }",
      "    get a(){",
      "        console.log('getter');",
      "        return this.a;",
      "    }",
      "    set a(a){",
      "        console.log('setter');",
      "        this.a = a; // 自身递归调用",
      "    }",
      "}",
      "let exam = new Example(1,2); // 不断输出 setter ，最终导致 RangeError",
      "class Example1{",
      "    constructor(a, b) {",
      "        this.a = a;",
      "        this.b = b;",
      "    }",
      "    get a(){",
      "        console.log('getter');",
      "        return this._a;",
      "    }",
      "    set a(a){",
      "        console.log('setter');",
      "        this._a = a;",
      "    }",
      "}",
      "let exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法",
      "console.log(exam._a); // 1, 可以直接访问"
    ]
  },
  "js-extends": {
    "prefix": "js-extends",
    "body": [
      "class Father {",
      "    constructor() {}",
      "}",
      "class Child extends Father {",
      "    constructor() {}",
      "    // or ",
      "    // constructor(a) {",
      "        // this.a = a;",
      "        // super();",
      "    // }",
      "}",
      "let test = new Child(); // Uncaught ReferenceError: Must call super ",
      "// constructor in derived class before accessing 'this' or returning ",
      "// from derived constructor"
    ]
  },
  "js-super": {
    "prefix": "js-super",
    "body": [
      "class Child2 extends Father {",
      "    constructor(){",
      "        super();",
      "        // 调用父类普通方法",
      "        console.log(super.test()); // 0",
      "    }",
      "    static test3(){",
      "        // 调用父类静态方法",
      "        return super.test1+2;",
      "    }",
      "}",
      "",
      "Child2.test3(); // 3",

      "class Father {",
      "    test(){",
      "        return 0;",
      "    }",
      "    static test1(){",
      "        return 1;",
      "    }",
      "}",
      "class Child extends Father {",
      "    constructor(){",
      "        super();",
      "    }",
      "}",
      "class Child1 extends Father {",
      "    test2() {",
      "        super(); // Uncaught SyntaxError: 'super' keyword unexpected     ",
      "        // here",
      "    }",
      "}"
    ]
  },
  "js-Object.setPrototypeOf": {
    "prefix": "js-Object.setPrototypeOf",
    "body": [
      "注意要点",
      "不可继承常规对象。",
      "",
      "var Father = {",
      "    // ...",
      "}",
      "class Child extends Father {",
      "     // ...",
      "}",
      "// Uncaught TypeError: Class extends value #<Object> is not a constructor or null",
      " ",
      "// 解决方案",
      "Object.setPrototypeOf(Child.prototype, Father);"
    ]
  }
}
