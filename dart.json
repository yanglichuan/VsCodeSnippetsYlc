{
	// Place your snippets for dart here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"dt-rowtest": {
		"prefix": "dt-rowtest",
		"body": [
			"Row(",
			"children: <Widget>[",
			"Container(",
			"height: 50, width: 100,",
			"color: Colors.red,",
			"), Container(",
			"height: 100,",
			"width: 100,",
			"color: Colors.green,",
			"), Container(",
			"height: 150, width: 100,",
			"color: Colors.blue,",
			"),",
			"], )",
		],
		"description": "Log output to console"
	},
	"dt-AboutDialog": {
		"prefix": "dt-AboutDialog",
		"body": [],
	},
	"dt-demo": {
		"prefix": "dt-demo",
		"body": [
			"// 定义一个函数",
			"printInteger(int aNumber) {",
			"  print('The number is $aNumber.'); // 打印到控制台。",
			"}",
			"",
			"// 应用从这里开始执行。",
			"main() {",
			"  var number = 42; // 声明并初始化一个变量。",
			"  printInteger(number); // 调用函数。",
			"}",
		],
	},
	"dt-字面量": {
		"prefix": "dt-字面量",
		"body": [
			"// 代码注释。",
			"单行注释。 Dart 同样支持多行注释和文档注释。 有关更多信息，参考 注释.",
			"",
			"int",
			"数据类型。一些其他 内置类型 包括 String , List , 和 bool 。",
			"",
			"42",
			"字面量。字面量是一种编译型常量。",
			"",
			"print()",
			"便利输出方式。",
			"",
			"'...' (or \"...\")",
			"字符串常量。",
			"",
			"$variableName (或 ${expression})",
			"字符串插值： 包括字符串文字内部的变量或表达式的字符串。 有关更多信息，参考 Strings.",
			"",
			"main()",
			"程序开始执行函数，该函数是特定的、必须的、顶级函数。 有关更多信息，参考 The main() function.",
			"",
			"var",
			"定义变量，通过这种方式定义变量不需要指定变量类型。",
			"",
			"提示： 本站的代码遵循 Dart 风格指南中的约定。 Dart 风格指南.",
		],
	},
	"dt-变量": {
		"prefix": "dt-变量",
		"body": [
			"创建一个变量并进行初始化:",
			"",
			"var name = 'Bob';",
			"变量仅存储对象引用，这里的变量是 name 存储了一个 String 类型的对象引用。 “Bob” 是这个 String 类型对象的值。",
			"",
			"name 变量的类型被推断为 String 。 但是也可以通过指定类型的方式，来改变变量类型。 如果对象不限定为单个类型，可以指定为 对象类型 或 动态类型， 参考 设计指南。",
			"",
			"dynamic name = 'Bob';",
			"另一种方式是显式声明可以推断出的类型：",
			"",
			"String name = 'Bob';",
		],
	},
	"dt-默认值": {
		"prefix": "dt-默认值",
		"body": [
			"未初始化的变量默认值是 null。即使变量是数字 类型默认值也是 null，因为在 Dart 中一切都是对象，数字类型 也不例外。",
			"",
			"int lineCount;",
			"assert(lineCount == null);",
			"提示： 在生产环境代码中 assert() 函数会被忽略，不会被调用。 在开发过程中, assert(condition) 会在非 true 的条件下抛出异常.有关更多信息，参考 Assert.",
		],
	},
	"dt-Final 和 Const": {
		"prefix": "dt-Final 和 Const",
		"body": [
			"使用过程中从来不会被修改的变量， 可以使用 final 或 const, 而不是 var 或者其他类型， Final 变量的值只能被设置一次； Const 变量在编译时就已经固定 (Const 变量 是隐式 Final 的类型.) 最高级 final 变量或类变量在第一次使用时被初始化。",
			"",
			"提示： 实例变量可以是 final 类型但不能是 const 类型。 必须在构造函数体执行之前初始化 final 实例变量 —— 在变量声明中，参数构造函数中或构造函数的初始化列表中进行初始化。",
			"",
			"创建和设置一个 Final 变量：",
			"",
			"final name = 'Bob'; // Without a type annotation",
			"final String nickname = 'Bobby';",
			"final 不能被修改:",
			"",
			"name = 'Alice'; // Error: 一个 final 变量只能被设置一次。",
			"如果需要在编译时就固定变量的值，可以使用 const 类型变量。 如果 Const 变量是类级别的，需要标记为 static const。 在这些地方可以使用在编译时就已经固定不变的值，字面量的数字和字符串， 固定的变量，或者是用于计算的固定数字：",
			"",
			"const bar = 1000000; // 压力单位 (dynes/cm2)",
			"const double atm = 1.01325 * bar; // 标准气压",
			"Const 关键字不仅可以用于声明常量变量。 还可以用来创建常量值，以及声明创建常量值的构造函数。 任何变量都可以拥有常量值。",
			"",
			"var foo = const [];",
			"final bar = const [];",
			"const baz = []; // Equivalent to `const []`",
			"声明 const 的初始化表达式中 const 可以被省略。 比如上面的 baz。 有关更多信息，参考 DON’T use const redundantly。",
			"",
			"非 Final ， 非 const 的变量是可以被修改的，即使这些变量 曾经引用过 const 值。",
			"",
			"foo = [1, 2, 3]; // 曾经引用过 const [] 常量值。",
			"Const 变量的值不可以修改：",
			"",
			"baz = [42]; // Error: 常量变量不能赋值修改。",
			"更多关于使用 const 创建常量值，参考 Lists， Maps， 和 Classes。",
		],
	},
	"dt-Dart 语言支持以下内建类型": {
		"prefix": "dt-Dart 语言支持以下内建类型",
		"body": [
			"Dart 语言支持以下内建类型：",
			"",
			"Number",
			"String",
			"Boolean",
			"List (也被称为 Array)",
			"Map",
			"Set",
			"Rune (用于在字符串中表示 Unicode 字符)",
			"Symbol",
			"这些类型都可以被初始化为字面量。 例如, 'this is a string' 是一个字符串的字面量， true 是一个布尔的字面量。",
			"",
			"因为在 Dart 所有的变量终究是一个对象（一个类的实例）， 所以变量可以使用 构造涵数 进行初始化。 一些内建类型拥有自己的构造函数。 例如， 通过 Map() 来构造一个 map 变量。",
		],
	},
	"dt-Number": {
		"prefix": "dt-Number",
		"body": [
			"Dart 语言的 Number 有两种类型:",
			"",
			"int",
			"整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -263 到 263 - 1. Dart 被编译为 JavaScript 时，使用 JavaScript numbers, 值的范围从 -253 到 253 - 1.",
			"",
			"double",
			"64位（双精度）浮点数，依据 IEEE 754 标准。",
			"",
			"int 和 double 都是 num. 的亚类型。 num 类型包括基本运算 +， -， /， 和 *， 以及 abs()， ceil()， 和 floor()， 等函数方法。 （按位运算符，例如»，定义在 int 类中。） 如果 num 及其亚类型找不到你想要的方法， 尝试查找使用 dart:math 库。",
			"",
			"整数类型不包含小数点。 下面是定义整数类型字面量的例子:",
			"",
			"var x = 1;",
			"var hex = 0xDEADBEEF;",
			"如果一个数字包含小数点，那么就是小数类型。 下面是定义小数类型字面量的例子:",
			"",
			"var y = 1.1;",
			"var exponents = 1.42e5;",
			"从 Dart 2.1 开始，必要的时候 int 字面量会自动转换成 double 类型。",
			"",
			"double z = 1; // 相当于 double z = 1.0.",
			"版本提示： 在 2.1 之前，在 double 上下文中使用 int 字面量是错误的。",
			"",
			"以下是将字符串转换为数字的方法，反之亦然：",
			"",
			"// String -> int",
			"var one = int.parse('1');",
			"assert(one == 1);",
			"",
			"// String -> double",
			"var onePointOne = double.parse('1.1');",
			"assert(onePointOne == 1.1);",
			"",
			"// int -> String",
			"String oneAsString = 1.toString();",
			"assert(oneAsString == '1');",
			"",
			"// double -> String",
			"String piAsString = 3.14159.toStringAsFixed(2);",
			"assert(piAsString == '3.14');",
			"int 特有的传统按位运算操作，移位（<<， >>），按位与（&）以及 按位或（|）。 例如：",
			"",
			"assert((3 << 1) == 6); // 0011 << 1 == 0110",
			"assert((3 >> 1) == 1); // 0011 >> 1 == 0001",
			"assert((3 | 4) == 7); // 0011 | 0100 == 0111",
			"数字类型字面量是编译时常量。 在算术表达式中，只要参与计算的因子是编译时常量， 那么算术表达式的结果也是编译时常量。",
			"",
			"const msPerSecond = 1000;",
			"const secondsUntilRetry = 5;",
			"const msUntilRetry = secondsUntilRetry * msPerSecond;",
		],
	},
	"dt-String": {
		"prefix": "dt-String",
		"body": [
			"Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。",
			"",
			"var s1 = 'Single quotes work well for string literals.';",
			"var s2 = \"Double quotes work just as well.\";",
			"var s3 = 'It\'s easy to escape the string delimiter.';",
			"var s4 = \"It's even easier to use the other delimiter.\";",
			"字符串可以通过 ${expression} 的方式内嵌表达式。 如果表达式是一个标识符，则 {} 可以省略。 在 Dart 中通过调用就对象的 toString() 方法来得到对象相应的字符串。",
			"",
			"var s = 'string interpolation';",
			"",
			"assert('Dart has $s, which is very handy.' ==",
			"    'Dart has string interpolation, ' +",
			"        'which is very handy.');",
			"assert('That deserves all caps. ' +",
			"        '${s.toUpperCase()} is very handy!' ==",
			"    'That deserves all caps. ' +",
			"        'STRING INTERPOLATION is very handy!');",
			"提示： == 运算符用来测试两个对象是否相等。 在字符串中，如果两个字符串包含了相同的编码序列，那么这两个字符串相等。 units.",
			"",
			"可以使用 + 运算符来把多个字符串连接为一个，也可以把多个字面量字符串写在一起来实现字符串连接：",
			"",
			"var s1 = 'String '",
			"    'concatenation'",
			"    \" works even over line breaks.\";",
			"assert(s1 ==",
			"    'String concatenation works even over '",
			"    'line breaks.');",
			"",
			"var s2 = 'The + operator ' + 'works, as well.';",
			"assert(s2 == 'The + operator works, as well.');",
			"使用连续三个单引号或者三个双引号实现多行字符串对象的创建：",
			"",
			"var s1 = '''",
			"You can create",
			"multi-line strings like this one.",
			"''';",
			"",
			"var s2 = \"\"\"This is also a",
			"multi-line string.\"\"\";",
			"使用 r 前缀，可以创建 “原始 raw” 字符串：",
			"",
			"var s = r\"In a raw string, even \n isn't special.\";",
			"// const 类型数据",
			"const aConstNum = 0;",
			"const aConstBool = true;",
			"const aConstString = 'a constant string';",
			"",
			"// 非 const 类型数据",
			"var aNum = 0;",
			"var aBool = true;",
			"var aString = 'a string';",
			"const aConstList = [1, 2, 3];",
			"",
			"const validConstString = '$aConstNum $aConstBool $aConstString'; //const 类型数据",
			"// const invalidConstString = '$aNum $aBool $aString $aConstList'; //非 const 类型数据",
		],
	},
	"dt-Boolean": {
		"prefix": "dt-Boolean",
		"body": [
			"Dart 使用 bool 类型表示布尔值。 Dart 只有字面量 true and false 是布尔类型， 这两个对象都是编译时常量。",
			"",
			"Dart 的类型安全意味着不能使用 if (nonbooleanValue) 或者 assert (nonbooleanValue)。 而是应该像下面这样，明确的进行值检查：",
			"",
			"// 检查空字符串。",
			"var fullName = '';",
			"assert(fullName.isEmpty);",
			"",
			"// 检查 0 值。",
			"var hitPoints = 0;",
			"assert(hitPoints <= 0);",
			"",
			"// 检查 null 值。",
			"var unicorn;",
			"assert(unicorn == null);",
			"",
			"// 检查 NaN 。",
			"var iMeantToDoThis = 0 / 0;",
			"assert(iMeantToDoThis.isNaN);",
		],
	},
	"dt-List": {
		"prefix": "dt-List",
		"body": [
			"几乎每种编程语言中最常见的集合可能是 array 或有序的对象集合。 在 Dart 中的 Array 就是 List 对象， 通常称之为 List 。",
			"",
			"Dart 中的 List 字面量非常像 JavaScript 中的 array 字面量。 下面是一个 Dart List 的示例：",
			"",
			"var list = [1, 2, 3];",
			"提示： Dart 推断 list 的类型为 List<int> 。 如果尝试将非整数对象添加到此 List 中， 则分析器或运行时会引发错误。 有关更多信息，请阅读 类型推断。",
			"",
			"Lists 的下标索引从 0 开始，第一个元素的索引是 0。 list.length - 1 是最后一个元素的索引。 访问 List 的长度和元素与 JavaScript 中的用法一样：",
			"",
			"var list = [1, 2, 3];",
			"assert(list.length == 3);",
			"assert(list[1] == 2);",
			"",
			"list[1] = 1;",
			"assert(list[1] == 1);",
			"在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量：",
			"",
			"var constantList = const [1, 2, 3];",
			"// constantList[1] = 1; // 取消注释会引起错误。",
			"List 类型包含了很多 List 的操作函数。 更多信息参考 泛型 和 集合.",
		],
	},
	"dt-Set": {
		"prefix": "dt-Set",
		"body": [
			"在 Dart 中 Set 是一个元素唯一且无需的集合。 Dart 为 Set 提供了 Set 字面量和 Set 类型。",
			"",
			"版本提示： 虽然 Set 类型 一直是 Dart 的核心部分， 但在 Dart2.2 中才引入了 Set 字面量 。",
			"",
			"下面是通过字面量创建 Set 的一个简单示例：",
			"",
			"var halogens = {'fluorine', 'chlorine', 'bromine', 'iodine', 'astatine'};",
			"Note: Dart 推断 halogens 类型为 Set<String> 。如果尝试为它添加一个 错误类型的值，分析器或执行时会抛出错误。更多内容，参阅 类型推断。",
			"",
			"要创建一个空集，使用前面带有类型参数的 {} ，或者将 {} 赋值给 Set 类型的变量：",
			"",
			"var names = <String>{};",
			"// Set<String> names = {}; // 这样也是可以的。",
			"// var names = {}; // 这样会创建一个 Map ，而不是 Set 。",
			"是 Set 还是 Map ？ Map 字面量语法同 Set 字面量语法非常相似。 因为先有的 Map 字母量语法，所以 {} 默认是 Map 类型。   如果忘记在 {} 上注释类型或赋值到一个未声明类型的变量上，   那么 Dart 会创建一个类型为 Map<dynamic, dynamic> 的对象。",
			"",
			"使用 add() 或 addAll() 为已有的 Set 添加元素：",
			"",
			"var elements = <String>{};",
			"elements.add('fluorine');",
			"elements.addAll(halogens);",
			"使用 .length 来获取 Set 中元素的个数：",
			"",
			"var elements = <String>{};",
			"elements.add('fluorine');",
			"elements.addAll(halogens);",
			"assert(elements.length == 5);",
			"在 Set 字面量前增加 const ，来创建一个编译时 Set 常量：",
			"",
			"final constantSet = const {",
			"  'fluorine',",
			"  'chlorine',",
			"  'bromine',",
			"  'iodine',",
			"  'astatine',",
			"};",
			"// constantSet.add('helium'); // Uncommenting this causes an error.",
			"更多关于 Set 的内容，参阅 Generic 及 Set。",
		],
	},
	"dt-因为在 Dart 2 中，new 关键字是可选的": {
		"prefix": "dt-因为在 Dart 2 中，new 关键字是可选的",
		"body": [],
	},
	"dt-Map": {
		"prefix": "dt-Map",
		"body": [
			"通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。 Dart 中 Map 通过 Map 字面量 和 Map 类型来实现。",
			"",
			"下面是使用 Map 字面量的两个简单例子：",
			"",
			"var gifts = {",
			"  // Key:    Value",
			"  'first': 'partridge',",
			"  'second': 'turtledoves',",
			"  'fifth': 'golden rings'",
			"};",
			"",
			"var nobleGases = {",
			"  2: 'helium',",
			"  10: 'neon',",
			"  18: 'argon',",
			"};",
			"提示： Dart 会将 gifts 的类型推断为 Map<String, String>， nobleGases 的类型推断为 Map<int, String> 。 如果尝试在上面的 map 中添加错误类型，那么分析器或者运行时会引发错误。 有关更多信息，请阅读类型推断。。",
			"",
			"以上 Map 对象也可以使用 Map 构造函数创建：",
			"",
			"var gifts = Map();",
			"gifts['first'] = 'partridge';",
			"gifts['second'] = 'turtledoves';",
			"gifts['fifth'] = 'golden rings';",
			"",
			"var nobleGases = Map();",
			"nobleGases[2] = 'helium';",
			"nobleGases[10] = 'neon';",
			"nobleGases[18] = 'argon';",
			"提示: 这里为什么只有 Map() ，而不是使用 new Map()。 因为在 Dart 2 中，new 关键字是可选的。 有关更多信息，参考 构造函数的使用。",
			"",
			"类似 JavaScript ，添加 key-value 对到已有的 Map 中：",
			"",
			"var gifts = {'first': 'partridge'};",
			"gifts['fourth'] = 'calling birds'; // Add a key-value pair",
			"类似 JavaScript ，从一个 Map 中获取一个 value：",
			"",
			"var gifts = {'first': 'partridge'};",
			"assert(gifts['first'] == 'partridge');",
			"如果 Map 中不包含所要查找的 key，那么 Map 返回 null：",
			"",
			"var gifts = {'first': 'partridge'};",
			"assert(gifts['fifth'] == null);",
			"使用 .length 函数获取当前 Map 中的 key-value 对数量：",
			"",
			"var gifts = {'first': 'partridge'};",
			"gifts['fourth'] = 'calling birds';",
			"assert(gifts.length == 2);",
			"创建 Map 类型运行时常量，要在 Map 字面量前加上关键字 const。",
			"",
			"final constantMap = const {",
			"  2: 'helium',",
			"  10: 'neon',",
			"  18: 'argon',",
			"};",
			"",
			"// constantMap[2] = 'Helium'; // 取消注释会引起错误。",
			"更名多关于 Map 的内容，参考 Generics and Maps.",
		],
	},
	"dt-Symbol": {
		"prefix": "dt-Symbol",
		"body": [
			"一个 Symbol 对象表示 Dart 程序中声明的运算符或者标识符。 你也许永远都不需要使用 Symbol ，但要按名称引用标识符的 API 时， Symbol 就非常有用了。 因为代码压缩后会改变标识符的名称，但不会改变标识符的符号。 通过字面量 Symbol ，也就是标识符前面添加一个 # 号，来获取标识符的 Symbol 。",
			"",
			"#radix",
			"#bar",
			"Symbol 字面量是编译时常量。",
		],
	},
	"dt-函数": {
		"prefix": "dt-函数",
		"body": [
			"Dart 是一门真正面向对象的语言， 甚至其中的函数也是对象，并且有它的类型 Function 。 这也意味着函数可以被赋值给变量或者作为参数传递给其他函数。 也可以把 Dart 类的实例当做方法来调用。 有关更多信息，参考 Callable classes.",
			"",
			"已下是函数实现的示例：",
			"",
			"bool isNoble(int atomicNumber) {",
			"  return _nobleGases[atomicNumber] != null;",
			"}",
			"虽然在 Effective Dart 中推荐 公共API中声明类型, 但是省略了类型声明，函数依旧是可以正常使用的：",
			"",
			"isNoble(atomicNumber) {",
			"  return _nobleGases[atomicNumber] != null;",
			"}",
			"如果函数中只有一句表达式，可以使用简写语法：",
			"",
			"bool isNoble(int atomicNumber) => _nobleGases[atomicNumber] != null;",
			"=> expr 语法是 { return expr; } 的简写。 => 符号 有时也被称为 箭头 语法。",
			"",
			"提示： 在箭头 (=>) 和分号 (;) 之间只能使用一个 表达式 ，不能是 语句 。 例如：不能使用 if 语句 ，但是可以是用 条件表达式.",
			"",
			"函数有两种参数类型: required 和 optional。 required 类型参数在参数最前面， 随后是 optional 类型参数。 命名的可选参数也可以标记为 “@ required” 。 参考下一章节，了解更多细节。",
		],
	},
	"dt-命名可选参数": {
		"prefix": "dt-命名可选参数",
		"body": [
			"命名可选参数",
			"调用函数时，可以使用指定命名参数 paramName: value。 例如：",
			"",
			"enableFlags(bold: true, hidden: false);",
			"定义函数是，使用 {param1, param2, …} 来指定命名参数：",
			"",
			"/// Sets the [bold] and [hidden] flags ...",
			"void enableFlags({bool bold, bool hidden}) {...}",
			"Flutter 创建实例的表达式可能很复杂， 因此窗口小部件构造函数仅使用命名参数。 这样创建实例的表达式更易于阅读。",
			"",
			"使用 @required 注释表示参数是 required 性质的命名参数， 该方式可以在任何 Dart 代码中使用（不仅仅是Flutter）。",
			"",
			"const Scrollbar({Key key, @required Widget child})",
			"此时 Scrollbar 是一个构造函数， 当 child 参数缺少时，分析器会提示错误。",
			"",
			"Required 被定义在 meta package。 无论是直接引入（import） package:meta/meta.dart ，或者引入了其他 package，而这个 package 输出（export）了 meta，比如 Flutter 的 package:flutter/material.dart。",
		],
	},
	"dt-位置可选参数": {
		"prefix": "dt-位置可选参数",
		"body": [
			"将参数放到 [] 中来标记参数是可选的：",
			"",
			"String say(String from, String msg, [String device]) {",
			"  var result = '$from says $msg';",
			"  if (device != null) {",
			"    result = '$result with a $device';",
			"  }",
			"  return result;",
			"}",
			"下面是不使用可选参数调用上面方法 的示例：",
			"",
			"assert(say('Bob', 'Howdy') == 'Bob says Howdy');",
			"下面是使用可选参数调用上面方法的示例：",
			"",
			"assert(say('Bob', 'Howdy', 'smoke signal') ==",
			"    'Bob says Howdy with a smoke signal');",
		],
	},
	"dt-默认参数值": {
		"prefix": "dt-默认参数值",
		"body": [
			"在定义方法的时候，可以使用 = 来定义可选参数的默认值。 默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。",
			"",
			"下面是设置可选参数默认值示例：",
			"",
			"/// 设置 [bold] 和 [hidden] 标志 ...",
			"void enableFlags({bool bold = false, bool hidden = false}) {...}",
			"",
			"// bold 值为 true; hidden 值为 false.",
			"enableFlags(bold: true);",
			"不推荐： 旧版本代码中可能使用的是冒号 (:) 而不是 = 来设置参数默认值。 原因是起初命名参数只支持 : 。 这种支持可能会被弃用。 建议 使用 = 指定默认值。",
			"",
			"下面示例演示了如何为位置参数设置默认值：",
			"",
			"String say(String from, String msg,",
			"    [String device = 'carrier pigeon', String mood]) {",
			"  var result = '$from says $msg';",
			"  if (device != null) {",
			"    result = '$result with a $device';",
			"  }",
			"  if (mood != null) {",
			"    result = '$result (in a $mood mood)';",
			"  }",
			"  return result;",
			"}",
			"",
			"assert(say('Bob', 'Howdy') ==",
			"    'Bob says Howdy with a carrier pigeon');",
			"list 或 map 可以作为默认值传递。 下面的示例定义了一个方法 doStuff()， 并分别指定参数 list 和 gifts 的默认值。",
			"",
			"void doStuff(",
			"    {List<int> list = const [1, 2, 3],",
			"    Map<String, String> gifts = const {",
			"      'first': 'paper',",
			"      'second': 'cotton',",
			"      'third': 'leather'",
			"    }}) {",
			"  print('list:  $list');",
			"  print('gifts: $gifts');",
			"}",
		],
	},
	"dt-main() 函数": {
		"prefix": "dt-main() 函数",
		"body": [
			"任何应用都必须有一个顶级 main() 函数，作为应用服务的入口。 main() 函数返回值为空，参数为一个可选的 List<String> 。",
			"",
			"下面是 web 应用的 main() 函数：",
			"",
			"void main() {",
			"  querySelector('#sample_text_id')",
			"    ..text = 'Click me!'",
			"    ..onClick.listen(reverseText);",
			"}",
			"提示：",
			"",
			"以上代码中的 .. 语法为 级联调用 （cascade）。 使用级联调用， 可以简化在一个对象上执行的多个操作。",
			"",
			"下面是一个命令行应用的 main() 方法，并且使用了输入参数：",
			"",
			"// 这样运行应用： dart args.dart 1 test",
			"void main(List<String> arguments) {",
			"  print(arguments);",
			"",
			"  assert(arguments.length == 2);",
			"  assert(int.parse(arguments[0]) == 1);",
			"  assert(arguments[1] == 'test');",
			"}",
			"使用 args library 可以定义和解析命令行参数。",
		],
	},
	"dt-函数是一等对象": {
		"prefix": "dt-函数是一等对象",
		"body": [
			"一个函数可以作为另一个函数的参数。 例如：",
			"",
			"void printElement(int element) {",
			"  print(element);",
			"}",
			"",
			"var list = [1, 2, 3];",
			"",
			"// 将 printElement 函数作为参数传递。",
			"list.forEach(printElement);",
			"同样可以将一个函数赋值给一个变量，例如：",
			"",
			"var loudify = (msg) => '!!! ${msg.toUpperCase()} !!!';",
			"assert(loudify('hello') == '!!! HELLO !!!');",
			"示例中使用了匿名函数。 下一章节会有更多介绍。",
		],
	},
	"dt-级联调用 （cascade）": {
		"prefix": "dt-级联调用 （cascade）",
		"body": [
			"void main() {",
			"  querySelector('#sample_text_id')",
			"    ..text = 'Click me!'",
			"    ..onClick.listen(reverseText);",
			"}",
		],
	},
	"dt-匿名函数": {
		"prefix": "dt-匿名函数",
		"body": [
			"多数函数是有名字的， 比如 main() 和 printElement()。 也可以创建没有名字的函数，这种函数被称为 匿名函数， 有时候也被称为 lambda 或者 closure 。 匿名函数可以赋值到一个变量中， 举个例子，在一个集合中可以添加或者删除一个匿名函数。",
			"",
			"匿名函数和命名函数看起来类似— 在括号之间可以定义一些参数或可选参数，参数使用逗号分割。",
			"",
			"后面大括号中的代码为函数体：",
			"",
			"([[Type] param1[, …]]) {",
			"  codeBlock;",
			"};",
			"",
			"下面例子中定义了一个包含一个无类型参数 item 的匿名函数。 list 中的每个元素都会调用这个函数，打印元素位置和值的字符串。",
			"",
			"var list = ['apples', 'bananas', 'oranges'];",
			"list.forEach((item) {",
			"  print('${list.indexOf(item)}: $item');",
			"})",
			"如果函数只有一条语句， 可以使用箭头简写。粘贴下面代码到 DartPad 中 并点击运行按钮，验证两个函数是等价性。",
			"",
			"list.forEach(",
			"    (item) => print('${list.indexOf(item)}: $item'));",
		],
	},
	"dt-词法作用域": {
		"prefix": "dt-词法作用域",
		"body": [
			"Dart 是一门词法作用域的编程语言，就意味着变量的作用域是固定的， 简单说变量的作用域在编写代码的时候就已经确定了。 花括号内的是变量可见的作用域。",
			"",
			"下面示例关于多个嵌套函数的变量作用域：",
			"",
			"bool topLevel = true;",
			"",
			"void main() {",
			"  var insideMain = true;",
			"",
			"  void myFunction() {",
			"    var insideFunction = true;",
			"",
			"    void nestedFunction() {",
			"      var insideNestedFunction = true;",
			"",
			"      assert(topLevel);",
			"      assert(insideMain);",
			"      assert(insideFunction);",
			"      assert(insideNestedFunction);",
			"    }",
			"  }",
			"}",
		],
	},
	"dt-词法闭包": {
		"prefix": "dt-词法闭包",
		"body": [
			"闭包 即一个函数对象，即使函数对象的调用在它原始作用域之外， 依然能够访问在它词法作用域内的变量。",
			"",
			"函数可以封闭定义到它作用域内的变量。 接下来的示例中， makeAdder() 捕获了变量 addBy。 无论在什么时候执行返回函数，函数都会使用捕获的 addBy 变量。",
			"",
			"/// 返回一个函数，返回的函数参数与 [addBy] 相加。",
			"Function makeAdder(num addBy) {",
			"  return (num i) => addBy + i;",
			"}",
			"",
			"void main() {",
			"  // 创建一个加 2 的函数。",
			"  var add2 = makeAdder(2);",
			"",
			"  // 创建一个加 4 的函数。",
			"  var add4 = makeAdder(4);",
			"",
			"  assert(add2(3) == 5);",
			"  assert(add4(3) == 7);",
			"}",
		],
	},
	"dt-返回值": {
		"prefix": "dt-返回值",
		"body": [
			"所有函数都会返回一个值。 如果没有明确指定返回值， 函数体会被隐式的添加 return null; 语句。",
			"",
			"foo() {}",
			"",
			"assert(foo() == null);",
		],
	},
	"dt-运算符": {
		"prefix": "dt-运算符",
		"body": [
			"下表是 Dart 定义的运算符。 多数运算符可以被重载，详情参考 重写运算符。",
			"",
			"Description Operator",
			"unary postfix expr++    expr--    ()    []    .    ?.",
			"unary prefix -expr    !expr    ~expr    ++expr    --expr   ",
			"multiplicative *    /    %  ~/",
			"additive +    -",
			"shift <<    >>    >>>",
			"bitwise AND &",
			"bitwise XOR ^",
			"bitwise OR  |",
			"relational and type test >=    >    <=    <    as    is    is!",
			"equality ==    !=   ",
			"logical AND &&",
			"logical OR ||",
			"if null ??",
			"conditional expr1 ? expr2 : expr3",
			"cascade   ..",
			"assignment = *=    /=   +=   -=   &=   ^=   etc.",
			"提示： 上述表格中描述的运算符优先级近似于Dart 解析器实际行为。 更准确的描述，请参阅 Dart language specification 中的语法。",
			"",
			"创建表达式的时候会用到运算符。 下面是一些运算符表达式的实例：",
			"",
			"a++",
			"a + b",
			"a = b",
			"a == b",
			"c ? a : b",
			"a is T",
			"在 运算符表 中， 每一行的运算符优先级，由上到下依次排列，第一行优先级最高，最后一行优先级最低。 例如 % 运算符优先级高于 == ， 而 == 高于 &&。 根据优先级规则，那么意味着以下两行代码执行的方式相同：",
			"",
			"// 括号可以提高可读性。",
			"if ((n % i == 0) && (d % i == 0)) ...",
			"",
			"// 可读性差，但是是等效的。",
			"if (n % i == 0 && d % i == 0) ...",
			"警告： 对于有两个操作数的运算符，运算符的功能由左边的操作数决定。 例如, 如果有两个操作数 Vector 和 Point， aVector + aPoint 使用的是 Vector 中定义的 + 运算符。",
		],
	},
	"dt-算术运算符": {
		"prefix": "dt-算术运算符",
		"body": [
			"assert(2 + 3 == 5);",
			"assert(2 - 3 == -1);",
			"assert(2 * 3 == 6);",
			"assert(5 / 2 == 2.5); // 结果是双浮点型",
			"assert(5 ~/ 2 == 2); // 结果是整型",
			"assert(5 % 2 == 1); // 余数",
			"",
			"assert('5/2 = ${5 ~/ 2} r ${5 % 2}' == '5/2 = 2 r 1');",
		],
	},
	"dt-Dart 还支持前缀和后缀，自增和自减运算符": {
		"prefix": "dt-Dart 还支持前缀和后缀，自增和自减运算符",
		"body": [
			"var a, b;",
			"",
			"a = 0;",
			"b = ++a; // a自加后赋值给b。",
			"assert(a == b); // 1 == 1",
			"",
			"a = 0;",
			"b = a++; // a先赋值给b后，a自加。",
			"assert(a != b); // 1 != 0",
			"",
			"a = 0;",
			"b = --a; // a自减后赋值给b。",
			"assert(a == b); // -1 == -1",
			"",
			"a = 0;",
			"b = a--; // a先赋值给b后，a自减。",
			"assert(a != b); // -1 != 0",
		],
	},
	"dt-关系运算符": {
		"prefix": "dt-关系运算符",
		"body": [
			"assert(2 == 2);",
			"assert(2 != 3);",
			"assert(3 > 2);",
			"assert(2 < 3);",
			"assert(3 >= 3);",
			"assert(2 <= 3);",
		],
	},
	"dt-as， is， 和 is! 运算符": {
		"prefix": "dt-as， is， 和 is! 运算符",
		"body": [
			"使用 as 运算符将对象强制转换为特定类型。 通常，可以认为是 is 类型判定后，被判定对象调用函数的一种缩写形式。 请考虑以下代码：",
			"",
			"if (emp is Person) {",
			"  // Type check",
			"  emp.firstName = 'Bob';",
			"}",
			"使用 as 运算符进行缩写：",
			"",
			"(emp as Person).firstName = 'Bob';",
			"提示： 以上代码并不是等价的。 如果 emp 为 null 或者不是 Person 对象， 那么第一个 is 的示例，后面将不回执行； 第二个 as 的示例会抛出异常。",
		],
	},
	"dt-赋值运算符": {
		"prefix": "dt-赋值运算符",
		"body": [
			"使用 = 为变量赋值。 使用 ??= 运算符时，只有当被赋值的变量为 null 时才会赋值给它。",
			"",
			"// 将值赋值给变量a",
			"a = value;",
			"// 如果b为空时，将变量赋值给b，否则，b的值保持不变。",
			"b ??= value;",
			"复合赋值运算符（如 += ）将算术运算符和赋值运算符组合在了一起。",
			"",
			"以下示例使用赋值和复合赋值运算符：",
			"",
			"var a = 2; // 使用 = 复制",
			"a *= 3; // 复制并做乘法运算： a = a * 3",
			"assert(a == 6);",
		],
	},
	"dt-逻辑运算符": {
		"prefix": "dt-逻辑运算符",
		"body": [
			"if (!done && (col == 0 || col == 3)) {",
			"  // ...Do something...",
			"}",
		],
	},
	"dt-按位和移位运算符": {
		"prefix": "dt-按位和移位运算符",
		"body": [
			"final value = 0x22;",
			"final bitmask = 0x0f;",
			"",
			"assert((value & bitmask) == 0x02); // AND",
			"assert((value & ~bitmask) == 0x20); // AND NOT",
			"assert((value | bitmask) == 0x2f); // OR",
			"assert((value ^ bitmask) == 0x2d); // XOR",
			"assert((value << 4) == 0x220); // Shift left",
			"assert((value >> 4) == 0x02); // Shift right",
		],
	},
	"dt-条件表达式": {
		"prefix": "dt-条件表达式 ?:  ??",
		"body": [
			"Dart有两个运算符，有时可以替换 if-else 表达式， 让表达式更简洁：",
			"",
			"condition ? expr1 : expr2",
			"如果条件为 true, 执行 expr1 (并返回它的值)： 否则, 执行并返回 expr2 的值。",
			"expr1 ?? expr2",
			"如果 expr1 是 non-null， 返回 expr1 的值； 否则, 执行并返回 expr2 的值。",
			"如果赋值是根据布尔值， 考虑使用 ?:。",
			"",
			"var visibility = isPublic ? 'public' : 'private';",
			"如果赋值是基于判定是否为 null， 考虑使用 ??。",
			"",
			"String playerName(String name) => name ?? 'Guest';",
			"下面给出了其他两种实现方式， 但并不简洁：",
			"",
			"// Slightly longer version uses ?: operator.",
			"String playerName(String name) => name != null ? name : 'Guest';",
			"",
			"// Very long version uses if-else statement.",
			"String playerName(String name) {",
			"  if (name != null) {",
			"    return name;",
			"  } else {",
			"    return 'Guest';",
			"  }",
			"}",
		],
	},
	"dt-级联运算符 (..)": {
		"prefix": "dt-级联运算符 (..)",
		"body": [
			"级联运算符 (..) 可以实现对同一个对像进行一系列的操作。 除了调用函数， 还可以访问同一对象上的字段属性。 这通常可以节省创建临时变量的步骤， 同时编写出更流畅的代码。",
			"",
			"考虑一下代码：",
			"",
			"querySelector('#confirm') // 获取对象。",
			"  ..text = 'Confirm' // 调用成员变量。",
			"  ..classes.add('important')",
			"  ..onClick.listen((e) => window.alert('Confirmed!'));",
			"第一句调用函数 querySelector() ， 返回获取到的对象。 获取的对象依次执行级联运算符后面的代码， 代码执行后的返回值会被忽略。",
			"",
			"上面的代码等价于：",
			"",
			"var button = querySelector('#confirm');",
			"button.text = 'Confirm';",
			"button.classes.add('important');",
			"button.onClick.listen((e) => window.alert('Confirmed!'));",
			"级联运算符可以嵌套，例如：",
			"",
			"final addressBook = (AddressBookBuilder()",
			"      ..name = 'jenny'",
			"      ..email = 'jenny@example.com'",
			"      ..phone = (PhoneNumberBuilder()",
			"            ..number = '415-555-0100'",
			"            ..label = 'home')",
			"          .build())",
			"    .build();",
			"在返回对象的函数中谨慎使用级联操作符。 例如，下面的代码是错误的：",
			"",
			"var sb = StringBuffer();",
			"sb.write('foo')",
			"  ..write('bar'); // Error: 'void' 没哟定义 'write' 函数。",
			"sb.write() 函数调用返回 void， 不能在 void 对象上创建级联操作。",
			"",
			"提示： 严格的来讲， “两个点” 的级联语法不是一个运算符。 它只是一个 Dart 的特殊语法。",
		],
	},
	"dt-其他运算符": {
		"prefix": "dt-其他运算符",
		"body": [
			"?. Conditional member access Like ., but the leftmost operand can be null; example: foo?.bar selects property bar from expression foo unless foo is null (in which case the value of foo?.bar is null)",
		],
	},
	"dt-控制流程语句": {
		"prefix": "dt-控制流程语句",
		"body": [
			"你可以通过下面任意一种方式来控制 Dart 程序流程：",
			"",
			"if and else",
			"",
			"for loops",
			"",
			"while and do-while loops",
			"",
			"break and continue",
			"",
			"switch and case",
			"",
			"assert",
			"",
			"使用 try-catch 和 throw 也可以改变程序流程， 详见 Exceptions。",
		],
	},
	"dt-if 和 else": {
		"prefix": "dt-if 和 else",
		"body": [
			"if (isRaining()) {",
			"  you.bringRainCoat();",
			"} else if (isSnowing()) {",
			"  you.wearJacket();",
			"} else {",
			"  car.putTopDown();",
			"}",
			"和 JavaScript 不同， Dart 的判断条件必须是布尔值，不能是其他类型。 更多信息，参考 Booleans 。",
		],
	},
	"dt-for 循环": {
		"prefix": "dt-for 循环",
		"body": [
			"进行迭代操作，可以使用标准 for 语句。 例如：",
			"",
			"var message = StringBuffer('Dart is fun');",
			"for (var i = 0; i < 5; i++) {",
			"  message.write('!');",
			"}",
			"闭包在 Dart 的 for 循环中会捕获循环的 index 索引值， 来避免 JavaScript 中常见的陷阱。 请思考示例代码：",
			"var callbacks = [];",
			"for (var i = 0; i < 2; i++) {",
			"  callbacks.add(() => print(i));",
			"}",
			"callbacks.forEach((c) => c());",
			"和期望一样，输出的是 0 和 1。 但是示例中的代码在 JavaScript 中会连续输出两个 2 。",
			"",
			"I如果要迭代一个实现了 Iterable 接口的对象， 可以使用 forEach() 方法， 如果不需要使用当前计数值， 使用 forEach() 是非常棒的选择；",
			"",
			"candidates.forEach((candidate) => candidate.interview());",
			"实现了 Iterable 的类（比如， List 和 Set）同样也支持使用 for-in 进行迭代操作 iteration ：",
			"",
			"var collection = [0, 1, 2];",
			"for (var x in collection) {",
			"  print(x); // 0 1 2",
			"}",
		],
	},
	"dt-while 和 do-while": {
		"prefix": "dt-while 和 do-while",
		"body": [
			"while 循环在执行前判断执行条件：",
			"",
			"while (!isDone()) {",
			"  doSomething();",
			"}",
			"do-while 循环在执行后判断执行条件：",
			"",
			"do {",
			"  printLine();",
			"} while (!atEndOfPage());",
		],
	},
	"dt-break 和 continue": {
		"prefix": "dt-break 和 continue",
		"body": [
			"使用 break 停止程序循环：",
			"",
			"while (true) {",
			"  if (shutDownRequested()) break;",
			"  processIncomingRequests();",
			"}",
			"使用 continue 跳转到下一次迭代：",
			"",
			"for (int i = 0; i < candidates.length; i++) {",
			"  var candidate = candidates[i];",
			"  if (candidate.yearsExperience < 5) {",
			"    continue;",
			"  }",
			"  candidate.interview();",
			"}",
			"如果对象实现了 Iterable 接口 （例如，list 或者 set）。 那么上面示例完全可以用另一种方式来实现：",
			"",
			"candidates",
			"    .where((c) => c.yearsExperience >= 5)",
			"    .forEach((c) => c.interview());",
		],
	},
	"dt-switch 和 case": {
		"prefix": "dt-switch 和 case",
		"body": [
			"在 Dart 中 switch 语句使用 == 比较整数，字符串，或者编译时常量。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 == 重写。 枚举类型 可以用于 switch 语句。",
			"",
			"提示： 在 Dart 中 Switch 语句仅适用于有限的情况下， 例如在 interpreter 或 scanner 中。",
			"",
			"在 case 语句中，每个非空的 case 语句结尾需要跟一个 break 语句。 除 break 以外，还有可以使用 continue, throw，者 return。",
			"",
			"当没有 case 语句匹配时，执行 default 代码：",
			"",
			"var command = 'OPEN';",
			"switch (command) {",
			"  case 'CLOSED':",
			"    executeClosed();",
			"    break;",
			"  case 'PENDING':",
			"    executePending();",
			"    break;",
			"  case 'APPROVED':",
			"    executeApproved();",
			"    break;",
			"  case 'DENIED':",
			"    executeDenied();",
			"    break;",
			"  case 'OPEN':",
			"    executeOpen();",
			"    break;",
			"  default:",
			"    executeUnknown();",
			"}",
			"下面的 case 程序示例中缺省了 break 语句，导致错误：",
			"",
			"var command = 'OPEN';",
			"switch (command) {",
			"  case 'OPEN':",
			"    executeOpen();",
			"    // ERROR: 丢失 break",
			"",
			"  case 'CLOSED':",
			"    executeClosed();",
			"    break;",
			"}",
			"但是， Dart 支持空 case 语句， 允许程序以 fall-through 的形式执行。",
			"",
			"var command = 'CLOSED';",
			"switch (command) {",
			"  case 'CLOSED': // Empty case falls through.",
			"  case 'NOW_CLOSED':",
			"    // Runs for both CLOSED and NOW_CLOSED.",
			"    executeNowClosed();",
			"    break;",
			"}",
			"在非空 case 中实现 fall-through 形式， 可以使用 continue 语句结合 lable 的方式实现:",
			"",
			"var command = 'CLOSED';",
			"switch (command) {",
			"  case 'CLOSED':",
			"    executeClosed();",
			"    continue nowClosed;",
			"  // Continues executing at the nowClosed label.",
			"",
			"  nowClosed:",
			"  case 'NOW_CLOSED':",
			"    // Runs for both CLOSED and NOW_CLOSED.",
			"    executeNowClosed();",
			"    break;",
			"}",
			"case 语句可以拥有局部变量， 这些局部变量只能在这个语句的作用域中可见。",
		],
	},
	"dt-assert": {
		"prefix": "dt-assert",
		"body": [
			"如果 assert 语句中的布尔条件为 false ， 那么正常的程序执行流程会被中断。 在本章中包含部分 assert 的使用， 下面是一些示例：",
			"",
			"// 确认变量值不为空。",
			"assert(text != null);",
			"",
			"// 确认变量值小于100。",
			"assert(number < 100);",
			"",
			"// 确认 URL 是否是 https 类型。",
			"assert(urlString.startsWith('https'));",
			"提示： assert 语句只在开发环境中有效， 在生产环境是无效的； Flutter 中的 assert 只在 debug 模式 中有效。 开发用的工具，例如 dartdevc 默认是开启 assert 功能。 其他的一些工具， 例如 dart 和 dart2js, 支持通过命令行开启 assert ： --enable-asserts。",
			"",
			"assert 的第二个参数可以为其添加一个字符串消息。",
			"",
			"assert(urlString.startsWith('https'),",
			"    'URL ($urlString) should start with \"https\".');",
			"assert 的第一个参数可以是解析为布尔值的任何表达式。 如果表达式结果为 true ， 则断言成功，并继续执行。 如果表达式结果为 false ， 则断言失败，并抛出异常 (AssertionError) 。",
		],
	},
	"dt-异常": {
		"prefix": "dt-异常",
		"body": [
			"Dart 代码可以抛出和捕获异常。 异常表示一些未知的错误情况。 如果异常没有被捕获， 则异常会抛出， 导致抛出异常的代码终止执行。",
			"",
			"和 Java 有所不同， Dart 中的所有异常是非检查异常。 方法不会声明它们抛出的异常， 也不要求捕获任何异常。",
			"",
			"Dart 提供了 Exception 和 Error 类型， 以及一些子类型。 当然也可以定义自己的异常类型。 但是，此外 Dart 程序可以抛出任何非 null 对象， 不仅限 Exception 和 Error 对象。",
			"",
			"throw",
			"下面是关于抛出或者 引发 异常的示例：",
			"",
			"throw FormatException('Expected at least 1 section');",
			"也可以抛出任意的对象：",
			"",
			"throw 'Out of llamas!';",
			"提示： 高质量的生产环境代码通常会实现 Error 或 Exception 类型的异常抛出。",
			"",
			"因为抛出异常是一个表达式， 所以可以在 => 语句中使用，也可以在其他使用表达式的地方抛出异常：",
			"",
			"void distanceTo(Point other) => throw UnimplementedError();",
			"catch",
			"捕获异常可以避免异常继续传递（除非重新抛出（ rethrow ）异常）。 可以通过捕获异常的机会来处理该异常：",
			"",
			"try {",
			"  breedMoreLlamas();",
			"} on OutOfLlamasException {",
			"  buyMoreLlamas();",
			"}",
			"通过指定多个 catch 语句，可以处理可能抛出多种类型异常的代码。 与抛出异常类型匹配的第一个 catch 语句处理异常。 如果 catch 语句未指定类型， 则该语句可以处理任何类型的抛出对象：",
			"",
			"try {",
			"  breedMoreLlamas();",
			"} on OutOfLlamasException {",
			"  // 一个特殊的异常",
			"  buyMoreLlamas();",
			"} on Exception catch (e) {",
			"  // 其他任何异常",
			"  print('Unknown exception: $e');",
			"} catch (e) {",
			"  // 没有指定的类型，处理所有异常",
			"  print('Something really unknown: $e');",
			"}",
			"如上述代码所示，捕获语句中可以同时使用 on 和 catch ，也可以单独分开使用。 使用 on 来指定异常类型， 使用 catch 来 捕获异常对象。",
			"",
			"catch() 函数可以指定1到2个参数， 第一个参数为抛出的异常对象， 第二个为堆栈信息 ( 一个 StackTrace 对象 )。",
			"",
			"try {",
			"  // ···",
			"} on Exception catch (e) {",
			"  print('Exception details:\n $e');",
			"} catch (e, s) {",
			"  print('Exception details:\n $e');",
			"  print('Stack trace:\n $s');",
			"}",
			"如果仅需要部分处理异常， 那么可以使用关键字 rethrow 将异常重新抛出。",
			"",
			"void misbehave() {",
			"  try {",
			"    dynamic foo = true;",
			"    print(foo++); // Runtime error",
			"  } catch (e) {",
			"    print('misbehave() partially handled ${e.runtimeType}.');",
			"    rethrow; // Allow callers to see the exception.",
			"  }",
			"}",
			"",
			"void main() {",
			"  try {",
			"    misbehave();",
			"  } catch (e) {",
			"    print('main() finished handling ${e.runtimeType}.');",
			"  }",
			"}",
			"finally",
			"不管是否抛出异常， finally 中的代码都会被执行。 如果 catch 没有匹配到异常， 异常会在 finally 执行完成后，再次被抛出：",
			"",
			"try {",
			"  breedMoreLlamas();",
			"} finally {",
			"  // Always clean up, even if an exception is thrown.",
			"  cleanLlamaStalls();",
			"}",
			"任何匹配的 catch 执行完成后，再执行 finally ：",
			"",
			"try {",
			"  breedMoreLlamas();",
			"} catch (e) {",
			"  print('Error: $e'); // Handle the exception first.",
			"} finally {",
			"  cleanLlamaStalls(); // Then clean up.",
			"}",
			"更多详情，请参考 Exceptions 章节。",
		],
	},
	"dt-所有的类都继承于 Object.": {
		"prefix": "dt-所有的类都继承于 Object.",
		"body": [
			"Dart 是一种基于类和 mixin 继承机制的面向对象的语言。 每个对象都是一个类的实例，所有的类都继承于 Object. 。 基于 * Mixin 继承* 意味着每个类（除 Object 外） 都只有一个超类， 一个类中的代码可以在其他多个继承类中重复使用。",
		],
	},
	"dt-使用类的成员变量": {
		"prefix": "dt-使用类的成员变量",
		"body": [
			"对象的由函数和数据（即方法和实例变量）组成。 方法的调用要通过对象来完成： 调用的方法可以访问其对象的其他函数和数据。",
			"",
			"使用 (.) 来引用实例对象的变量和方法：",
			"",
			"var p = Point(2, 2);",
			"",
			"// 为实例的变量 y 设置值。",
			"p.y = 3;",
			"",
			"// 获取变量 y 的值。",
			"assert(p.y == 3);",
			"",
			"// 调用 p 的 distanceTo() 方法。",
			"num distance = p.distanceTo(Point(4, 4));",
			"使用 ?. 来代替 . ， 可以避免因为左边对象可能为 null ， 导致的异常：",
			"",
			"// 如果 p 为 non-null，设置它变量 y 的值为 4。",
			"p?.y = 4;",
		],
	},
	"dt-使用构造函数": {
		"prefix": "dt-使用构造函数",
		"body": [
			"通过 构造函数 创建对象。 构造函数的名字可以是 ClassName 或者 ClassName.identifier。例如， 以下代码使用 Point 和 Point.fromJson() 构造函数创建 Point 对象：",
			"",
			"var p1 = Point(2, 2);",
			"var p2 = Point.fromJson({'x': 1, 'y': 2});",
			"以下代码具有相同的效果， 但是构造函数前面的的 new 关键字是可选的：",
			"",
			"var p1 = new Point(2, 2);",
			"var p2 = new Point.fromJson({'x': 1, 'y': 2});",
			"版本提示： 在 Dart 2 中 new 关键字变成了可选的。",
			"",
			"一些类提供了常量构造函数。 使用常量构造函数，在构造函数名之前加 const 关键字，来创建编译时常量时：",
			"",
			"var p = const ImmutablePoint(2, 2);",
			"构造两个相同的编译时常量会产生一个唯一的， 标准的实例：",
			"",
			"var a = const ImmutablePoint(1, 1);",
			"var b = const ImmutablePoint(1, 1);",
			"",
			"assert(identical(a, b)); // 它们是同一个实例。",
			"在 常量上下文 中， 构造函数或者字面量前的 const 可以省略。 例如，下面代码创建了一个 const 类型的 map 对象：",
			"",
			"// 这里有很多的 const 关键字。",
			"const pointAndLine = const {",
			"  'point': const [const ImmutablePoint(0, 0)],",
			"  'line': const [const ImmutablePoint(1, 10), const ImmutablePoint(-2, 11)],",
			"};",
			"保留第一个 const 关键字，其余的全部省略：",
			"",
			"// 仅有一个 const ，由该 const 建立常量上下文。",
			"const pointAndLine = {",
			"  'point': [ImmutablePoint(0, 0)],",
			"  'line': [ImmutablePoint(1, 10), ImmutablePoint(-2, 11)],",
			"};",
			"如果常量构造函数在常量上下文之外， 且省略了 const 关键字， 此时创建的对象是非常量对象：",
			"",
			"var a = const ImmutablePoint(1, 1); // 创建一个常量对象",
			"var b = ImmutablePoint(1, 1); // 创建一个非常量对象",
			"",
			"assert(!identical(a, b)); // 两者不是同一个实例!",
			"版本提示： 在 Dart 2 中，一个常量上下文中的 const 关键字可以被省略。",
		],
	},
	"dt-获取对象的类型": {
		"prefix": "dt-获取对象的类型",
		"body": [
			"使用对象的 runtimeType 属性， 可以在运行时获取对象的类型， runtimeType 属性回返回一个 Type 对象。",
			"",
			"print('The type of a is ${a.runtimeType}');",
			"到目前为止，我们已经解了如何_使用_类。 本节的其余部分将介绍如何_实现_一个类。",
		],
	},
	"dt-实例变量": {
		"prefix": "dt-实例变量",
		"body": [
			"下面是声明实例变量的示例：",
			"",
			"class Point {",
			"  num x; // 声明示例变量 x，初始值为 null 。",
			"  num y; // 声明示例变量 y，初始值为 null 。",
			"  num z = 0; // 声明示例变量 z，初始值为 0 。",
			"}",
			"未初始化实例变量的默认人值为 “null” 。",
			"",
			"所有实例变量都生成隐式 getter 方法。 非 final 的实例变量同样会生成隐式 setter 方法。 有关更多信息，参考 Getters 和 setters.",
			"",
			"class Point {",
			"  num x;",
			"  num y;",
			"}",
			"",
			"void main() {",
			"  var point = Point();",
			"  point.x = 4; // Use the setter method for x.",
			"  assert(point.x == 4); // Use the getter method for x.",
			"  assert(point.y == null); // Values default to null.",
			"}",
			"如果在声明时进行了示例变量的初始化， 那么初始化值会在示例创建时赋值给变量， 该赋值过程在构造函数及其初始化列表执行之前。",
		],
	},
	"dt-构造函数": {
		"prefix": "dt-构造函数",
		"body": [
			"通过创建一个与其类同名的函数来声明构造函数 （另外，还可以附加一个额外的可选标识符，如 命名构造函数 中所述）。 下面通过最常见的构造函数形式， 即生成构造函数， 创建一个类的实例：",
			"",
			"class Point {",
			"  num x, y;",
			"",
			"  Point(num x, num y) {",
			"    // 还有更好的方式来实现下面代码，敬请关注。",
			"    this.x = x;",
			"    this.y = y;",
			"  }",
			"}",
			"使用 this 关键字引用当前实例。",
			"",
			"提示： 近当存在命名冲突时，使用 this 关键字。 否则，按照 Dart 风格应该省略 this 。",
			"",
			"通常模式下，会将构造函数传入的参数的值赋值给对应的实例变量， Dart 自身的语法糖精简了这些代码：",
			"",
			"class Point {",
			"  num x, y;",
			"",
			"  // 在构造函数体执行前，",
			"  // 语法糖已经设置了变量 x 和 y。",
			"  Point(this.x, this.y);",
			"}",
		],
	},
	"dt-默认构造函数": {
		"prefix": "dt-默认构造函数",
		"body": [
			"默认构造函数",
			"在没有声明构造函数的情况下， Dart 会提供一个默认的构造函数。 默认构造函数没有参数并会调用父类的无参构造函数。",
			"",
			"构造函数不被继承",
			"子类不会继承父类的构造函数。 子类不声明构造函数，那么它就只有默认构造函数 (匿名，没有参数) 。",
		],
	},
	"dt-命名构造函数": {
		"prefix": "dt-命名构造函数",
		"body": [
			"使用命名构造函数可为一个类实现多个构造函数， 也可以使用命名构造函数来更清晰的表明函数意图：",
			"",
			"class Point {",
			"  num x, y;",
			"",
			"  Point(this.x, this.y);",
			"",
			"  // 命名构造函数",
			"  Point.origin() {",
			"    x = 0;",
			"    y = 0;",
			"  }",
			"}",
			"切记，构造函数不能够被继承， 这意味着父类的命名构造函数不会被子类继承。 如果希望使用父类中定义的命名构造函数创建子类， 就必须在子类中实现该构造函数。",
		],
	},
	"dt-调用父类非默认构造函数": {
		"prefix": "dt-调用父类非默认构造函数",
		"body": [
			"默认情况下，子类的构造函数会自动调用父类的默认构造函数（匿名，无参数）。 父类的构造函数在子类构造函数体开始执行的位置被调用。 如果提供了一个 initializer list （初始化参数列表）， 则初始化参数列表在父类构造函数执行之前执行。 总之，执行顺序如下：",
			"",
			"initializer list （初始化参数列表）",
			"superclass’s no-arg constructor （父类的无名构造函数）",
			"main class’s no-arg constructor （主类的无名构造函数）",
			"如果父类中没有匿名无参的构造函数， 则需要手工调用父类的其他构造函数。 在当前构造函数冒号 (:) 之后，函数体之前，声明调用父类构造函数。",
			"",
			"下面的示例中，Employee 类的构造函数调用了父类 Person 的命名构造函数。 点击运行按钮 执行示例代码。",
			"",
			"",
			"由于父类的构造函数参数在构造函数执行之前执行， 所以参数可以是一个表达式或者一个方法调用：",
			"",
			"class Employee extends Person {",
			"  Employee() : super.fromJson(getDefaultData());",
			"  // ···",
			"}",
			"警告： 调用父类构造函数的参数无法访问 this 。 例如，参数可以为静态函数但是不能是实例函数。",
			,
			"class Person {",
			"  String firstName;",
			"",
			"  Person.fromJson(Map data) {",
			"    print('in Person');",
			"  }",
			"}",
			"",
			"class Employee extends Person {",
			"  // Person does not have a default constructor;",
			"  // you must call super.fromJson(data).",
			"  Employee.fromJson(Map data) : super.fromJson(data) {",
			"    print('in Employee');",
			"  }",
			"}",
			"",
			"main() {",
			"  var emp = new Employee.fromJson({});",
			"",
			"  // Prints:",
			"  // in Person",
			"  // in Employee",
			"  if (emp is Person) {",
			"    // Type check",
			"    emp.firstName = 'Bob';",
			"  }",
			"  (emp as Person).firstName = 'Bob';",
			"}",
		],
	},
	"dt-初始化列表": {
		"prefix": "dt-初始化列表",
		"body": [
			"除了调用超类构造函数之外， 还可以在构造函数体执行之前初始化实例变量。 各参数的初始化用逗号分隔。",
			"",
			"// 在构造函数体执行之前，",
			"// 通过初始列表设置实例变量。",
			"Point.fromJson(Map<String, num> json)",
			"    : x = json['x'],",
			"      y = json['y'] {",
			"  print('In Point.fromJson(): ($x, $y)');",
			"}",
			"警告： 初始化程序的右侧无法访问 this 。",
			"",
			"在开发期间， 可以使用 assert 来验证输入的初始化列表。",
			"",
			"Point.withAssert(this.x, this.y) : assert(x >= 0) {",
			"  print('In Point.withAssert(): ($x, $y)');",
			"}",
			"使用初始化列表可以很方便的设置 final 字段。 下面示例演示了，如何使用初始化列表初始化设置三个 final 字段",
			,
			"import 'dart:math';",
			"",
			"class Point {",
			"  final num x;",
			"  final num y;",
			"  final num distanceFromOrigin;",
			"",
			"  Point(x, y)",
			"      : x = x,",
			"        y = y,",
			"        distanceFromOrigin = sqrt(x * x + y * y);",
			"}",
			"",
			"main() {",
			"  var p = new Point(2, 3);",
			"  print(p.distanceFromOrigin);",
			"}",
		],
	},
	"dt-重定向构造函数": {
		"prefix": "dt-重定向构造函数",
		"body": [
			"有时构造函数的唯一目的是重定向到同一个类中的另一个构造函数。 重定向构造函数的函数体为空， 构造函数的调用在冒号 (:) 之后。",
			"",
			"class Point {",
			"  num x, y;",
			"",
			"  // 类的主构造函数。",
			"  Point(this.x, this.y);",
			"",
			"  // 指向主构造函数",
			"  Point.alongXAxis(num x) : this(x, 0);",
			"}",
		],
	},
	"dt-常量构造函数": {
		"prefix": "dt-常量构造函数",
		"body": [
			"如果该类生成的对象是固定不变的， 那么就可以把这些对象定义为编译时常量。 为此，需要定义一个 const 构造函数， 并且声明所有实例变量为 final。",
			"",
			"class ImmutablePoint {",
			"  static final ImmutablePoint origin =",
			"      const ImmutablePoint(0, 0);",
			"",
			"  final num x, y;",
			"",
			"  const ImmutablePoint(this.x, this.y);",
			"}",
			"常量构造函数创建的实例并不总是常量。 更多内容，查看 使用构造函数 章节。",
		],
	},
	"dt-工厂构造函数": {
		"prefix": "dt-工厂构造函数",
		"body": [
			"当执行构造函数并不总是创建这个类的一个新实例时，则使用 factory 关键字。 例如，一个工厂构造函数可能会返回一个 cache 中的实例， 或者可能返回一个子类的实例。",
			"",
			"以下示例演示了从缓存中返回对象的工厂构造函数：",
			"",
			"class Logger {",
			"  final String name;",
			"  bool mute = false;",
			"",
			"  // 从命名的 _ 可以知，",
			"  // _cache 是私有属性。",
			"  static final Map<String, Logger> _cache =",
			"      <String, Logger>{};",
			"",
			"  factory Logger(String name) {",
			"    if (_cache.containsKey(name)) {",
			"      return _cache[name];",
			"    } else {",
			"      final logger = Logger._internal(name);",
			"      _cache[name] = logger;",
			"      return logger;",
			"    }",
			"  }",
			"",
			"  Logger._internal(this.name);",
			"",
			"  void log(String msg) {",
			"    if (!mute) print(msg);",
			"  }",
			"}",
			"提示： 工厂构造函数无法访问 this。",
			"",
			"工厂构造函的调用方式与其他构造函数一样：",
			"",
			"var logger = Logger('UI');",
			"logger.log('Button clicked');",
		],
	},
	"dt-实例方法": {
		"prefix": "dt-实例方法",
		"body": [
			"对象的实例方法可以访问 this 和实例变量。 以下示例中的 distanceTo() 方法就是实例方法：",
			"",
			"import 'dart:math';",
			"",
			"class Point {",
			"  num x, y;",
			"",
			"  Point(this.x, this.y);",
			"",
			"  num distanceTo(Point other) {",
			"    var dx = x - other.x;",
			"    var dy = y - other.y;",
			"    return sqrt(dx * dx + dy * dy);",
			"  }",
			"}",
		],
	},
	"dt-Getter 和 Setter": {
		"prefix": "dt-Getter 和 Setter",
		"body": [
			"Getter 和 Setter 是用于对象属性读和写的特殊方法。 回想之前的例子，每个实例变量都有一个隐式 Getter ，通常情况下还会有一个 Setter 。 使用 get 和 set 关键字实现 Getter 和 Setter ，能够为实例创建额外的属性。",
			"",
			"class Rectangle {",
			"  num left, top, width, height;",
			"",
			"  Rectangle(this.left, this.top, this.width, this.height);",
			"",
			"  // 定义两个计算属性： right 和 bottom。",
			"  num get right => left + width;",
			"  set right(num value) => left = value - width;",
			"  num get bottom => top + height;",
			"  set bottom(num value) => top = value - height;",
			"}",
			"",
			"void main() {",
			"  var rect = Rectangle(3, 4, 20, 15);",
			"  assert(rect.left == 3);",
			"  rect.right = 12;",
			"  assert(rect.left == -8);",
			"}",
			"最开始实现 Getter 和 Setter 也许是直接返回成员变量； 随着需求变化， Getter 和 Setter 可能需要进行计算处理而使用方法来实现； 但是，调用对象的代码不需要做任何的修改。",
			"",
			"提示： 类似 (++) 之类操作符不管是否定义了 getter 方法，都能够正确的执行。 为了避免一些问题，操作符只调用一次 getter 方法， 然后把值保存到一个临时的变量中。",
		],
	},
	"dt-抽象方法": {
		"prefix": "dt-抽象方法",
		"body": [
			"实例方法， getter， 和 setter 方法可以是抽象的， 只定义接口不进行实现，而是留给其他类去实现。 抽象方法只存在于 抽象类 中。",
			"",
			"定义一个抽象函数，使用分号 (;) 来代替函数体：",
			"",
			"abstract class Doer {",
			"  // 定义实例变量和方法 ...",
			"",
			"  void doSomething(); // 定义一个抽象方法。",
			"}",
			"",
			"class EffectiveDoer extends Doer {",
			"  void doSomething() {",
			"    // 提供方法实现，所以这里的方法就不是抽象方法了...",
			"  }",
			"}",
			"调用抽象方法会导致运行时错误。",
		],
	},
	"dt-抽象类": {
		"prefix": "dt-抽象类",
		"body": [
			"使用 abstract 修饰符来定义 抽象类 — 抽象类不能实例化。 抽象类通常用来定义接口，以及部分实现。 如果希望抽象类能够被实例化，那么可以通过定义一个 工厂构造函数 来实现。",
			"",
			"抽象类通常具有 抽象方法。 下面是一个声明具有抽象方法的抽象类示例：",
			"",
			"// 这个类被定义为抽象类，",
			"// 所以不能被实例化。",
			"abstract class AbstractContainer {",
			"  // 定义构造行数，字段，方法...",
			"",
			"  void updateChildren(); // 抽象方法。",
			"}",
		],
	},
	"dt-隐式接口implements": {
		"prefix": "dt-隐式接口implements",
		"body": [
			"每个类都隐式的定义了一个接口，接口包含了该类所有的实例成员及其实现的接口。 如果要创建一个 A 类，A 要支持 B 类的 API ，但是不需要继承 B 的实现， 那么可以通过 A 实现 B 的接口。",
			"",
			"一个类可以通过 implements 关键字来实现一个或者多个接口， 并实现每个接口要求的 API。 例如：",
			"",
			"// person 类。 隐式接口里面包含了 greet() 方法声明。",
			"class Person {",
			"  // 包含在接口里，但只在当前库中可见。",
			"  final _name;",
			"",
			"  // 不包含在接口里，因为这是一个构造函数。",
			"  Person(this._name);",
			"",
			"  // 包含在接口里。",
			"  String greet(String who) => 'Hello, $who. I am $_name.';",
			"}",
			"",
			"// person 接口的实现。",
			"class Impostor implements Person {",
			"  get _name => '';",
			"",
			"  String greet(String who) => 'Hi $who. Do you know who I am?';",
			"}",
			"",
			"String greetBob(Person person) => person.greet('Bob');",
			"",
			"void main() {",
			"  print(greetBob(Person('Kathy')));",
			"  print(greetBob(Impostor()));",
			"}",
			"下面示例演示一个类如何实现多个接口： Here’s an example of specifying that a class implements multiple interfaces:",
			"",
			"class Point implements Comparable, Location {...}",
		],
	},
	"dt-扩展类（继承）": {
		"prefix": "dt-扩展类（继承）",
		"body": [
			"使用 extends 关键字来创建子类， 使用 super 关键字来引用父类：",
			"",
			"class Television {",
			"  void turnOn() {",
			"    _illuminateDisplay();",
			"    _activateIrSensor();",
			"  }",
			"  // ···",
			"}",
			"",
			"class SmartTelevision extends Television {",
			"  void turnOn() {",
			"    super.turnOn();",
			"    _bootNetworkInterface();",
			"    _initializeMemory();",
			"    _upgradeApps();",
			"  }",
			"  // ···",
			"}",
		],
	},
	"dt-重写类成员": {
		"prefix": "dt-重写类成员",
		"body": [
			"子类可以重写实例方法，getter 和 setter。 可以使用 @override 注解指出想要重写的成员：",
			"",
			"class SmartTelevision extends Television {",
			"  @override",
			"  void turnOn() {...}",
			"  // ···",
			"}",
		],
	},
	"dt-重写运算符": {
		"prefix": "dt-重写运算符",
		"body": [
			"下面示例演示一个类重写 + 和 - 操作符：",
			"",
			"class Vector {",
			"  final int x, y;",
			"",
			"  Vector(this.x, this.y);",
			"",
			"  Vector operator +(Vector v) => Vector(x + v.x, y + v.y);",
			"  Vector operator -(Vector v) => Vector(x - v.x, y - v.y);",
			"",
			"  // 运算符 == 和 hashCode 部分没有列出。 有关详情，请参考下面的注释。",
			"  // ···",
			"}",
			"",
			"void main() {",
			"  final v = Vector(2, 3);",
			"  final w = Vector(2, 2);",
			"",
			"  assert(v + w == Vector(4, 5));",
			"  assert(v - w == Vector(0, 1));",
			"}",
			"如果要重写 == 操作符，需要重写对象的 hashCode getter 方法。 重写 == 和 hashCode 的实例，参考 Implementing map keys.",
			"",
			"有关重写的更多介绍，请参考 扩展类（继承）.",
		],
	},
	"dt-noSuchMethod": {
		"prefix": "dt-noSuchMethod",
		"body": [
			"当代码尝试使用不存在的方法或实例变量时， 通过重写 noSuchMethod() 方法，来实现检测和应对处理：",
			"",
			"class A {",
			"  // 如果不重写 noSuchMethod，访问",
			"  // 不存在的实例变量时会导致 NoSuchMethodError 错误。",
			"  @override",
			"  void noSuchMethod(Invocation invocation) {",
			"    print('You tried to use a non-existent member: ' +",
			"        '${invocation.memberName}');",
			"  }",
			"}",
			"除非符合下面的任意一项条件， 否则没有实现的方法不能够被调用：",
			"",
			"receiver 具有 dynamic 的静态类型 。",
			"",
			"receiver 具有静态类型，用于定义为实现的方法 (可以是抽象的), 并且 receiver 的动态类型具有 noSuchMethod() 的实现， 该实现与 Object 类中的实现不同。",
			"",
			"有关更多信息，参考 noSuchMethod forwarding specification.",
		],
	},
	"dt-枚举类型": {
		"prefix": "dt-枚举类型",
		"body": [
			"使用枚举",
			"使用 enum 关键字定义一个枚举类型：",
			"",
			"enum Color { red, green, blue }",
			"枚举中的每个值都有一个 index getter 方法， 该方法返回值所在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的索引是 0 ， 第二个枚举值的索引是 1。",
			"",
			"assert(Color.red.index == 0);",
			"assert(Color.green.index == 1);",
			"assert(Color.blue.index == 2);",
			"使用枚举的 values 常量， 获取所有枚举值列表（ list ）。",
			"",
			"List<Color> colors = Color.values;",
			"assert(colors[2] == Color.blue);",
			"可以在 switch 语句 中使用枚举， 如果不处理所有枚举值，会收到警告：",
			"",
			"var aColor = Color.blue;",
			"",
			"switch (aColor) {",
			"  case Color.red:",
			"    print('Red as roses!');",
			"    break;",
			"  case Color.green:",
			"    print('Green as grass!');",
			"    break;",
			"  default: // 没有这个，会看到一个警告。",
			"    print(aColor); // 'Color.blue'",
			"}",
			"枚举类型具有以下限制：",
			"",
			"枚举不能被子类化，混合或实现。",
			"枚举不能被显式实例化。",
			"有关更多信息，参考 Dart language specification 。",
		],
	},
	"dt-为类添加功能： Mixin": {
		"prefix": "dt-为类添加功能： Mixin",
		"body": [
			"Mixin 是复用类代码的一种途径， 复用的类可以在不同层级，之间可以不存在继承关系。",
			"",
			"通过 with 后面跟一个或多个混入的名称，来 使用 Mixin ， 下面的示例演示了两个使用 Mixin 的类：",
			"",
			"class Musician extends Performer with Musical {",
			"  // ···",
			"}",
			"",
			"class Maestro extends Person",
			"    with Musical, Aggressive, Demented {",
			"  Maestro(String maestroName) {",
			"    name = maestroName;",
			"    canConduct = true;",
			"  }",
			"}",
			"通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 例如：",
			"",
			"mixin Musical {",
			"  bool canPlayPiano = false;",
			"  bool canCompose = false;",
			"  bool canConduct = false;",
			"",
			"  void entertainMe() {",
			"    if (canPlayPiano) {",
			"      print('Playing piano');",
			"    } else if (canConduct) {",
			"      print('Waving hands');",
			"    } else {",
			"      print('Humming to self');",
			"    }",
			"  }",
			"}",
			"指定只有某些类型可以使用的 Mixin - 比如， Mixin 可以调用 Mixin 自身没有定义的方法 - 使用 on 来指定可以使用 Mixin 的父类类型：",
			"",
			"mixin MusicalPerformer on Musician {",
			"  // ···",
			"}",
			"版本提示： mixin 关键字在 Dart 2.1 中被引用支持。 早期版本中的代码通常使用 abstract class 代替。 更多有关 Mixin 在 2.1 中的变更信息，请参见 Dart SDK changelog 和 2.1 mixin specification 。",
			"",
			"提示： 对 Mixin 的一些限制正在被移除。 关于更多详情，参考 proposed mixin specification.",
			"",
			"有关 Dart 中 Mixin 的理论演变，参考 A Brief History of Mixins in Dart.",
		],
	},
	"dt-静态变量": {
		"prefix": "dt-静态变量",
		"body": [
			"静态变量（类变量）对于类级别的状态是非常有用的：",
			"",
			"class Queue {",
			"  static const initialCapacity = 16;",
			"  // ···",
			"}",
			"",
			"void main() {",
			"  assert(Queue.initialCapacity == 16);",
			"}",
			"静态变量只到它们被使用的时候才会初始化。",
			"",
			"提示： 代码准守风格推荐指南 中的命名规则， 使用 lowerCamelCase 来命名常量。",
		],
	},
	"dt-静态方法": {
		"prefix": "dt-静态方法",
		"body": [
			"静态方法（类方法）不能在实例上使用，因此它们不能访问 this 。 例如：",
			"",
			"import 'dart:math';",
			"",
			"class Point {",
			"  num x, y;",
			"  Point(this.x, this.y);",
			"",
			"  static num distanceBetween(Point a, Point b) {",
			"    var dx = a.x - b.x;",
			"    var dy = a.y - b.y;",
			"    return sqrt(dx * dx + dy * dy);",
			"  }",
			"}",
			"",
			"void main() {",
			"  var a = Point(2, 2);",
			"  var b = Point(4, 4);",
			"  var distance = Point.distanceBetween(a, b);",
			"  assert(2.8 < distance && distance < 2.9);",
			"  print(distance);",
			"}",
			"提示： 对于常见或广泛使用的工具和函数， 应该考虑使用顶级函数而不是静态方法。",
			"",
			"静态函数可以当做编译时常量使用。 例如，可以将静态方法作为参数传递给常量构造函数。",
		],
	},
	"dt-为什么使用泛型": {
		"prefix": "dt-为什么使用泛型",
		"body": [
			"在类型安全上通常需要泛型支持， 它的好处不仅仅是保证代码的正常运行：",
			"",
			"正确指定泛型类型可以提高代码质量。",
			"使用泛型可以减少重复的代码。",
			"如果想让 List 仅仅支持字符串类型， 可以将其声明为 List<String> （读作“字符串类型的 list ”）。 那么，当一个非字符串被赋值给了这个 list 时，开发工具就能够检测到这样的做法可能存在错误。 例如：",
			"",
			"var names = List<String>();",
			"names.addAll(['Seth', 'Kathy', 'Lars']);",
			"names.add(42); // 错误",
			"另外一个使用泛型的原因是减少重复的代码。 泛型可以在多种类型之间定义同一个实现， 同时还可以继续使用检查模式和静态分析工具提供的代码分析功能。 例如，假设你创建了一个用于缓存对象的接口：",
			"",
			"abstract class ObjectCache {",
			"  Object getByKey(String key);",
			"  void setByKey(String key, Object value);",
			"}",
			"后来发现需要一个相同功能的字符串类型接口，因此又创建了另一个接口：",
			"",
			"abstract class StringCache {",
			"  String getByKey(String key);",
			"  void setByKey(String key, String value);",
			"}",
			"后来，又发现需要一个相同功能的数字类型接口 … 这里你应该明白了。",
			"",
			"泛型可以省去创建所有这些接口的麻烦。 通过创建一个带有泛型参数的接口，来代替上述接口：",
			"",
			"abstract class Cache<T> {",
			"  T getByKey(String key);",
			"  void setByKey(String key, T value);",
			"}",
			"在上面的代码中，T 是一个备用类型。 这是一个类型占位符，在开发者调用该接口的时候会指定具体类型。",
		],
	},
	"dt-使用集合字面量": {
		"prefix": "dt-使用集合字面量",
		"body": [
			"List , Set 和 Map 字面量也是可以参数化的。 参数化字面量和之前的字面量定义类似， 对于 List 或 Set 只需要在声明语句前加 <type> 前缀， 对于 Map 只需要在声明语句前加 <keyType, valueType> 前缀， 下面是参数化字面量的示例：",
			"",
			"var names = <String>['Seth', 'Kathy', 'Lars'];",
			"var uniqueNames = <String>{'Seth', 'Kathy', 'Lars'};",
			"var pages = <String, String>{",
			"  'index.html': 'Homepage',",
			"  'robots.txt': 'Hints for web robots',",
			"  'humans.txt': 'We are people, not machines'",
			"};",
		],
	},
	"dt-使用泛型类型的构造函数": {
		"prefix": "dt-使用泛型类型的构造函数",
		"body": [
			"在调用构造函数的时，在类名字后面使用尖括号（<...>）来指定泛型类型。 例如：",
			"",
			"var nameSet = Set<String>.from(names);",
			"下面代码创建了一个 key 为 integer， value 为 View 的 map 对象：",
			"",
			"var views = Map<int, View>();",
		],
	},
	"dt-运行时中的泛型集合": {
		"prefix": "dt-运行时中的泛型集合",
		"body": [
			"Dart 中泛型类型是 固化的，也就是说它们在运行时是携带着类型信息的。 例如， 在运行时检测集合的类型：",
			"",
			"var names = List<String>();",
			"names.addAll(['Seth', 'Kathy', 'Lars']);",
			"print(names is List<String>); // true",
			"提示： 相反，Java中的泛型会被 擦除 ，也就是说在运行时泛型类型参数的信息是不存在的。 在Java中，可以测试对象是否为 List 类型， 但无法测试它是否为 List<String> 。",
		],
	},
	"dt-限制泛型类型": {
		"prefix": "dt-限制泛型类型",
		"body": [
			"使用泛型类型的时候， 可以使用 extends 实现参数类型的限制。",
			"",
			"class Foo<T extends SomeBaseClass> {",
			"  // Implementation goes here...",
			"  String toString() => \"Instance of 'Foo<$T>'\";",
			"}",
			"",
			"class Extender extends SomeBaseClass {...}",
			"可以使用 SomeBaseClass 或其任意子类作为通用参数：",
			"",
			"var someBaseClassFoo = Foo<SomeBaseClass>();",
			"var extenderFoo = Foo<Extender>();",
			"也可以不指定泛型参数：",
			"",
			"var foo = Foo();",
			"print(foo); // Instance of 'Foo<SomeBaseClass>'",
			"指定任何非 SomeBaseClass 类型会导致错误：",
			"",
			"var foo = Foo<Object>();",
		],
	},
	"dt-使用泛型函数": {
		"prefix": "dt-使用泛型函数",
		"body": [
			"最初，Dart 的泛型只能用于类。 新语法_泛型方法_，允许在方法和函数上使用类型参数：",
			"",
			"T first<T>(List<T> ts) {",
			"  // Do some initial work or error checking, then...",
			"  T tmp = ts[0];",
			"  // Do some additional checking or processing...",
			"  return tmp;",
			"}",
			"这里的 first (<T>) 泛型可以在如下地方使用参数 T ：",
			"",
			"函数的返回值类型 (T).",
			"参数的类型 (List<T>).",
			"局部变量的类型 (T tmp).",
			"关于泛型的更多信息，参考 使用泛型函数",
		],
	},
	"dt-使用库": {
		"prefix": "dt-使用库",
		"body": [
			"通过 import 指定一个库命名空间中的内如如何在另一个库中使用。 例如，Dart Web应用程序通常使用 dart:html 库，它们可以像这样导入：",
			"",
			"import 'dart:html';",
			"import 参数只需要一个指向库的 URI。 对于内置库，URI 拥有自己特殊的dart: 方案。 对于其他的库，使用系统文件路径或者 package: 方案 。 package: 方案指定由包管理器（如 pub 工具）提供的库。例如：",
			"",
			"import 'package:test/test.dart';",
			"提示： URI 代表统一资源标识符。 URL（统一资源定位符）是一种常见的URI。",
		],
	},
	"dt-指定库前缀": {
		"prefix": "dt-指定库前缀",
		"body": [
			"如果导入两个存在冲突标识符的库， 则可以为这两个库，或者其中一个指定前缀。 例如，如果 library1 和 library2 都有一个 Element 类， 那么可以通过下面的方式处理：",
			"",
			"import 'package:lib1/lib1.dart';",
			"import 'package:lib2/lib2.dart' as lib2;",
			"",
			"// 使用 lib1 中的 Element。",
			"Element element1 = Element();",
			"",
			"// 使用 lib2 中的 Element。",
			"lib2.Element element2 = lib2.Element();",
		],
	},
	"dt-导入库的一部分": {
		"prefix": "dt-导入库的一部分",
		"body": [
			"如果你只使用库的一部分功能，则可以选择需要导入的 内容。例如：",
			"",
			"// Import only foo.",
			"import 'package:lib1/lib1.dart' show foo;",
			"",
			"// Import all names EXCEPT foo.",
			"import 'package:lib2/lib2.dart' hide foo;",
		],
	},
	"dt-延迟加载库": {
		"prefix": "dt-延迟加载库",
		"body": [
			"Deferred loading (也称之为 lazy loading) 可以让应用在需要的时候再加载库。 下面是一些使用延迟加载库的场景：",
			"",
			"减少 APP 的启动时间。",
			"执行 A/B 测试，例如 尝试各种算法的 不同实现。",
			"加载很少使用的功能，例如可选的屏幕和对话框。",
			"要延迟加载一个库，需要先使用 deferred as 来导入：",
			"",
			"import 'package:greetings/hello.dart' deferred as hello;",
			"当需要使用的时候，使用库标识符调用 loadLibrary() 函数来加载库：",
			"",
			"Future greet() async {",
			"  await hello.loadLibrary();",
			"  hello.printGreeting();",
			"}",
			"在前面的代码，使用 await 关键字暂停代码执行一直到库加载完成。 关于 async 和 await 的更多信息请参考 异步支持。",
			"",
			"在一个库上你可以多次调用 loadLibrary() 函数。但是该库只是载入一次。",
			"",
			"使用延迟加载库的时候，请注意一下问题：",
			"",
			"延迟加载库的常量在导入的时候是不可用的。 只有当库加载完毕的时候，库中常量才可以使用。",
			"在导入文件的时候无法使用延迟库中的类型。 如果你需要使用类型，则考虑把接口类型移动到另外一个库中， 让两个库都分别导入这个接口库。",
			"Dart 隐含的把 loadLibrary() 函数导入到使用 deferred as 的命名空间 中。 loadLibrary() 方法返回一个 Future。",
			"Dart VM difference: The Dart VM allows access to members of deferred libraries even before the call to loadLibrary(). This behavior might change, so don’t depend on the current VM behavior. For details, see issue #33118.",
		],
	},
	"dt-处理 Future": {
		"prefix": "dt-处理 Future",
		"body": [
			"可以通过下面两种方式，获得 Future 执行完成的结果：",
			"",
			"使用 async 和 await.",
			"使用 Future API，具体描述，参考 库概览.",
			"使用 async 和 await 关键字的代码是异步的。 虽然看起来有点想同步代码。 例如，下面的代码使用 await 等待异步函数的执行结果。",
			"",
			"await lookUpVersion();",
			"要使用 await ， 代码必须在 异步函数（使用 async 标记的函数）中：",
			"",
			"Future checkVersion() async {",
			"  var version = await lookUpVersion();",
			"  // Do something with version",
			"}",
			"提示： 虽然异步函数可能会执行耗时的操作， 但它不会等待这些操作。 相反，异步函数只有在遇到第一个 await 表达式（详情见）时才会执行。 也就是说，它返回一个 Future 对象， 仅在await表达式完成后才恢复执行。",
			"",
			"使用 try， catch， 和 finally 来处理代码中使用 await 导致的错误。",
			"",
			"try {",
			"  version = await lookUpVersion();",
			"} catch (e) {",
			"  // React to inability to look up the version",
			"}",
			"在一个异步函数中可以多次使用 await 。 例如，下面代码中等待了三次函数结果：",
			"",
			"var entrypoint = await findEntrypoint();",
			"var exitCode = await runExecutable(entrypoint, args);",
			"await flushThenExit(exitCode);",
			"在 await 表达式 中， 表达式 的值通常是一个 Future 对象； 如果不是，这是表达式的值会被自动包装成一个 Future 对象。 Future 对象指明返回一个对象的承诺（promise）。 await 表达式 执行的结果为这个返回的对象。 await 表达式会阻塞代码的执行，直到需要的对象返回为止。",
			"",
			"如果在使用 await 导致编译时错误， 确认 await 是否在一个异步函数中。 例如，在应用的 main() 函数中使用 await ， main() 函数的函数体必须被标记为 async ：",
			"",
			"Future main() async {",
			"  checkVersion();",
			"  print('In main: version is ${await lookUpVersion()}');",
			"}",
		],
	},
	"dt-声明异步函数": {
		"prefix": "dt-声明异步函数",
		"body": [
			"函数体被 async 标示符标记的函数，即是一个_异步函数_。 将 async 关键字添加到函数使其返回Future。 例如，考虑下面的同步函数，它返回一个 String ：",
			"",
			"String lookUpVersion() => '1.0.0';",
			"例如，将来的实现将非常耗时，将其更改为异步函数，返回值是 Future 。",
			"",
			"Future<String> lookUpVersion() async => '1.0.0';",
			"注意，函数体不需要使用Future API。 如有必要， Dart 会创建 Future 对象。",
			"",
			"如果函数没有返回有效值， 需要设置其返回类型为 Future<void> 。",
		],
	},
	"dt-处理 Stream": {
		"prefix": "dt-处理 Stream",
		"body": [
			"当需要从 Stream 中获取数据值时， 可以通过一下两种方式：",
			"",
			"使用 async 和 一个 异步循环 （await for）。",
			"使用 Stream API, 更多详情，参考 in the library tour。",
			"提示： 在使用 await for 前，确保代码清晰， 并且确实希望等待所有流的结果。 例如，通常不应该使用 await for 的UI事件侦听器， 因为UI框架会发送无穷无尽的事件流。",
			"",
			"一下是异步for循环的使用形式：",
			"",
			"await for (varOrType identifier in expression) {",
			"  // Executes each time the stream emits a value.",
			"}",
			"上面 表达式 返回的值必须是 Stream 类型。 执行流程如下：",
			"",
			"等待，直到流发出一个值。",
			"执行 for 循环体，将变量设置为该发出的值",
			"重复1和2，直到关闭流。",
			"使用 break 或者 return 语句可以停止接收 stream 的数据， 这样就跳出了 for 循环， 并且从 stream 上取消注册。 **如果在实现异步 for 循环时遇到编译时错误， 请检查确保 await for 处于异步函数中。** 例如，要在应用程序的 main() 函数中使用异步 fo r循环， main() 函数体必须标记为 async` ：",
			"",
			"Future main() async {",
			"  // ...",
			"  await for (var request in requestServer) {",
			"    handleRequest(request);",
			"  }",
			"  // ...",
			"}",
			"有关异步编程的更多信息，请参考 dart:async 部分。 同时也可参考文章 Dart Language Asynchrony Support: Phase 1 和 Dart Language Asynchrony Support: Phase 2, 以及 Dart language specification 。",
		],
	},
	"dt-生成器": {
		"prefix": "dt-生成器",
		"body": [
			"当您需要延迟生成( lazily produce )一系列值时， 可以考虑使用_生成器函数_。 Dart 内置支持两种生成器函数：",
			"",
			"Synchronous 生成器： 返回一个 Iterable 对象。",
			"Asynchronous 生成器： 返回一个 Stream 对象。",
			"通过在函数体标记 sync*， 可以实现一个同步生成器函数。 使用 yield 语句来传递值：",
			"",
			"Iterable<int> naturalsTo(int n) sync* {",
			"  int k = 0;",
			"  while (k < n) yield k++;",
			"}",
			"通过在函数体标记 async*， 可以实现一个异步生成器函数。 使用 yield 语句来传递值：",
			"",
			"Stream<int> asynchronousNaturalsTo(int n) async* {",
			"  int k = 0;",
			"  while (k < n) yield k++;",
			"}",
			"如果生成器是递归的，可以使用 yield* 来提高其性能：",
			"",
			"Iterable<int> naturalsDownFrom(int n) sync* {",
			"  if (n > 0) {",
			"    yield n;",
			"    yield* naturalsDownFrom(n - 1);",
			"  }",
			"}",
			"有关生成器的更多信息，请参考文章 Dart Language Asynchrony Support: Phase 2 。",
		],
	},
	"dt-可调用类": {
		"prefix": "dt-可调用类",
		"body": [
			"通过实现类的 call() 方法， 能够让类像函数一样被调用。",
			"",
			"在下面的示例中，WannabeFunction 类定义了一个 call() 函数， 函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号。 单击运行按钮  执行代码。",
			"class WannabeFunction {",
			"  call(String a, String b, String c) => '$a $b $c!';",
			"}",
			"",
			"main() {",
			"  var wf = new WannabeFunction();",
			"  var out = wf(\"Hi\",\"there,\",\"gang\");",
			"  print('$out');",
			"}",
		],
	},
	"dt-Isolates": {
		"prefix": "dt-Isolates",
		"body": [
			"大多数计算机中，甚至在移动平台上，都在使用多核CPU。 为了有效利用多核性能，开发者一般使用共享内存数据来保证多线程的正确执行。 然而， 多线程共享数据通常会导致很多潜在的问题，并导致代码运行出错。",
			"",
			"所有 Dart 代码都在隔离区（ isolates ）内运行，而不是线程。 每个隔离区都有自己的内存堆，确保每个隔离区的状态都不会被其他隔离区访问。",
			"",
			"有关更多信息，请参考 dart:isolate library documentation. 。",
		],
	},
	"dt-Typedefs": {
		"prefix": "dt-Typedefs",
		"body": [
			"在 Dart 中，函数也是对象，就想字符和数字对象一样。 使用 typedef ，或者 function-type alias 为函数起一个别名， 别名可以用来声明字段及返回值类型。 当函数类型分配给变量时，typedef会保留类型信息。",
			"",
			"请考虑以下代码，代码中未使用 typedef ：",
			"",
			"class SortedCollection {",
			"  Function compare;",
			"",
			"  SortedCollection(int f(Object a, Object b)) {",
			"    compare = f;",
			"  }",
			"}",
			"",
			"// Initial, broken implementation. // broken ？",
			"int sort(Object a, Object b) => 0;",
			"",
			"void main() {",
			"  SortedCollection coll = SortedCollection(sort);",
			"",
			"  // 虽然知道 compare 是函数，",
			"  // 但是函数是什么类型 ？",
			"  assert(coll.compare is Function);",
			"}",
			"当把 f 赋值给 compare 的时候，类型信息丢失了。 f 的类型是 (Object, Object) → int (这里 → 代表返回值类型)， 但是 compare 得到的类型是 Function 。如果我们使用显式的名字并保留类型信息， 这样开发者和工具都可以使用这些信息：",
			"",
			"typedef Compare = int Function(Object a, Object b);",
			"",
			"class SortedCollection {",
			"  Compare compare;",
			"",
			"  SortedCollection(this.compare);",
			"}",
			"",
			"// Initial, broken implementation.",
			"int sort(Object a, Object b) => 0;",
			"",
			"void main() {",
			"  SortedCollection coll = SortedCollection(sort);",
			"  assert(coll.compare is Function);",
			"  assert(coll.compare is Compare);",
			"}",
			"提示： 目前，typedefs 只能使用在函数类型上， 我们希望将来这种情况有所改变。",
			"",
			"由于 typedefs 只是别名， 他们还提供了一种方式来判断任意函数的类型。例如：",
			"",
			"typedef Compare<T> = int Function(T a, T b);",
			"",
			"int sort(int a, int b) => a - b;",
			"",
			"void main() {",
			"  assert(sort is Compare<int>); // True!",
			"}",
		],
	},
	"dt-元数据": {
		"prefix": "dt-元数据",
		"body": [
			"使用元数据可以提供有关代码的其他信息。 元数据注释以字符 @ 开头， 后跟对编译时常量 (如 deprecated) 的引用或对常量构造函数的调用。",
			"",
			"对于所有 Dart 代码有两种可用注解：@deprecated 和 @override。 关于 @override 的使用， 参考 扩展类（继承）。 下面是使用 @deprecated 注解的示例：",
			"",
			"class Television {",
			"  /// _Deprecated: Use [turnOn] instead._",
			"  @deprecated",
			"  void activate() {",
			"    turnOn();",
			"  }",
			"",
			"  /// Turns the TV's power on.",
			"  void turnOn() {...}",
			"}",
			"可以自定义元数据注解。 下面的示例定义了一个带有两个参数的 @todo 注解：",
			"",
			"library todo;",
			"",
			"class Todo {",
			"  final String who;",
			"  final String what;",
			"",
			"  const Todo(this.who, this.what);",
			"}",
			"使用 @todo 注解的示例：",
			"",
			"import 'todo.dart';",
			"",
			"@Todo('seth', 'make this do something')",
			"void doSomething() {",
			"  print('do something');",
			"}",
			"元数据可以在 library、 class、 typedef、 type parameter、 constructor、 factory、 function、 field、 parameter 或者 variable 声明之前使用，也可以在 import 或者 export 指令之前使用。 使用反射可以在运行时获取元数据信息",
		],
	},
	"dt-文档注释": {
		"prefix": "dt-文档注释",
		"body": [
			"文档注释可以是多行注释，也可以是单行注释， 文档注释以 /// 或者 /** 开始。 在连续行上使用 /// 与多行文档注释具有相同的效果。",
			"",
			"在文档注释中，除非用中括号括起来，否则Dart 编译器会忽略所有文本。 使用中括号可以引用类、 方法、 字段、 顶级变量、 函数、 和参数。 括号中的符号会在已记录的程序元素的词法域中进行解析。",
			"",
			"下面是一个引用其他类和成员的文档注释：",
			"",
			"/// A domesticated South American camelid (Lama glama).",
			"///",
			"/// 自从西班牙时代以来，",
			"/// 安第斯文化就将骆驼当做肉食类和运输类动物。",
			"class Llama {",
			"  String name;",
			"",
			"  /// 喂养骆驼 [Food].",
			"  ///",
			"  /// 典型的美洲驼每周吃一捆干草。",
			"  void feed(Food food) {",
			"    // ...",
			"  }",
			"",
			"  /// 使用 [activity] 训练骆驼",
			"  /// [timeLimit] 分钟。",
			"  void exercise(Activity activity, int timeLimit) {",
			"    // ...",
			"  }",
			"}",
		],
	},
	"dt-style-使用 UpperCamelCase 风格命名类型。": {
		"prefix": "dt-style-使用 UpperCamelCase 风格命名类型。",
		"body": [
			"Classes（类名）、 enums（枚举类型）、 typedefs（类型定义）、 以及 type parameters（类型参数）应该把每个单词的首字母都大写（包含第一个单词）， 不使用分隔符。",
			"",
			"class SliderMenu { ... }",
			"",
			"class HttpRequest { ... }",
			"",
			"typedef Predicate = bool Function<T>(T value);",
			"这里包括使用元数据注解的类。",
			"",
			"class Foo {",
			"  const Foo([arg]);",
			"}",
			"",
			"@Foo(anArg)",
			"class A { ... }",
			"",
			"@Foo()",
			"class B { ... }",
			"如果注解类的构造函数是无参函数， 则可以使用一个 lowerCamelCase 风格的常量来初始化这个注解。",
			"",
			"const foo = Foo();",
			"",
			"@foo",
			"class C { ... }",
		],
	},
	"dt-style-在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名。": {
		"prefix": "dt-style-在库，包，文件夹，源文件中使用 lowercase_with_underscores 方式命名。",
		"body": [
			"要 用 lowercase_with_underscores 风格命名库和源文件名。",
			"一些文件系统不区分大小写，所以很多项目要求文件名必须是小写字母。 使用分隔符这种形式可以保证命名的可读性。使用下划线作为分隔符可确保名称仍然是有效的Dart标识符， 如果语言后续支持符号导入，这将会起到非常大的帮助。",
			"",
			"library peg_parser.source_scanner;",
			"",
			"import 'file_system.dart';",
			"import 'slider_menu.dart';",
		],
	},
	"dt-style- 使用 lowerCamelCase 风格来命名其他的标识符。": {
		"prefix": "dt-style- 使用 lowerCamelCase 风格来命名其他的标识符。",
		"body": [
			"类成员、顶级定义、变量、参数以及命名参数等 除了第一个单词，每个单词首字母都应大写，并且不使用分隔符。",
			"",
			"var item;",
			"",
			"HttpRequest httpRequest;",
			"",
			"void align(bool clearItems) {",
			"  // ...",
			"}",
		],
	},
	"dt-style- 使用 lowerCamelCase 来命名常量。": {
		"prefix": "dt-style- 使用 lowerCamelCase 来命名常量。",
		"body": [
			"在新的代码中，使用 lowerCamelCase 来命名常量，包括枚举的值。 已有的代码使用了 SCREAMING_CAPS 风格， 你可以继续全部使用该风格来保持代码的一致性。",
			"",
			"const pi = 3.14;",
			"const defaultTimeout = 1000;",
			"final urlScheme = RegExp('^([a-z]+):');",
			"",
			"class Dice {",
			"  static final numberGenerator = Random();",
			"}",
		],
	},
	"dt-style-把超过两个字母的首字母大写缩略词和缩写词当做一般单词来对待。": {
		"prefix": "dt-style-把超过两个字母的首字母大写缩略词和缩写词当做一般单词来对待。",
		"body": [
			"首字母大写缩略词比较难阅读， 特别是多个缩略词连载一起的时候会引起歧义。 例如，一个以 HTTPSFTP 开头的名字， 没有办法判断它是指 HTTPS FTP 还是 HTTP SFTP 。",
			"",
			"为了避免上面的情况，缩略词和缩写词要像普通单词一样首字母大写， 两个字母的单词除外。 （像 ID 和 Mr. 这样的双字母缩写词仍然像一般单词一样首字母大写。）",
			"",
			"HttpConnectionInfo",
			"uiHandler",
			"IOStream",
			"HttpRequest",
			"Id",
			"DB",
		],
	},
	"dt-style-使用前缀字母": {
		"prefix": "dt-style-使用前缀字母",
		"body": [
			"在编译器无法帮助你了解自己代码的时， 匈牙利命名法 和其他方案出现在了 BCPL ， 但是因为 Dart 可以提示你声明的类型，范围，可变性和其他属性， 所以没有理由在标识符名称中对这些属性进行编码。",
			"",
			"defaultTimeout",
			"kDefaultTimeout",
		],
	},
	"dt-style-把 “dart:” 导入语句放到其他导入语句之前。": {
		"prefix": "dt-style-把 “dart:” 导入语句放到其他导入语句之前。",
		"body": [
			"import 'dart:async';",
			"import 'dart:html';",
			"",
			"import 'package:bar/bar.dart';",
			"import 'package:foo/foo.dart';",
		],
	},
	"dt-style- 把 “package:” 导入语句放到项目相关导入语句之前。": {
		"prefix": "dt-style- 把 “package:” 导入语句放到项目相关导入语句之前。",
		"body": [
			"import 'package:bar/bar.dart';",
			"import 'package:foo/foo.dart';",
			"",
			"import 'util.dart';",
		],
	},
	"dt-style-把外部扩展 “package:” 导入语句放到其他语句之前。": {
		"prefix": "dt-style-把外部扩展 “package:” 导入语句放到其他语句之前。",
		"body": [
			"如果你使用了多个 “package:” 导入语句来导入自己的包以及其他外部扩展包， 推荐将自己的包分开放到一个额外的部分。",
			"",
			"import 'package:bar/bar.dart';",
			"import 'package:foo/foo.dart';",
			"",
			"import 'package:my_package/util.dart';",
		],
	},
	"dt-style-把导出（export）语句作为一个单独的部分放到所有导入语句之后。把导出（export）语句作为一个单独的部分放到所有导入语句之后。": {
		"prefix": "dt-style-把导出（export）语句作为一个单独的部分放到所有导入语句之后。",
		"body": [
			"import 'src/error.dart';",
			"import 'src/foo_bar.dart';",
			"",
			"export 'src/error.dart';",
		],
	},
	"dt-style-要 按照字母顺序来排序每个部分中的语句。": {
		"prefix": "dt-style- 按照字母顺序来排序每个部分中的语句。",
		"body": [
			"import 'package:bar/bar.dart';",
			"import 'package:foo/foo.dart';",
			"",
			"import 'foo.dart';",
			"import 'foo/foo.dart';",
			"import 'package:foo/foo.dart';",
			"import 'package:bar/bar.dart';",
			"",
			"import 'foo/foo.dart';",
			"import 'foo.dart';",
		],
	},
	"dt-style-对所有流控制结构使用花括号。": {
		"prefix": "dt-style-对所有流控制结构使用花括号。",
		"body": [
			"这样可以避免 dangling else （else悬挂）的问题。",
			"",
			"if (isWeekDay) {",
			"  print('Bike to work!');",
			"} else {",
			"  print('Go dancing or read a book!');",
			"}",
			"这里有一个例外：一个没有 else 的 if 语句， 并且这个 if 语句以及它的执行体适合在一行中实现。 在这种情况下，如果您愿意，可以不用括号：",
			"",
			"if (arg == null) return defaultValue;",
			"但是，如果执行体包含下一行，请使用大括号：",
			"",
			"if (overflowChars != other.overflowChars) {",
			"  return overflowChars < other.overflowChars;",
			"}",
			"if (overflowChars != other.overflowChars)",
			"  return overflowChars < other.overflowChars;",
		],
	},
	"dt-style-使用临近字符字的方式连接字面量字符串。": {
		"prefix": "dt-style-使用临近字符字的方式连接字面量字符串。",
		"body": [
			"raiseAlarm(",
			"    'ERROR: Parts of the spaceship are on fire. Other '",
			"    'parts are overrun by martians. Unclear which are which.');",
			"raiseAlarm('ERROR: Parts of the spaceship are on fire. Other ' +",
			"    'parts are overrun by martians. Unclear which are which.');",
		],
	},
	"dt-style-使用插值的形式来组合字符串和值。": {
		"prefix": "dt-style-使用插值的形式来组合字符串和值。",
		"body": [
			"如果你之前使用过其他语言，你一定习惯使用大量 + 将字面量字符串以及字符串变量链接构建字符串。 这种方式在 Dart 中同样有效，但是通常情况下使用插值会更清晰简短。",
			"",
			"'Hello, $name! You are ${year - birth} years old.';",
			"'Hello, ' + name + '! You are ' + (year - birth).toString() + ' y...';",
		],
	},
	"dt-style-在字符串插值中使用不必要的大括号。": {
		"prefix": "dt-style-在字符串插值中使用不必要的大括号。",
		"body": [
			"如果要插入是一个简单的标识符，并且后面没有紧跟随在其他字母文本，则应省略 {} 。",
			"",
			"'Hi, $name!'",
			"\"Wear your wildest $decade's outfit.\"",
			"'Wear your wildest ${decade}s outfit.'",
			"'Hi, ${name}!'",
			"\"Wear your wildest ${decade}'s outfit.\"",
		],
	},
	"dt-style-尽可能的使用集合字面量。": {
		"prefix": "dt-style-尽可能的使用集合字面量。",
		"body": [
			"有两种方式来构造一个空的可变 list ： [] 和 List() 。 同样，有三总方式来构造一个空的链表哈希 map：{}， Map()， 和 LinkedHashMap() 。",
			"",
			"如果想创建一个固定不变的 list 或者其他自定义集合类型，这种情况下你需要使用构造函数。 否则，使用字面量语法更加优雅。 核心库中暴露这些构造函数易于扩展，但是通常在 Dart 代码中并不使用构造函数。",
			"",
			"var points = [];",
			"var addresses = {};",
			"",
			"var points = <Point>[];",
			"var addresses = <String, Address>{};",
		],
	},
	"dt-style-不要 使用 .length 来判断一个集合是否为空。": {
		"prefix": "dt-style-不要 使用 .length 来判断一个集合是否为空。",
		"body": [
			"Iterable 合约并不要求集合知道其长度，也没要求在遍历的时候其长度不能改变。 通过调用 .length 来判断集合是否包含内容是非常低效的。",
			"",
			"相反，Dart 提供了更加高效率和易用的 getter 函数：.isEmpty 和.isNotEmpty。 使用这些函数并不需要对结果再次取非。",
			"",
			"if (lunchBox.isEmpty) return 'so hungry...';",
			"if (words.isNotEmpty) return words.join(' ');",
		],
	},
	"dt-style-考虑 使用高阶（higher-order）函数来转换集合数据。": {
		"prefix": "dt-style-考虑 使用高阶（higher-order）函数来转换集合数据。",
		"body": [
			"如果你有一个集合并且想要修改里面的内容转换为另外一个集合， 使用 .map()、 .where() 以及 Iterable 提供的其他函数会让代码更加简洁。",
			"",
			"使用这些函数替代 for 循环会让代码更加可以表述你的意图， 生成一个新的集合系列并不具有副作用。",
			"",
			"var aquaticNames = animals",
			"    .where((animal) => animal.isAquatic)",
			"    .map((animal) => animal.name);",
			"与此同时，这可以非常长， 如果你串联或者嵌套调用很多高阶函数， 则使用一些命令式代码可能会更加清晰",
		],
	},
	"dt-style-不要 使用 List.from() 除非想修改结果的类型。": {
		"prefix": "dt-style-不要 使用 List.from() 除非想修改结果的类型。",
		"body": [
			"给定一个可迭代的对象，有两种常见方式来生成一个包含相同元素的 list：",
			"",
			"var copy1 = iterable.toList();",
			"var copy2 = List.from(iterable);",
			"明显的区别是前一个更短。 更重要的区别在于第一个保留了原始对象的类型参数：",
			"",
			"// Creates a List<int>:",
			"var iterable = [1, 2, 3];",
			"",
			"// Prints \"List<int>\":",
			"print(iterable.toList().runtimeType);",
			"如果你想要改变类型，那么可以调用 List.from() ：",
			"",
			"var numbers = [1, 2.3, 4]; // List<num>.",
			"numbers.removeAt(1); // Now it only contains integers.",
			"var ints = List<int>.from(numbers);",
			"但是如果你的目的只是复制可迭代对象并且保留元素原始类型， 或者并不在乎类型，那么请使用 toList() 。",
		],
	},
	"dt-style-要 使用 whereType() 按类型过滤集合。": {
		"prefix": "dt-style-要 使用 whereType() 按类型过滤集合。",
		"body": [
			"假设你有一个 list 里面包含了多种类型的对象， 但是你指向从它里面获取整型类型的数据。 那么你可以像下面这样使用 where() ：",
			"",
			"var objects = [1, \"a\", 2, \"b\", 3];",
			"var ints = objects.where((e) => e is int);",
			"这个很罗嗦，但是更糟糕的是，它返回的可迭代对象类型可能并不是你想要的。 在上面的例子中，虽然你想得到一个 Iterable<int>，然而它返回了一个 Iterable<Object>， 这是因为，这是你过滤后得到的类型。",
			"",
			"有时候你会看到通过添加 cast() 来“修正”上面的错误：",
			"",
			"var objects = [1, \"a\", 2, \"b\", 3];",
			"var ints = objects.where((e) => e is int).cast<int>();",
			"代码冗长，并导致创建了两个包装器，获取元素对象要间接通过两层，并进行两次多余的运行时检查。 幸运的是，对于这个用例，核心库提供了 whereType()]where-type 方法：",
			"",
			"var objects = [1, \"a\", 2, \"b\", 3];",
			"var ints = objects.whereType<int>();",
			"使用 whereType() 简洁， 生成所需的 Iterable（可迭代）类型， 并且没有不必要的层级包装。",
		],
	},
	"dt-style-不要 使用 cast()，如果有更合适的方法。": {
		"prefix": "dt-style-不要 使用 cast()，如果有更合适的方法。",
		"body": [
			"通常，当处理可迭代对象或 stream 时， 你可以对其执行多次转换。 最后，生成所希望的具有特定类型参数的对象。 尝试查看是否有已有的转换方法来改变类型，而不是去掉用 cast() 。 而不是调用cast（），看看是否有一个现有的转换可以改变类型。",
			"",
			"如果你已经使用了 toList() ，那么请使用 List<T>.from() 替换， 这里的 T 是你想要的返回值的类型。",
			"",
			"var stuff = <dynamic>[1, 2];",
			"var ints = List<int>.from(stuff);",
			"var stuff = <dynamic>[1, 2];",
			"var ints = stuff.toList().cast<int>();",
			"如果你正在调用 map() ，给它一个显式的类型参数， 这样它就能产生一个所需类型的可迭代对象。 类型推断通常根据传递给 map() 的函数选择出正确的类型， 但有的时候需要明确指明。",
			"",
			"var stuff = <dynamic>[1, 2];",
			"var reciprocals = stuff.map<double>((n) => 1 / n);",
			"var stuff = <dynamic>[1, 2];",
			"var reciprocals = stuff.map((n) => 1 / n).cast<double>();",
		],
	},
	"dt-style-避免 使用 cast() ": {
		"prefix": "dt-style-避免 使用 cast() ",
		"body": [
			"这是对先前规则的一个宽松的定义。 有些时候，并没有合适的方式来修改对象类型，即便如此， 也应该尽可能的避免使用 cast() 来“改变”集合中元素的类型。",
			"",
			"推荐使用下面的方式来替代：",
			"",
			"用恰当的类型创建集合。 修改集合被首次创建时的代码， 为集合提供有一个恰当的类型。",
			"",
			"在访问元素时进行 cast 操作。 如果要立即对集合进行迭代， 在迭代内部 cast 每个元素。",
			"",
			"逼不得已进行 cast，请使用 List.from() 。 如果最终你会使用到集合中的大部分元素， 并且不需要对象还原到原始的对象类型，使用 List.from() 来转换它。",
			"",
			"cast() 方法返回一个惰性集合（lazy collection），每个操作都会对元素进行检查。 如果只对少数元素执行少量操作，那么这种惰性方式就非常合适。 但在许多情况下，惰性验证和包裹（wrapping）所产生的开销已经超过了它们所带来的好处。",
			"",
			"下面是 用恰当的类型创建集合 的示例：",
			"",
			"List<int> singletonList(int value) {",
			"  var list = <int>[];",
			"  list.add(value);",
			"  return list;",
			"}",
			"List<int> singletonList(int value) {",
			"  var list = []; // List<dynamic>.",
			"  list.add(value);",
			"  return list.cast<int>();",
			"}",
			"下面是 在访问元素时进行 cast 操作 的示例：",
			"",
			"void printEvens(List<Object> objects) {",
			"  // We happen to know the list only contains ints.",
			"  for (var n in objects) {",
			"    if ((n as int).isEven) print(n);",
			"  }",
			"}",
			"void printEvens(List<Object> objects) {",
			"  // We happen to know the list only contains ints.",
			"  for (var n in objects.cast<int>()) {",
			"    if (n.isEven) print(n);",
			"  }",
			"}",
			"下面是 使用 List.from() 进行 cast 操作 的示例：",
			"",
			"int median(List<Object> objects) {",
			"  // We happen to know the list only contains ints.",
			"  var ints = List<int>.from(objects);",
			"  ints.sort();",
			"  return ints[ints.length ~/ 2];",
			"}",
			"int median(List<Object> objects) {",
			"  // We happen to know the list only contains ints.",
			"  var ints = objects.cast<int>();",
			"  ints.sort();",
			"  return ints[ints.length ~/ 2];",
			"}",
			"当然，这些替代方案并不总能解决问题，显然，这时候就应该选择 cast() 方式了。 但是考虑到这种方式的风险和缺点——如果使用不当，可能会导致执行缓慢和运行失败。",
		],
	},
	"dt-style-不要 使用 lambda 表达式来替代 tear-off。": {
		"prefix": "dt-style-不要 使用 lambda 表达式来替代 tear-off。",
		"body": [
			"如果你在一个对象上调用函数并省略了括号， Dart 称之为”tear-off”—一个和函数使用同样参数的闭包， 当你调用闭包的时候执行其中的函数。",
			"",
			"如果你有一个方法，这个方法调用了参数相同的另一个方法。 那么，你不需要人为将这个方法包装到一个 lambda 表达式中。",
			"",
			"names.forEach(print);",
			"names.forEach((name) {",
			"  print(name);",
			"});",
		],
	},
	"dt-style-要 使用 = 来分隔参数名和参数默认值。": {
		"prefix": "dt-style-要 使用 = 来分隔参数名和参数默认值。",
		"body": [
			"由于遗留原因，Dart 同时支持 : 和 = 作为参数名和默认值的分隔符。 为了与可选的位置参数保持一致，请使用 = 。",
			"",
			"void insert(Object item, {int at = 0}) { ... }",
			"void insert(Object item, {int at: 0}) { ... }",
		],
	},
	"dt-style-不要 显式的为参数设置 null 值。": {
		"prefix": "dt-style-不要 显式的为参数设置 null 值。",
		"body": [
			"如果你创建了一个可选参数，那么就不要为其赋默认值， Dart 默认使用 null 作为默认值，所以这里不需要为其 null 赋值语句。",
			"",
			"void error([String message]) {",
			"  stderr.write(message ?? '\n');",
			"}",
			"void error([String message = null]) {",
			"  stderr.write(message ?? '\n');",
			"}",
			"",
			"在Dart中，未自动显式初始化的变量或字段将初始化为 null 。 语言保证了赋值的可靠性。在 Dart 中没有“未初始化内存”的概念。 所以使用 = null 是多余的。",
			"",
			"int _nextId;",
			"",
			"class LazyId {",
			"  int _id;",
			"",
			"  int get id {",
			"    if (_nextId == null) _nextId = 0;",
			"    if (_id == null) _id = _nextId++;",
			"",
			"    return _id;",
			"  }",
			"}",
			"int _nextId = null;",
			"",
			"class LazyId {",
			"  int _id = null;",
			"",
			"  int get id {",
			"    if (_nextId == null) _nextId = 0;",
			"    if (_id == null) _id = _nextId++;",
			"",
			"    return _id;",
			"  }",
			"}",
		],
	},
	"dt-style-不要 为字段创建不必要的 getter 和 setter 方法。": {
		"prefix": "dt-style-不要 为字段创建不必要的 getter 和 setter 方法。",
		"body": [
			"在 Java 和 C# 中，通常情况下会将所有的字段隐藏到 getter 和 setter 方法中（在 C# 中被称为属性）， 即使实现中仅仅是指向这些字段。在这种方式下，即使你在这些成员上做多少的事情，你也不需要直接访问它们。 这是因为，在 Java 中，调用 getter 方法和直接访问字段是不同的。 在 C# 中，访问属性与访问字段不是二进制兼容的。",
			"",
			"Dart 不存在这个限制。字段和 getter/setter 是完全无法区分的。 你可以在类中公开一个字段，然后将其包装在 getter 和 setter 中， 而不会影响任何使用该字段的代码。",
			"",
			"class Box {",
			"  var contents;",
			"}",
			"class Box {",
			"  var _contents;",
			"  get contents => _contents;",
			"  set contents(value) {",
			"    _contents = value;",
			"  }",
			"}",
		],
	},
	"dt-style-推荐 使用 final 关键字来创建只读属性。": {
		"prefix": "dt-style-推荐 使用 final 关键字来创建只读属性。",
		"body": [
			"如果你有一个变量，对于外部代买来说只能读取不能修改， 最简单的做法就是使用 final 关键字来标记这个变量。",
			"",
			"class Box {",
			"  final contents = [];",
			"}",
			"class Box {",
			"  var _contents;",
			"  get contents => _contents;",
			"}",
			"当然，如果你需要构造一个内部可以赋值，外部可以访问的字段， 你可以需要这种“私有成员变量，公开访问函数”的模式， 但是，如非必要，请不要使用这种模式。",
		],
	},
	"dt-style-考虑 对简单成员使用 =>": {
		"prefix": "dt-style-考虑 对简单成员使用 =>",
		"body": [
			"除了使用 => 可以用作函数表达式以外， Dart 还允许使用它来定义成员。 这种风格非常适合，仅进行计算并返回结果的简单成员。",
			"",
			"double get area => (right - left) * (bottom - top);",
			"",
			"bool isReady(num time) => minTime == null || minTime <= time;",
			"",
			"String capitalize(String name) =>",
			"    '${name[0].toUpperCase()}${name.substring(1)}';",
			"编写代码的人似乎很喜欢 => 语法，但是它很容易被滥用，最后导致代码不容易被阅读。 如果你有很多行声明或包含深层的嵌套表达式（级联和条件运算符就是常见的罪魁祸首）， 你以及其他人有谁会愿意读这样的代码！ 你应该换做使用代码块和一些语句来实现。",
			"",
			"Treasure openChest(Chest chest, Point where) {",
			"  if (_opened.containsKey(chest)) return null;",
			"",
			"  var treasure = Treasure(where);",
			"  treasure.addAll(chest.contents);",
			"  _opened[chest] = treasure;",
			"  return treasure;",
			"}",
		],
	},
	"dt-style-不要 使用 this. ，在重定向命名函数和避免冲突的情况下除外。": {
		"prefix": "dt-style-不要 使用 this. ，在重定向命名函数和避免冲突的情况下除外。",
		"body": [
			"class Box {",
			"  var value;",
			"",
			"  void clear() {",
			"    update(null);",
			"  }",
			"",
			"  void update(value) {",
			"    this.value = value;",
			"  }",
			"}",
			"另一种使用 this. 的情况是在重定向到一个命名函数的时候：",
			"class ShadeOfGray {",
			"  final int brightness;",
			"",
			"  ShadeOfGray(int val) : brightness = val;",
			"",
			"  ShadeOfGray.black() : this(0);",
			"",
			"  // 现在就可以了！",
			"  ShadeOfGray.alsoBlack() : this.black();",
			"}",
			"注意，构造函数初始化列表中的字段有永远不会与构造函数参数列表参数产生冲突。",
			"",
			"class Box extends BaseBox {",
			"  var value;",
			"",
			"  Box(value)",
			"      : value = value,",
			"        super(value);",
			"}",
			"这看起来很令人惊讶，但是实际结果是你想要的。 幸运的是，由于初始化规则的特殊性，上面的代码很少见到。",
		],
	},
	"dt-style-要 尽可能的在定义变量的时候初始化变量值。": {
		"prefix": "dt-style-要 尽可能的在定义变量的时候初始化变量值。",
		"body": [
			"class Folder {",
			"  final String name;",
			"  final List<Document> contents = [];",
			"",
			"  Folder(this.name);",
			"  Folder.temp() : name = 'temporary';",
			"}",
		],
	},
	"dt-style-要 尽可能的使用初始化形式。": {
		"prefix": "dt-style-要 尽可能的使用初始化形式。",
		"body": [
			"为了初始化一个字段，我们需要取_四_次 x 。使用下面的方式会更好：",
			"",
			"class Point {",
			"  num x, y;",
			"  Point(this.x, this.y);",
			"}",
			"这里的位于构造函数参数之前的 this. 语法被称之为初始化形式（initializing formal）。 有些情况下这无法使用这种形式。特别是，这种形式下在初始化列表中无法看到变量。 但是如果能使用该方式，就应该尽量使用。",
		],
	},
	"dt-style-不要 在初始化形式中做类型注释。": {
		"prefix": "dt-style-不要 在初始化形式中做类型注释。",
		"body": [
			"如果构造函数参数使用 this. 的方式来初始化字段， 这时参数的类型被认为和字段类型相同。",
			"",
			"class Point {",
			"  int x, y;",
			"  Point(this.x, this.y);",
			"}",
			"class Point {",
			"  int x, y;",
			"  Point(int this.x, int this.y);",
			"}",
		],
	},
	"dt-style-要 用 ; 来替代空的构造函数体 {}。": {
		"prefix": "dt-style-要 用 ; 来替代空的构造函数体 {}。",
		"body": [
			"在 Dart 中，没有具体函数体的构造函数可以使用分号结尾。 （事实上，这是不可变构造函数的要求。）",
			"",
			"class Point {",
			"  int x, y;",
			"  Point(this.x, this.y);",
			"}",
			"class Point {",
			"  int x, y;",
			"  Point(this.x, this.y) {}",
			"}",
		],
	},
	"dt-style-不要 使用 new 。": {
		"prefix": "dt-style-不要 使用 new 。",
		"body": [
			"为了减少代码迁移时的痛苦， Dart 语言仍允许使用 new 关键字， 但请考在你的代码中弃用和删除 new 。",
			"",
			"Widget build(BuildContext context) {",
			"  return Row(",
			"    children: [",
			"      RaisedButton(",
			"        child: Text('Increment'),",
			"      ),",
			"      Text('Click!'),",
			"    ],",
			"  );",
			"}",
		],
	},
	"dt-style-不要 冗余地使用 const 。": {
		"prefix": "dt-style-不要 冗余地使用 const 。",
		"body": [
			"在表达式一定是常量的上下文中，const 关键字是隐式的，不需要写，也不应该。 这里包括：",
			"",
			"一个字面量常量集合。",
			"调用一个常量构造函数。",
			"元数据注解。",
			"一个常量声明的初始化方法。",
			"switch case 表达式—— case 和 : 中间的部分，不是 case 执行体。",
			"（默认值并不包含在这个列表中，因为在 Dart 将来的版本中可能会在支持非常量的默认值。）",
			"",
			"基本上，任何地方用 new 替代 const 的写法都是错的， 因为 Dart 2 中允许省略 const 。",
			"",
			"const primaryColors = [",
			"  Color(\"red\", [255, 0, 0]),",
			"  Color(\"green\", [0, 255, 0]),",
			"  Color(\"blue\", [0, 0, 255]),",
			"];",
			"const primaryColors = const [",
			"  const Color(\"red\", const [255, 0, 0]),",
			"  const Color(\"green\", const [0, 255, 0]),",
			"  const Color(\"blue\", const [0, 0, 255]),",
			"];",
		],
	},
	"dt-style-要 使用 rethrow 来重新抛出捕获的异常。": {
		"prefix": "dt-style-要 使用 rethrow 来重新抛出捕获的异常。",
		"body": [
			"try {",
			"  somethingRisky();",
			"} catch (e) {",
			"  if (!canHandle(e)) rethrow;",
			"  handle(e);",
			"}",
		],
	},
	"dt-style-推荐 使用 async/await 而不是直接使用底层的特性。": {
		"prefix": "dt-style-推荐 使用 async/await 而不是直接使用底层的特性。",
		"body": [
			"显式的异步代码是非常难以阅读和调试的， 即使使用很好的抽象（比如 future）也是如此。 这就是为何 Dart 提供了 async/await。 这样可以显著的提高代码的可读性并且让你可以在异步代码中使用语言提供的所有流程控制语句。",
			"",
			"Future<int> countActivePlayers(String teamName) async {",
			"  try {",
			"    var team = await downloadTeam(teamName);",
			"    if (team == null) return 0;",
			"",
			"    var players = await team.roster;",
			"    return players.where((player) => player.isActive).length;",
			"  } catch (e) {",
			"    log.error(e);",
			"    return 0;",
			"  }",
			"}",
			"Future<int> countActivePlayers(String teamName) {",
			"  return downloadTeam(teamName).then((team) {",
			"    if (team == null) return Future.value(0);",
			"",
			"    return team.roster.then((players) {",
			"      return players.where((player) => player.isActive).length;",
			"    });",
			"  }).catchError((e) {",
			"    log.error(e);",
			"    return 0;",
			"  });",
			"}",
		],
	},
	"dt-style-不要 在没有有用效果的情况下使用 async 。": {
		"prefix": "dt-style-不要 在没有有用效果的情况下使用 async 。",
		"body": [
			"当成为习惯之后，你可能会在所有和异步相关的函数使用 async。但是在有些情况下， 如果可以忽略 async 而不改变方法的行为，则应该这么做：",
			"",
			"Future afterTwoThings(Future first, Future second) {",
			"  return Future.wait([first, second]);",
			"}",
			"Future afterTwoThings(Future first, Future second) async {",
			"  return Future.wait([first, second]);",
			"}",
			"下面这些情况 async 是有用的：",
			"",
			"你使用了 await。 (这是一个很明显的例子。)",
			"",
			"你在异步的抛出一个异常。 async 然后 throw 比 return new Future.error(...) 要简短很多。",
			"",
			"你在返回一个值，但是你希望他显式的使用 Future。async 比 new Future.value(...) 要简短很多。",
			"",
			"你不希望在事件循环发生事件之前执行任何代码。",
			"",
			"Future usesAwait(Future later) async {",
			"  print(await later);",
			"}",
			"",
			"Future asyncError() async {",
			"  throw 'Error!';",
			"}",
			"",
			"Future asyncValue() async => 'value';",
		],
	},
	"dt-Hello World": {
		"prefix": "dt-Hello World",
		"body": [
			"void main() {",
			"  print('Hello, World!');",
			"}",
		],
	},
	"dt-变量1": {
		"prefix": "dt-变量1",
		"body": [
			"虽然 Dart 代码是类型安全的，但是由于支持类型推断，大多数变量是不需要显式指定类型的：",
			"",
			"var name = 'Voyager I';",
			"var year = 1977;",
			"var antennaDiameter = 3.7;",
			"var flybyObjects = ['Jupiter', 'Saturn', 'Uranus', 'Neptune'];",
			"var image = {",
			"  'tags': ['saturn'],",
			"  'url': '//path/to/saturn.jpg'",
			"};",
			"阅读更多 Dart 中关于变量的内容， 包含默认值， final 和 const 关键字，以及静态类型。",
		],
	},
	"dt-控制流程语句1": {
		"prefix": "dt-控制流程语句2",
		"body": [
			"if (year >= 2001) {",
			"  print('21st century');",
			"} else if (year >= 1901) {",
			"  print('20th century');",
			"}",
			"",
			"for (var object in flybyObjects) {",
			"  print(object);",
			"}",
			"",
			"for (int month = 1; month <= 12; month++) {",
			"  print(month);",
			"}",
			"",
			"while (year < 2016) {",
			"  year += 1;",
			"}",
		],
	},
	"dt-函数2": {
		"prefix": "dt-函数2",
		"body": [
			"指定每个函数的参数类型和返回值：",
			"",
			"int fibonacci(int n) {",
			"  if (n == 0 || n == 1) return n;",
			"  return fibonacci(n - 1) + fibonacci(n - 2);",
			"}",
			"",
			"var result = fibonacci(20);",
			"=>（箭头）语法用于仅包含一条语句的函数。该语法在匿名函数作为函数参数情况中 非常有用。",
			"",
			"flybyObjects.where((name) => name.contains('turn')).forEach(print);",
			"上例除了演示匿名函数（匿名函数作为 where() 的参数），同时也演示了函数作为 参数的使用：顶级函数 print() 是传入 forEach() 方法的一个参数。",
		],
	},
	"dt-注释": {
		"prefix": "dt-注释",
		"body": [
			"// 这是一个标准的单行注释。",
			"",
			"/// 这是一个文档注释，用来为库，类，以及它们的成员提供文档。",
			"/// 像 IDEs 和 dartdoc 的工具会专门处理这些注释来生成文档。",
			"",
			"/* 也支持类似的注释 */",
		],
	},
	"dt-Import": {
		"prefix": "dt-Import",
		"body": [
			"// 导入核心库",
			"import 'dart:math';",
			"",
			"// 从外部包导入库",
			"import 'package:test/test.dart';",
			"",
			"// 导入文件",
			"import 'path/to/my_other_file.dart';",
		],
	},
	"dt-类class": {
		"prefix": "dt-类class",
		"body": [
			"下面是一个关于类的示例，这个类包含三个属性，两个构造函数，以及一个方法。 其中一个属性不能被直接赋值，因此它被定义为一个 getter 方法（而不是变量）。",
			"",
			"class Spacecraft {",
			"  String name;",
			"  DateTime launchDate;",
			"",
			"  // 构造函数，使用语法糖设置成员变量。",
			"  Spacecraft(this.name, this.launchDate) {",
			"    // 这里编写初始化代码。",
			"  }",
			"",
			"  // 命名构造函数，最终调用默认构造函数。",
			"  Spacecraft.unlaunched(String name) : this(name, null);",
			"",
			"  int get launchYear =>",
			"      launchDate?.year; // read-only non-final 属性",
			"",
			"  // 方法。",
			"  void describe() {",
			"    print('Spacecraft: $name');",
			"    if (launchDate != null) {",
			"      int years =",
			"          DateTime.now().difference(launchDate).inDays ~/",
			"              365;",
			"      print('Launched: $launchYear ($years years ago)');",
			"    } else {",
			"      print('Unlaunched');",
			"    }",
			"  }",
			"}",
			"可以像下面这样使用 Spacecraft 这个类：",
			"",
			"var voyager = Spacecraft('Voyager I', DateTime(1977, 9, 5));",
			"voyager.describe();",
			"",
			"var voyager3 = Spacecraft.unlaunched('Voyager III');",
			"voyager3.describe();",
			"阅读更多 Dart 中关于类的内容, 包括初始化列表，可选关键字 new 和 const ，重定向构造函数， factory 构造函数， getter 方法， setter 方法，以及更多类似部分。",
		],
	},
	"dt-扩展类（继承）1": {
		"prefix": "dt-扩展类1（继承）1",
		"body": [
			"class Orbiter extends Spacecraft {",
			"  num altitude;",
			"  Orbiter(String name, DateTime launchDate, this.altitude)",
			"      : super(name, launchDate);",
			"}",
		],
	},
	"dt-Mixin": {
		"prefix": "dt-Mixin",
		"body": [
			"Mixin 是一种在多个类层次结构中重用代码的方法。下面的类可以作为一个 mixin ：",
			"",
			"class Piloted {",
			"  int astronauts = 1;",
			"  void describeCrew() {",
			"    print('Number of astronauts: $astronauts');",
			"  }",
			"}",
			"将 mixin 的功能添加到一个类中，只需要继承这个类并 with 这个 mixin 。",
			"",
			"class PilotedCraft extends Spacecraft with Piloted {",
			"  // ···",
			"}",
			"现在 飞行器 有了 astronauts 字段以及 describeCrew() 方法。",
			"",
			"阅读更多 关于 mixin 的内容.",
		],
	},
	"dt-接口和抽象类": {
		"prefix": "dt-接口和抽象类",
		"body": [
			"Dart 没有 interface 关键字。相反，所有的类都隐式定义了一个接口，因此，任意类都可以作为接口被实现。",
			"",
			"class MockSpaceship implements Spacecraft {",
			"  // ···",
			"}",
			"阅读更多 关于隐式接口的内容。",
			"",
			"创建一个抽象类，这个类可以被一个具体的类去扩展（或实现）。抽象类可以包含抽象方法（只声明未实现）。",
			"",
			"abstract class Describable {",
			"  void describe();",
			"",
			"  void describeWithEmphasis() {",
			"    print('=========');",
			"    describe();",
			"    print('=========');",
			"  }",
			"}",
		],
	},
	"dt-Async": {
		"prefix": "dt-Async",
		"body": [
			"避免回调地狱（callback hell），使用 async 和 await 使代码更具可读性。",
			"",
			"const oneSecond = Duration(seconds: 1);",
			"// ···",
			"Future<void> printWithDelay(String message) async {",
			"  await Future.delayed(oneSecond);",
			"  print(message);",
			"}",
			"上面的方法相当于:",
			"",
			"Future<void> printWithDelay(String message) {",
			"  return Future.delayed(oneSecond).then((_) {",
			"    print(message);",
			"  });",
			"}",
			"如下一个示例所示，async 和 await 有助于使异步代码变的易于阅读。",
			"",
			"Future<void> createDescriptions(Iterable<String> objects) async {",
			"  for (var object in objects) {",
			"    try {",
			"      var file = File('$object.txt');",
			"      if (await file.exists()) {",
			"        var modified = await file.lastModified();",
			"        print(",
			"            'File for $object already exists. It was modified on $modified.');",
			"        continue;",
			"      }",
			"      await file.create();",
			"      await file.writeAsString('Start describing $object in this file.');",
			"    } on IOException catch (e) {",
			"      print('Cannot create description for $object: $e');",
			"    }",
			"  }",
			"}",
			"同样 async* 能够提供一个很棒的，可读的方式去构造 stream 。",
			"",
			"Stream<String> report(Spacecraft craft, Iterable<String> objects) async* {",
			"  for (var object in objects) {",
			"    await Future.delayed(oneSecond);",
			"    yield '${craft.name} flies by $object';",
			"  }",
			"}",
		],
	},
	"dt-异常1": {
		"prefix": "dt-异常1",
		"body": [
			"使用 throw 抛出一个异常：",
			"",
			"if (astronauts == 0) {",
			"  throw StateError('No astronauts.');",
			"}",
			"使用 try 语句以及 on 和 catch（或者两者），捕获一个异常。",
			"",
			"try {",
			"  for (var object in flybyObjects) {",
			"    var description = await File('$object.txt').readAsString();",
			"    print(description);",
			"  }",
			"} on IOException catch (e) {",
			"  print('Could not describe object: $e');",
			"} finally {",
			"  flybyObjects.clear();",
			"}",
			"请注意，上面的代码是异步的; 同步代码以及异步函数代码中都能够使用 try 捕获异常。",
			"",
			"阅读更多 关于异常的内容， 包括栈跟踪（ stack traces ）， rethrow ，以及 Error 和 Exception的区别。",
		],
	},
	"dt-Dart 库概览": {
		"prefix": "dt-Dart 库概览",
		"body": [
			"本章将介绍以下库的主要功能及使用方式， 所有Dart平台中都包含这些库：",
			"",
			"dart:core",
			"内置类型，集合和其他核心功能。 该库会被自动导入到所有的 Dart 程序。",
			"dart:async",
			"支持异步编程，包括Future和Stream等类。",
			"dart:math",
			"数学常数和函数，以及随机数生成器。",
			"dart:convert",
			"用于在不同数据表示之间进行转换的编码器和解码器，包括 JSON 和 UTF-8 。",
			"本章只是一个概述； 只涵盖了几个 dart:* 库， 不包括第三方库。 特定平台库 dart:io 和 dart:html 的介绍，详见 dart:io tour 和 dart:html tour 。",
			"",
			"更多库信息可以在 [pub.dartlang.org][pub.dartlang.org] 和 Dart web developer library guide. 查找。 所有 dart:* 库的 API 文档可以在 Dart API reference 查找， 如果使用的是 Flutter 可以在 [Flutter API reference.][docs.flutter.io] 查找。",
			"",
			"DartPad tip： 可以通过将该页中的代码拷贝到 DartPad 中进行演示。",
		],
	},
	"dt-dart:core - 数字，集合，字符串等": {
		"prefix": "dt-dart:core - 数字，集合，字符串等",
		"body": [
			"dart:core 库 (API reference) 提供了一个少量但是重要的内置功能集合。 该库会被自动导入每个 Dart 程序。",
			"",
			"控制台打印",
			"顶级 print() 方法接受一个参数 任意对象） 并输出显示这个对象的字符串值(由 toString() 返回) 到控制台。",
			"",
			"print(anObject);",
			"print('I drink $tea.');",
			"有关基本字符串和 toString() 的更多信息，参考 Strings in the language tour.",
			"",
			"数字",
			"dart:core 库定义了 num ，int 以及 double 类， 这些类拥有一定的工具方法来处理数字。",
			"",
			"使用 int 和 double 的 parse() 方法将字符串转换为整型或双浮点型对象：",
			"",
			"assert(int.parse('42') == 42);",
			"assert(int.parse('0x42') == 66);",
			"assert(double.parse('0.50') == 0.5);",
			"或者使用 num 的 parse() 方法，该方法可能会创建一个整型，否则为浮点型对象：",
			"",
			"assert(num.parse('42') is int);",
			"assert(num.parse('0x42') is int);",
			"assert(num.parse('0.50') is double);",
			"通过添加 radix 参数，指定整数的进制基数：",
			"",
			"assert(int.parse('42', radix: 16) == 66);",
			"使用 toString() 方法将整型或双精度浮点类型转换为字符串类型。 使用 toStringAsFixed(). 指定小数点右边的位数， 使用 toStringAsPrecision(): 指定字符串中的有效数字的位数。",
			"",
			"// 整型转换为字符串类型。",
			"assert(42.toString() == '42');",
			"",
			"// 双浮点型转换为字符串类型。",
			"assert(123.456.toString() == '123.456');",
			"",
			"// 指定小数点后的位数。",
			"assert(123.456.toStringAsFixed(2) == '123.46');",
			"",
			"// 指定有效数字的位数。",
			"assert(123.456.toStringAsPrecision(2) == '1.2e+2');",
			"assert(double.parse('1.2e+2') == 120.0);",
			"更多详情， 参考 int， double， 和 num 的相关 API 文档。 也可参考 dart:math section。",
		],
	},
	"dt-字符和正则表达式": {
		"prefix": "dt-字符和正则表达式",
		"body": ["可以获取字符串中的单个字符，将其作为字符串或者整数。 确切地说，实际上获取的是单独的UTF-16编码单元; 诸如高音谱号符号 (‘\u{1D11E}’) 之类的高编号字符分别为两个编码单元。",
			"",
			"你也可以获取字符串中的子字符串或者将一个字符串分割为子字符串列表：",
			"",
			"// 抓取一个子字符串。",
			"assert('Never odd or even'.substring(6, 9) == 'odd');",
			"",
			"// 使用字符串模式分割字符串。",
			"var parts = 'structured web apps'.split(' ');",
			"assert(parts.length == 3);",
			"assert(parts[0] == 'structured');",
			"",
			"// 通过下标获取 UTF-16 编码单元（编码单元作为字符串）。",
			"assert('Never odd or even'[0] == 'N');",
			"",
			"// 使用 split() 传入一个空字符串参数，",
			"// 得到一个所有字符的 list 集合；",
			"// 有助于字符迭代。",
			"for (var char in 'hello'.split('')) {",
			"  print(char);",
			"}",
			"",
			"// 获取一个字符串的所有 UTF-16 编码单元。",
			"var codeUnitList =",
			"    'Never odd or even'.codeUnits.toList();",
			"assert(codeUnitList[0] == 78);",
			,
			"首字母大小写转换",
			"可以轻松的对字符串的首字母大小写进行转换：",
			"",
			"// 转换为首字母大写。",
			"assert('structured web apps'.toUpperCase() ==",
			"    'STRUCTURED WEB APPS');",
			"",
			"// 转换为首字母小写。",
			"assert('STRUCTURED WEB APPS'.toLowerCase() ==",
			"    'structured web apps');",
			"提示： 这些方法不是在所有语言上都有效的。例如， 土耳其字母表的无点 I 转换是不正确的。",
			"",
			"Trimming 和空字符串",
			"使用 trim() 移除首尾空格。 使用 isEmpty 检查一个字符串是否为空（长度为0）。",
			"",
			"// Trim a string.",
			"assert('  hello  '.trim() == 'hello');",
			"",
			"// 检查字符串是否为空。",
			"assert(''.isEmpty);",
			"",
			"// 空格字符串不是空字符串。",
			"assert('  '.isNotEmpty);",
			"替换部分字符串",
			"字符串是不可变的对象，也就是说字符串可以创建但是不能被修改。 如果仔细阅读了 String API docs, 你会注意到，没有一个方法实际的改变了字符串的状态。 例如，方法 replaceAll() 返回一个新字符串， 并没有改变原始字符串：",
			"",
			"var greetingTemplate = 'Hello, NAME!';",
			"var greeting =",
			"    greetingTemplate.replaceAll(RegExp('NAME'), 'Bob');",
			"",
			"// greetingTemplate 没有改变。",
			"assert(greeting != greetingTemplate);",
			"构建一个字符串",
			"要以代码方式生成字符串，可以使用 StringBuffer 。 在调用 toString() 之前， StringBuffer 不会生成新字符串对象。 writeAll() 的第二个参数为可选参数，用来指定分隔符， 本例中使用空格作为分隔符。",
			"",
			"var sb = StringBuffer();",
			"sb",
			"  ..write('Use a StringBuffer for ')",
			"  ..writeAll(['efficient', 'string', 'creation'], ' ')",
			"  ..write('.');",
			"",
			"var fullString = sb.toString();",
			"",
			"assert(fullString ==",
			"    'Use a StringBuffer for efficient string creation.');",
		],
	},
	"dt-正则表达式": {
		"prefix": "dt-正则表达式",
		"body": [
			"RegExp类提供与JavaScript正则表达式相同的功能。 使用正则表达式可以对字符串进行高效搜索和模式匹配。",
			"",
			"// 下面正则表达式用于匹配一个或多个数字。",
			"var numbers = RegExp(r'\d+');",
			"",
			"var allCharacters = 'llamas live fifteen to twenty years';",
			"var someDigits = 'llamas live 15 to 20 years';",
			"",
			"// contains() 能够使用正则表达式。",
			"assert(!allCharacters.contains(numbers));",
			"assert(someDigits.contains(numbers));",
			"",
			"// 替换所有匹配对象为另一个字符串。",
			"var exedOut = someDigits.replaceAll(numbers, 'XX');",
			"assert(exedOut == 'llamas live XX to XX years');",
			"你也可以直接使用RegExp类。 Match 类提供对正则表达式匹配对象的访问。",
			"",
			"var numbers = RegExp(r'\d+');",
			"var someDigits = 'llamas live 15 to 20 years';",
			"",
			"// 检查正则表达式是否在字符串中匹配到对象。",
			"assert(numbers.hasMatch(someDigits));",
			"",
			"// 迭代所有匹配对象",
			"for (var match in numbers.allMatches(someDigits)) {",
			"  print(match.group(0)); // 15, then 20",
			"}",
		],
	},
	"dt-Lists": {
		"prefix": "dt-Lists",
		"body": [
			"如语言概览中介绍，lists 可以通过字面量来创建和初始化。 另外，也可以使用 List 的构造函数。 List 类还定义了若干方法，用于向列表添加或删除项目。",
			"",
			"// 使用 List 构造函数。",
			"var vegetables = List();",
			"",
			"// 或者仅使用一个 list 字面量。",
			"var fruits = ['apples', 'oranges'];",
			"",
			"// 添加一个元素到 list 对象。",
			"fruits.add('kiwis');",
			"",
			"// 添加多个元素到 list 对象。",
			"fruits.addAll(['grapes', 'bananas']);",
			"",
			"// 获取 list 长度。",
			"assert(fruits.length == 5);",
			"",
			"// 移除一个元素到 list 对象。",
			"var appleIndex = fruits.indexOf('apples');",
			"fruits.removeAt(appleIndex);",
			"assert(fruits.length == 4);",
			"",
			"// 移除多个元素到 list 对象。",
			"fruits.clear();",
			"assert(fruits.length == 0);",
			"使用 indexOf() 方法查找一个对象在 list 中的下标值。",
			"",
			"var fruits = ['apples', 'oranges'];",
			"",
			"// 使用下标访问 list 中的元素",
			"assert(fruits[0] == 'apples');",
			"",
			"// 查找一个元素在 list 中的下标。",
			"assert(fruits.indexOf('apples') == 0);",
			"使用 sort() 方法排序一个 list 。 你可以提供一个排序函数用于比较两个对象。 比较函数在 小于 时返回 \ <0，相等 时返回 0，bigger 时返回 > 0 。 下面示例中使用 compareTo() 函数， 该函数在 Comparable 中定义， 并被 String 类实现。",
			"",
			"var fruits = ['bananas', 'apples', 'oranges'];",
			"",
			"// 排序一个 list 。",
			"fruits.sort((a, b) => a.compareTo(b));",
			"assert(fruits[0] == 'apples');",
			"list 是参数化类型， 因此可以指定 list 应该包含的元素类型：",
			"",
			"// 这个 list 只能包含字符串类型。",
			"var fruits = List<String>();",
			"",
			"fruits.add('apples');",
			"var fruit = fruits[0];",
			"assert(fruit is String);",
			"",
			"// 产生静态分析警告，num 不是字符串类型。",
			"fruits.add(5); // BAD: Throws exception in checked mode.",
		],
	},
	"dt-Sets": {
		"prefix": "dt-Sets",
		"body": [
			"在 Dart 中，set 是一个无序的，元素唯一的集合。 因为一个 set 是无序的，所以无法通过下标（位置）获取 set 中的元素。",
			"",
			"var ingredients = Set();",
			"ingredients.addAll(['gold', 'titanium', 'xenon']);",
			"assert(ingredients.length == 3);",
			"",
			"// 添加一个重复的元素是无效的。",
			"ingredients.add('gold');",
			"assert(ingredients.length == 3);",
			"",
			"// 从 set 中移除一个元素。",
			"ingredients.remove('gold');",
			"assert(ingredients.length == 2);",
			"使用 contains() 和 containsAll() 来检查一个或多个元素是否在 set 中。",
			"",
			"var ingredients = Set();",
			"ingredients.addAll(['gold', 'titanium', 'xenon']);",
			"",
			"// 检查一个元素是否在该 set 中。",
			"assert(ingredients.contains('titanium'));",
			"",
			"// 检查多个元素是否在该 set 中。",
			"assert(ingredients.containsAll(['titanium', 'xenon']));",
			"交集是另外两个 set 中的公共元素组成的 set 。",
			"",
			"var ingredients = Set();",
			"ingredients.addAll(['gold', 'titanium', 'xenon']);",
			"",
			"// 创建两个 set 的交集。",
			"var nobleGases = Set.from(['xenon', 'argon']);",
			"var intersection = ingredients.intersection(nobleGases);",
			"assert(intersection.length == 1);",
			"assert(intersection.contains('xenon'));",
		],
	},
	"dt-Maps": {
		"prefix": "dt-Maps",
		"body": [
			"map 是一个无序的 key-value （键值对）集合，就是大家熟知的 dictionary 或者 hash。 map 将 kay 与 value 关联，以便于检索。和 JavaScript 不同，Dart 对象不是 map 。",
			"",
			"声明 map 可以使用简洁的字面量语法，也可以使用传统构造函数：",
			"",
			"// map 通常使用字符串作为 key。",
			"var hawaiianBeaches = {",
			"  'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'],",
			"  'Big Island': ['Wailea Bay', 'Pololu Beach'],",
			"  'Kauai': ['Hanalei', 'Poipu']",
			"};",
			"",
			"// map 可以通过构造函数构建。",
			"var searchTerms = Map();",
			"",
			"// map 是参数化类型；",
			"// 可以指定一个 map 中 key 和 value 的类型。",
			"var nobleGases = Map<int, String>();",
			"通过大括号语法可以为 map 添加，获取，设置元素。 使用 remove() 方法从 map 中移除键值对。",
			"",
			"var nobleGases = {54: 'xenon'};",
			"",
			"// 使用 key 检索 value 。",
			"assert(nobleGases[54] == 'xenon');",
			"",
			"// 检查 map 是否包含 key 。",
			"assert(nobleGases.containsKey(54));",
			"",
			"// 移除一个 key 及其 value。",
			"nobleGases.remove(54);",
			"assert(!nobleGases.containsKey(54));",
			"可以从一个 map 中检索出所有的 key 或所有的 value：",
			"",
			"var hawaiianBeaches = {",
			"  'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'],",
			"  'Big Island': ['Wailea Bay', 'Pololu Beach'],",
			"  'Kauai': ['Hanalei', 'Poipu']",
			"};",
			"",
			"// 获取的所有的 key 是一个无序集合",
			"// (可迭代 list 对象)。",
			"var keys = hawaiianBeaches.keys;",
			"",
			"assert(keys.length == 3);",
			"assert(Set.from(keys).contains('Oahu'));",
			"",
			"// 获取的所有的 value 是一个无序集合",
			"// (可迭代 list 对象).",
			"var values = hawaiianBeaches.values;",
			"assert(values.length == 3);",
			"assert(values.any((v) => v.contains('Waikiki')));",
			"使用 containsKey() 方法检查一个 map 中是否包含某个key 。 因为 map 中的 value 可能会是 null ， 所有通过 key 获取 value，并通过判断 value 是否为 null 来判断 key 是否存在是不可靠的。",
			"",
			"var hawaiianBeaches = {",
			"  'Oahu': ['Waikiki', 'Kailua', 'Waimanalo'],",
			"  'Big Island': ['Wailea Bay', 'Pololu Beach'],",
			"  'Kauai': ['Hanalei', 'Poipu']",
			"};",
			"",
			"assert(hawaiianBeaches.containsKey('Oahu'));",
			"assert(!hawaiianBeaches.containsKey('Florida'));",
			"如果当且仅当该 key 不存在于 map 中，且要为这个 key 赋值， 可使用putIfAbsent（）方法。 该方法需要一个方法返回这个 value 。",
			"",
			"var teamAssignments = {};",
			"teamAssignments.putIfAbsent(",
			"    'Catcher', () => pickToughestKid());",
			"assert(teamAssignments['Catcher'] != null);",
		],
	},
	"dt-公共集合方法": {
		"prefix": "dt-公共集合方法",
		"body": [
			"List, Set, 和 Map 共享许多集合中的常用功能。 其中一些常见功能由 Iterable 类定义， 这些函数由 List 和 Set 实现。",
			"",
			"提示： 虽然Map没有实现 Iterable， 但可以使用 Map keys 和 values 属性从中获取 Iterable 对象。",
			"",
			"使用 isEmpty 和 isNotEmpty 方法可以检查 list， set 或 map 对象中是否包含元素：",
			"",
			"var coffees = [];",
			"var teas = ['green', 'black', 'chamomile', 'earl grey'];",
			"assert(coffees.isEmpty);",
			"assert(teas.isNotEmpty);",
			"使用 forEach() 可以让 list， set 或 map 对象中的每个元素都使用一个方法。",
			"",
			"var teas = ['green', 'black', 'chamomile', 'earl grey'];",
			"",
			"teas.forEach((tea) => print('I drink $tea'));",
			"当在 map 对象上调用 `forEach() 方法时，函数必须带两个参数（key 和 value）：",
			"",
			"hawaiianBeaches.forEach((k, v) {",
			"  print('I want to visit $k and swim at $v');",
			"  // 我想去瓦胡岛并且在",
			"  // [Waikiki, Kailua, Waimanalo]游泳， 等等。",
			"});",
			"Iterable 提供 map() 方法，这个方法将所有结果返回到一个对象中。",
			"",
			"var teas = ['green', 'black', 'chamomile', 'earl grey'];",
			"",
			"var loudTeas = teas.map((tea) => tea.toUpperCase());",
			"loudTeas.forEach(print);",
			"提示： map() 方法返回的对象是一个 懒求值（lazily evaluated）对象： 只有当访问对象里面的元素时，函数才会被调用。",
			"",
			"使用 map().toList() 或 map().toSet() ， 可以强制在每个项目上立即调用函数。",
			"",
			"var loudTeas =",
			"    teas.map((tea) => tea.toUpperCase()).toList();",
			"使用 Iterable 的 where() 方法可以获取所有匹配条件的元素。 使用 Iterable 的 any() 和 every() 方法可以检查部分或者所有元素是否匹配某个条件。",
			"",
			"var teas = ['green', 'black', 'chamomile', 'earl grey'];",
			"",
			"// 洋甘菊不含咖啡因。",
			"bool isDecaffeinated(String teaName) =>",
			"    teaName == 'chamomile';",
			"",
			"// 使用 where() 来查找元素，",
			"// 这些元素在给定的函数中返回 true 。",
			"var decaffeinatedTeas =",
			"    teas.where((tea) => isDecaffeinated(tea));",
			"// 或者 teas.where(isDecaffeinated)",
			"",
			"// 使用 any() 来检查集合中是否至少有一个元素满足条件。",
			"assert(teas.any(isDecaffeinated));",
			"",
			"// 使用 every() 来检查集合中是否所有元素满足条件。",
			"assert(!teas.every(isDecaffeinated));",
			"有关方法的完整列表，请参考 Iterable API docs, 以及 List, Set, and Map.",
		],
	},
	"dt-URI": {
		"prefix": "dt-URI",
		"body": [
			"在使用 URI（可能你会称它为 URLs） 时，Uri 类 提供对字符串的编解码操作。 这些函数用来处理 URI 特有的字符，例如 ＆ 和 = 。 Uri 类还可以解析和处理 URI—host，port，scheme等组件。",
			"",
			"编码和解码完整合法的URI",
			"使用 encodeFull() 和 decodeFull() 方法， 对 URI 中除了特殊字符（例如 /， :， &， #）以外的字符进行编解码， 这些方法非常适合编解码完整合法的 URI，并保留 URI 中的特殊字符。",
			"",
			"var uri = 'http://example.org/api?foo=some message';",
			"",
			"var encoded = Uri.encodeFull(uri);",
			"assert(encoded ==",
			"    'http://example.org/api?foo=some%20message');",
			"",
			"var decoded = Uri.decodeFull(encoded);",
			"assert(uri == decoded);",
			"注意上面代码只编码了 some 和 message 之间的空格。",
			"",
			"编码和解码 URI 组件",
			"使用 encodeComponent() 和 decodeComponent() 方法， 对 URI 中具有特殊含义的所有字符串字符，特殊字符包括（但不限于）/， &， 和 :。",
			"",
			"var uri = 'http://example.org/api?foo=some message';",
			"",
			"var encoded = Uri.encodeComponent(uri);",
			"assert(encoded ==",
			"    'http%3A%2F%2Fexample.org%2Fapi%3Ffoo%3Dsome%20message');",
			"",
			"var decoded = Uri.decodeComponent(encoded);",
			"assert(uri == decoded);",
			"注意上面代码编码了所有的字符。例如 / 被编码为 %2F。",
			"",
			"解析 URI",
			"使用 Uri 对象的字段（例如 path）， 来获取一个 Uri 对象或者 URI 字符串的一部分。 使用 parse() 静态方法，可以使用字符串创建 Uri 对象。",
			"",
			"var uri =",
			"    Uri.parse('http://example.org:8080/foo/bar#frag');",
			"",
			"assert(uri.scheme == 'http');",
			"assert(uri.host == 'example.org');",
			"assert(uri.path == '/foo/bar');",
			"assert(uri.fragment == 'frag');",
			"assert(uri.origin == 'http://example.org:8080');",
			"有关 URI 组件的更多内容，参考 Uri API docs 。",
			"",
			"构建 URI",
			"使用 Uri() 构造函数，可以将各组件部分构建成 URI 。",
			"",
			"var uri = Uri(",
			"    scheme: 'http',",
			"    host: 'example.org',",
			"    path: '/foo/bar',",
			"    fragment: 'frag');",
			"assert(",
			"    uri.toString() == 'http://example.org/foo/bar#frag');",
		],
	},
	"dt-日期和时间": {
		"prefix": "dt-日期和时间",
		"body": [
			"DateTime 对象代表某个时刻，时区可以是 UTC 或者 本地时区。",
			"",
			"DateTime 对象可以通过若干构造函数创建：",
			"",
			"// 获取当前时刻。",
			"var now = DateTime.now();",
			"",
			"// 更具本地时区创建 DateTime 对象。",
			"var y2k = DateTime(2000); // January 1, 2000",
			"",
			"// 指定年月日。",
			"y2k = DateTime(2000, 1, 2); // January 2, 2000",
			"",
			"// 将日期指定为 UTC 时区。",
			"y2k = DateTime.utc(2000); // 1/1/2000, UTC",
			"",
			"// 指定自Unix纪元以来，以毫秒为单位的日期和时间。",
			"y2k = DateTime.fromMillisecondsSinceEpoch(946684800000,",
			"    isUtc: true);",
			"",
			"// 解析ISO 8601日期。",
			"y2k = DateTime.parse('2000-01-01T00:00:00Z');",
			"日期中 millisecondsSinceEpoch 属性返回自 “Unix纪元（January 1, 1970, UTC）“以来的毫秒数：",
			"",
			"// 1/1/2000, UTC",
			"var y2k = DateTime.utc(2000);",
			"assert(y2k.millisecondsSinceEpoch == 946684800000);",
			"",
			"// 1/1/1970, UTC",
			"var unixEpoch = DateTime.utc(1970);",
			"assert(unixEpoch.millisecondsSinceEpoch == 0);",
			"使用 Duration 类来计算两个日期的查，也可以对时刻进行前移和后移操作：",
			"",
			"var y2k = DateTime.utc(2000);",
			"",
			"// 增加一年。",
			"var y2001 = y2k.add(const Duration(days: 366));",
			"assert(y2001.year == 2001);",
			"",
			"// 减少30天。",
			"var december2000 =",
			"    y2001.subtract(const Duration(days: 30));",
			"assert(december2000.year == 2000);",
			"assert(december2000.month == 12);",
			"",
			"// 计算两个时刻之间的查，",
			"// 返回 Duration 对象。",
			"var duration = y2001.difference(y2k);",
			"assert(duration.inDays == 366); // y2k was a leap year.",
			"警告： 由于时钟转换（例如，夏令时）的原因， 使用 Duration 对 DateTime 按天移动可能会有问题。 如果要按照天数来位移时间，请使用 UTC 日期。",
			"",
			"参考 DateTime 和 Duration API 文档了解全部方法列表。",
		],
	},
	"dt-比较对象": {
		"prefix": "dt-比较对象",
		"body": [
			"如果实现了 Comparable 接口， 也就是说可以将该对象与另一个对象进行比较， 通常用于排序。 compareTo() 方法在 小于 时返回 < 0， 在 相等 时返回 0， 在 大于 时返回 > 0。",
			"",
			"class Line implements Comparable<Line> {",
			"  final int length;",
			"  const Line(this.length);",
			"",
			"  @override",
			"  int compareTo(Line other) => length - other.length;",
			"}",
			"",
			"void main() {",
			"  var short = const Line(1);",
			"  var long = const Line(100);",
			"  assert(short.compareTo(long) < 0);",
			"}",
		],
	},
	"dt-Implementing map keys (equal ==)": {
		"prefix": "dt-Implementing map keys (equal ==",
		"body": [
			"在 Dart 中每个对象会默认提供一个整数的哈希值， 因此在 map 中可以作为 key 来使用， 重写 hashCode 的 getter 方法来生成自定义哈希值。 如果重写 hashCode 的 getter 方法，那么可能还需要重写 == 运算符。 相等的（通过 == ）对象必须拥有相同的哈希值。 哈希值并不要求是唯一的， 但是应该具有良好的分布形态。。",
			"",
			"class Person {",
			"  final String firstName, lastName;",
			"",
			"  Person(this.firstName, this.lastName);",
			"",
			"  // 重写 hashCode，实现策略源于  Effective Java，",
			"  // 第11章。",
			"  @override",
			"  int get hashCode {",
			"    int result = 17;",
			"    result = 37 * result + firstName.hashCode;",
			"    result = 37 * result + lastName.hashCode;",
			"    return result;",
			"  }",
			"",
			"  // 如果重写了 hashCode，通常应该从新实现 == 操作符。",
			"  @override",
			"  bool operator ==(dynamic other) {",
			"    if (other is! Person) return false;",
			"    Person person = other;",
			"    return (person.firstName == firstName &&",
			"        person.lastName == lastName);",
			"  }",
			"}",
			"",
			"void main() {",
			"  var p1 = Person('Bob', 'Smith');",
			"  var p2 = Person('Bob', 'Smith');",
			"  var p3 = 'not a person';",
			"  assert(p1.hashCode == p2.hashCode);",
			"  assert(p1 == p2);",
			"  assert(p1 != p3);",
			"}",
		],
	},
	"dt-迭代iterable": {
		"prefix": "dt-迭代iterable",
		"body": [
			"Iterable][] 和 Iterator 类支持 for-in 循环。 当创建一个类的时候，继承或者实现 Iterable，可以为该类提供用于 for-in 循环的 Iterators。 实现 Iterator 来定义实际的遍历操作。",
			"",
			"class Process {",
			"  // Represents a process...",
			"}",
			"",
			"class ProcessIterator implements Iterator<Process> {",
			"  @override",
			"  Process get current => ...",
			"  @override",
			"  bool moveNext() => ...",
			"}",
			"",
			"// A mythical class that lets you iterate through all",
			"// processes. Extends a subclass of [Iterable].",
			"class Processes extends IterableBase<Process> {",
			"  @override",
			"  final Iterator<Process> iterator = ProcessIterator();",
			"}",
			"",
			"void main() {",
			"  // Iterable objects can be used with for-in.",
			"  for (var process in Processes()) {",
			"    // Do something with the process.",
			"  }",
			"}",
		],
	},
	"dt-异常2": {
		"prefix": "dt-异常2",
		"body": [
			"Dart 核心库定义了很多公共的异常和错误类。 异常通常是一些可以预见和预知的情况。 错误是无法预见或者预防的情况。",
			"",
			"两个最常见的错误：",
			"",
			"NoSuchMethodError",
			"当方法的接受对象（可能为null）没有实现该方法时抛出。",
			"",
			"ArgumentError",
			"当方法在接受到一个不合法参数时抛出。",
			"",
			"通常通过抛出一个应用特定的异常，来表示应用发生了错误。 通过实现 Exception 接口来自定义异常。",
			"",
			"class FooException implements Exception {",
			"  final String msg;",
			"",
			"  const FooException([this.msg]);",
			"",
			"  @override",
			"  String toString() => msg ?? 'FooException';",
			"}",
			"更多内容，参考 Exceptions 以及 Exception API 文档。",
		],
	},
	"dt-dart:async - 异步编程": {
		"prefix": "dt-dart:async - 异步编程",
		"body": [
			"异步编程通常使用回调方法来实现，但是 Dart 提供了其他方案：Future 和 Stream 对象。 Future 类似与 JavaScript 中的 Promise ， 代表在将来某个时刻会返回一个结果。 Stream 类可以用来获取一系列的值，比如，一些列事件。 Future， Stream，以及更多内容，参考 dart:async library (API reference)。",
			"",
			"提示： 你并不总是需要直接使用 Future 或 Stream 的 API。 Dart 语言支持使用关键字（例如，async 和 await ）来实现异步编程。 更多详情，参考语言概览中 Asynchrony support。",
			"",
			"dart:async 库可以工作在 web 应用及 command-line 应用。 通过 import dart:async 来使用。",
			"",
			"import 'dart:async';",
			"版本提示： 从 Dart 2.1 开始，使用 Future 和 Stream 不需要导入 dart:async ， 因为 dart:core 库 export 了这些类。",
		],
	},
	"dt-Future": {
		"prefix": "dt-Future",
		"body": [
			"在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个 Future。 当一个 future 完成执行后，future 中的值就已经可以使用了。",
			"",
			"使用 await",
			"在直接使用 Future API 前，首先应该考虑 await 来替代。 代码中使用 await 表达式会比直接使用 Future API 更容易理解。",
			"",
			"阅读思考下面代码。 代码使用 Future 的 then() 方法在同一行执行了三个异步函数， 要等待上一个执行完成，再执行下一个任务之。",
			"",
			"runUsingFuture() {",
			"  // ...",
			"  findEntryPoint().then((entryPoint) {",
			"    return runExecutable(entryPoint, args);",
			"  }).then(flushThenExit);",
			"}",
			"通过 await 表达式实现等价的代码， 看起来非常像同步代码：",
			"",
			"runUsingAsyncAwait() async {",
			"  // ...",
			"  var entryPoint = await findEntryPoint();",
			"  var exitCode = await runExecutable(entryPoint, args);",
			"  await flushThenExit(exitCode);",
			"}",
			"async 函数能够捕获来自 Future 的异常。 例如：",
			"",
			"var entryPoint = await findEntryPoint();",
			"try {",
			"  var exitCode = await runExecutable(entryPoint, args);",
			"  await flushThenExit(exitCode);",
			"} catch (e) {",
			"  // Handle the error...",
			"}",
			"重要： async 函数 返回 Future 对象。 如果你不希望你的函数返回一个 future 对象， 可以使用其他方案。 例如，你可以在你的方法中调用一个 async 方法。",
			"",
			"更多关于 await 的使用及相关的 Dart 语言特征，参考 Asynchrony support。",
			"",
			"基本用法",
			"当 future 执行完成后，then() 中的代码会被执行。",
			"",
			"then() 中的代码会在 future 完成后被执行。 例如， HttpRequest.getString() 返回一个 future 对象，因为 HTTP 请求可能需要一段时间。 当 Future 完成并且保证字符串值有效后，使用 then() 来执行你需要的代码：",
			"",
			"HttpRequest.getString(url).then((String result) {",
			"  print(result);",
			"});",
			"使用 catchError() 来处理一些 Future 对象可能抛出的错误或者异常。",
			"",
			"HttpRequest.getString(url).then((String result) {",
			"  print(result);",
			"}).catchError((e) {",
			"  // Handle or ignore the error.",
			"});",
			"then().catchError() 组合是 try-catch 的异步版本。",
			"",
			"重要： 确保调用 catchError() 方式在 then() 的结果上，而不是在原来的 Future 对象上调用。 否则的话，catchError() 就只能处理原来 Future 对象抛出的异常， 而无法处理 then() 代码里面的异常。",
			"",
			"链式异步编程",
			"then() 方法返回一个 Future 对象， 这样就提供了一个非常好的方式让多个异步方法按顺序依次执行。 如果用 then() 注册的回调返回一个 Future ， 那么 then() 返回一个等价的 Future 。 如果回调返回任何其他类型的值， 那么 then() 会创建一个以该值完成的新 Future 。",
			"",
			"Future result = costlyQuery(url);",
			"result",
			"    .then((value) => expensiveWork(value))",
			"    .then((_) => lengthyComputation())",
			"    .then((_) => print('Done!'))",
			"    .catchError((exception) {",
			"  /* Handle exception... */",
			"});",
			"在上面的示例中，方法按下面顺序执行：",
			"",
			"costlyQuery()",
			"expensiveWork()",
			"lengthyComputation()",
			"这是使用 await 编写的等效代码：",
			"",
			"try {",
			"  final value = await costlyQuery(url);",
			"  await expensiveWork(value);",
			"  await lengthyComputation();",
			"  print('Done!');",
			"} catch (e) {",
			"  /* Handle exception... */",
			"}",
		],
	},
	"dt-等待多个 Future": {
		"prefix": "dt-等待多个 Future",
		"body": [
			"有时代码逻辑需要调用多个异步函数， 并等待它们全部完成后再继续执行。 使用 Future.wait() 静态方法管理多个 Future 以及等待它们完成：",
			"",
			"Future deleteLotsOfFiles() async =>  ...",
			"Future copyLotsOfFiles() async =>  ...",
			"Future checksumLotsOfOtherFiles() async =>  ...",
			"",
			"await Future.wait([",
			"  deleteLotsOfFiles(),",
			"  copyLotsOfFiles(),",
			"  checksumLotsOfOtherFiles(),",
			"]);",
			"print('Done with all the long steps!');",
		],
	},
	"dt-Stream": {
		"prefix": "dt-Stream",
		"body": [
			"在 Dart API 中 Stream 对象随处可见，Stream 用来表示一些列数据。 例如，HTML 中的按钮点击就是通过 stream 传递的。 同样也可以将文件作为数据流来读取。",
			"",
			"异步循环",
			"有时，可以使用异步 for 循环 await for ，来替代 Stream API 。",
			"",
			"思考下面示例函数。 它使用 Stream 的 listen() 方法来订阅文件列表， 传入一个搜索文件或目录的函数。",
			"",
			"void main(List<String> arguments) {",
			"  // ...",
			"  FileSystemEntity.isDirectory(searchPath).then((isDir) {",
			"    if (isDir) {",
			"      final startingDir = Directory(searchPath);",
			"      startingDir",
			"          .list(",
			"              recursive: argResults[recursive],",
			"              followLinks: argResults[followLinks])",
			"          .listen((entity) {",
			"        if (entity is File) {",
			"          searchFile(entity, searchTerms);",
			"        }",
			"      });",
			"    } else {",
			"      searchFile(File(searchPath), searchTerms);",
			"    }",
			"  });",
			"}",
			"下面是使用 await 表达式和异步 for 循环 (await for) 实现的等价的代码， 看起来更像是同步代码：",
			"",
			"Future main(List<String> arguments) async {",
			"  // ...",
			"  if (await FileSystemEntity.isDirectory(searchPath)) {",
			"    final startingDir = Directory(searchPath);",
			"    await for (var entity in startingDir.list(",
			"        recursive: argResults[recursive],",
			"        followLinks: argResults[followLinks])) {",
			"      if (entity is File) {",
			"        searchFile(entity, searchTerms);",
			"      }",
			"    }",
			"  } else {",
			"    searchFile(File(searchPath), searchTerms);",
			"  }",
			"}",
			"重要： 在使用 await for 前，确认这样能保持代码清晰， 并希望获取所有 stream 的结果。 例如，你通常并 不 会使用 await for 来监听 DOM 事件， 因为 DOM 会发送无尽的流事件。 如果在同一行使用 await for 注册两个 DOM 事件， 那么第二个事件永远不会被处理。",
			"",
			"有关 await 的使用及 Dart 语言的相关信息，参考 Asynchrony support。",
			"",
			"监听流数据（stream data）",
			"使用 await for 或者使用 listen() 方法监听 stream， 来获取每个到达的数据流值：",
			"",
			"// 通过 ID 获取 button 并添加事件处理函数。",
			"querySelector('#submitInfo').onClick.listen((e) {",
			"  // 当 button 被点击是，该代码会执行。",
			"  submitData();",
			"});",
			"下面示例中，ID 为 “submitInfo” button 提供的 onClick 属性是一个 Stream 对象。",
			"",
			"如果只关心其中一个事件，可以使用，例如，first， last，或 single 属性来获取。 要在处理时间前对事件进行测试，可以使用，例如 firstWhere()， lastWhere()， 或 singleWhere() 方法。",
			"",
			"如果只关心事件中的一个子集，可以使用，例如，skip()， skipWhile()，take()，takeWhile()， 和 where()。",
			"",
			"传递流数据（stream data）",
			"常常，在使用流数据前需要改变数据的格式。 使用 transform() 方法生成具有不同类型数据的流：",
			"",
			"var lines = inputStream",
			"    .transform(utf8.decoder)",
			"    .transform(LineSplitter());",
			"上面例子中使用了两个 transformer 。 第一个使用 utf8.decoder 将整型流转换为字符串流。 接着，使用了 LineSplitter 将字符串流转换为多行字符串流。 这些 transformer 来自 dart:convert 库 （参考dart:convert section）。",
		],
	},
	"dt-dart:math": {
		"prefix": "dt-dart:math",
		"body": [
			"dart:math 库（API reference） 提供通用的功能，例如，正弦和余弦， 最大值和最小值，以及数学常数，例如 pi 和 e。 大多数在 Math 库中的功能是作为顶级函数实现的。",
			"",
			"通过 import dart:math 来引入使用该库。 下面的实例中使用 math 前缀，来说明顶级函数及常量源于 Math 库。",
			"",
			"import 'dart:math';",
			"三角函数",
			"Math 库提供基本的三角函数：",
			"",
			"// Cosine",
			"assert(cos(pi) == -1.0);",
			"",
			"// Sine",
			"var degrees = 30;",
			"var radians = degrees * (pi / 180);",
			"// radians is now 0.52359.",
			"var sinOf30degrees = sin(radians);",
			"// sin 30° = 0.5",
			"assert((sinOf30degrees - 0.5).abs() < 0.01);",
			"提示： 这些函数参数单位是弧度，不是角度！",
			"",
			"最大值和最小值",
			"Math 库提供 max() 和 min() 方法：",
			"",
			"assert(max(1, 1000) == 1000);",
			"assert(min(1, -1000) == -1000);",
			"数学常数",
			"在 Math 库中可以找到你需要的数学常熟，例如，pi， e 等等：",
			"",
			"// See the Math library for additional constants.",
			"print(e); // 2.718281828459045",
			"print(pi); // 3.141592653589793",
			"print(sqrt2); // 1.4142135623730951",
			"随机数",
			"使用 Random 类产生随机数。 可以为 Random 构造函数提供一个可选的种子参数。",
			"",
			"var random = Random();",
			"random.nextDouble(); // Between 0.0 and 1.0: [0, 1)",
			"random.nextInt(10); // Between 0 and 9.",
			"也可以产生随机布尔值序列：",
			"",
			"var random = Random();",
			"random.nextBool(); // true or false",
		],
	},
	"dt-dart:convert ": {
		"prefix": "dt-dart:convert ",
		"body": [
			"dart:convert 库 （API reference）提供 JSON 和 UTF-8 转换器， 以及创建其他转换器。 JSON 是一种用于表示结构化对象和集合的简单文本格式。 UTF-8 是一种常见的可变宽度编码，可以表示Unicode字符集中的每个字符。",
			"",
			"dart:convert 库可以在 web 及 命令行应用中使用。 使用时，通过 import dart:convert 引入。",
			"",
			"import 'dart:convert';",
			"编解码JSON",
			"使用 jsonDecode() 解码 JSON 编码的字符串为 Dart 对象：",
			"",
			"// 提示：在 JSON 字符串中，必须使用双引号（\"）,",
			"// 而不是单引号（'）。",
			"// 下面是 JSON 字符串，非 Dart 字符串。",
			"var jsonString = '''",
			"  [",
			"    {\"score\": 40},",
			"    {\"score\": 80}",
			"  ]",
			"''';",
			"",
			"var scores = jsonDecode(jsonString);",
			"assert(scores is List);",
			"",
			"var firstScore = scores[0];",
			"assert(firstScore is Map);",
			"assert(firstScore['score'] == 40);",
			"使用 jsonEncode() 编码 Dart 对象为 JSON 格式的字符串：",
			"",
			"var scores = [",
			"  {'score': 40},",
			"  {'score': 80},",
			"  {'score': 100, 'overtime': true, 'special_guest': null}",
			"];",
			"",
			"var jsonText = jsonEncode(scores);",
			"assert(jsonText ==",
			"    '[{\"score\":40},{\"score\":80},'",
			"    '{\"score\":100,\"overtime\":true,'",
			"    '\"special_guest\":null}]');",
			"只有 int， double， String， bool, null, List, 或者 Map 类型对象可以直接编码成 JSON。 List 和 Map 对象进行递归编码。",
			"",
			"不能直接编码的对象有两种方式对其编码。 第一种方式是调用 encode() 时赋值第二个参数， 这个参数是一个函数， 该函数返回一个能够直接编码的对象 第二种方式是省略第二个参数，着这种情况下编码器调用对象的 toJson() 方法。 更多示例及 JSON 包相关链接，参考 JSON Support 。",
		],
	},
	"dt-编解码 UTF-8 字符": {
		"prefix": "dt-编解码 UTF-8 字符",
		"body": [
			"使用 utf8.decode() 解码 UTF8 编码的字符创为 Dart 字符创：",
			"",
			"List<int> utf8Bytes = [",
			"  0xc3, 0x8e, 0xc3, 0xb1, 0xc5, 0xa3, 0xc3, 0xa9,",
			"  0x72, 0xc3, 0xb1, 0xc3, 0xa5, 0xc5, 0xa3, 0xc3,",
			"  0xae, 0xc3, 0xb6, 0xc3, 0xb1, 0xc3, 0xa5, 0xc4,",
			"  0xbc, 0xc3, 0xae, 0xc5, 0xbe, 0xc3, 0xa5, 0xc5,",
			"  0xa3, 0xc3, 0xae, 0xe1, 0xbb, 0x9d, 0xc3, 0xb1",
			"];",
			"",
			"var funnyWord = utf8.decode(utf8Bytes);",
			"",
			"assert(funnyWord == 'Îñţérñåţîöñåļîžåţîờñ');",
			"将 UTF-8 字符串流转换为 Dart 字符串，为 Stream 的 transform() 方法上指定 utf8.decoder：",
			"",
			"var lines = inputStream",
			"    .transform(utf8.decoder)",
			"    .transform(LineSplitter());",
			"try {",
			"  await for (var line in lines) {",
			"    print('Got ${line.length} characters from stream');",
			"  }",
			"  print('file is now closed');",
			"} catch (e) {",
			"  print(e);",
			"}",
			"使用 utf8.encode() 将 Dart 字符串编码为一个 UTF8 编码的字节流：",
			"",
			"List<int> encoded = utf8.encode('Îñţérñåţîöñåļîžåţîờñ');",
			"",
			"assert(encoded.length == utf8Bytes.length);",
			"for (int i = 0; i < encoded.length; i++) {",
			"  assert(encoded[i] == utf8Bytes[i]);",
			"}",
		],
	},
	"dt-没有interface": {
		"prefix": "dt-没有interface",
		"body": [
			"没有interface"
		],
	},
	"dt-api-sum": {
		"prefix": "dt-api-sum",
		"body": [
			"Uri dartlang = Uri.parse('http://dartlang.org/');",
			"DateTime now = new DateTime.now();",
			"DateTime berlinWallFell = new DateTime(1989, 11, 9);",
			"DateTime moonLanding = DateTime.parse(\"1969-07-20\");",
			"Create a Duration object specifying the individual time units.",
			"",
			"Duration timeRemaining = new Duration(hours:56, minutes:14);",
			"Map sidekicks = { 'Batman': 'Robin',",
			"                  'Superman': 'Lois Lane',",
			"                  'Harry Potter': 'Ron and Hermione' };",
			"A List is an ordered collection of objects, with a length. Lists are sometimes called arrays. Use a List when you need to access objects by index.",
			"",
			"List superheroes = [ 'Batman', 'Superman', 'Harry Potter' ];",
			"A Set is an unordered collection of unique objects. You cannot get an item by index (position). Adding a duplicate item has no effect.",
			"",
			"Set villains = new Set();",
			"villains.add('Joker');",
			"villains.addAll( ['Lex Luther', 'Voldemort'] );",
			"var numbers = new RegExp(r'\\d+');",
			"StringBuffer moreShakespeare = new StringBuffer();",
			"moreShakespeare.write('And all the men and women ');",
			"moreShakespeare.write('merely players; ...');",
			"String shakespeareQuote = \"All the world's a stage, ...\";",
			"int meaningOfLife = 42;",
			"double valueOfPi  = 3.141592;",
			"bool visible      = true;",
		],
	},
	"dt-api-DateTime": {
		"prefix": "dt-api-DateTime",
		"body": [
			"var now = new DateTime.now();",
			"var berlinWallFell = new DateTime.utc(1989, 11, 9);",
			"var moonLanding = DateTime.parse(\"1969-07-20 20:18:04Z\");  // 8:18pm",
			"A DateTime object is anchored either in the UTC time zone or in the local time zone of the current computer when the object is created.",
			"",
			"Once created, neither the value nor the time zone of a DateTime object may be changed.",
			"",
			"You can use properties to get the individual units of a DateTime object.",
			"",
			"assert(berlinWallFell.month == 11);",
			"assert(moonLanding.hour == 20);",
			"For convenience and readability, the DateTime class provides a constant for each day and month name - for example, august and friday. You can use these constants to improve code readability:",
			"",
			"var berlinWallFell = new DateTime.utc(1989, DateTime.november, 9);",
			"assert(berlinWallFell.weekday == DateTime.thursday);",
			"Day and month values begin at 1, and the week starts on Monday. That is, the constants january and monday are both 1.",
			"",
			"Working with UTC and local time",
			"A DateTime object is in the local time zone unless explicitly created in the UTC time zone.",
			"",
			"var dDay = new DateTime.utc(1944, 6, 6);",
			"Use isUtc to determine whether a DateTime object is based in UTC. Use the methods toLocal and toUtc to get the equivalent date/time value specified in the other time zone. Use timeZoneName to get an abbreviated name of the time zone for the DateTime object. To find the difference between UTC and the time zone of a DateTime object call timeZoneOffset.",
			"",
			"Comparing DateTime objects",
			"The DateTime class contains several handy methods, such as isAfter, isBefore, and isAtSameMomentAs, for comparing DateTime objects.",
			"",
			"assert(berlinWallFell.isAfter(moonLanding) == true);",
			"assert(berlinWallFell.isBefore(moonLanding) == false);",
			"Using DateTime with Duration",
			"Use the add and subtract methods with a Duration object to create a new DateTime object based on another. For example, to find the date that is sixty days (24 * 60 hours) after today, write:",
			"",
			"var now = new DateTime.now();",
			"var sixtyDaysFromNow = now.add(new Duration(days: 60));",
			"To find out how much time is between two DateTime objects use difference, which returns a Duration object:",
			"",
			"var difference = berlinWallFell.difference(moonLanding);",
			"assert(difference.inDays == 7416);",
		],
	},
	"dt-api-List": {
		"prefix": "dt-api-List",
		"body": [
			"The following code illustrates that some List implementations support only a subset of the API.",
			"",
			"List<int> fixedLengthList = new List(5);",
			"fixedLengthList.length = 0;  // Error",
			"fixedLengthList.add(499);    // Error",
			"fixedLengthList[0] = 87;",
			"List<int> growableList = [1, 2];",
			"growableList.length = 0;",
			"growableList.add(499);",
			"growableList[0] = 87;",
		],
	},
	"dt-api-Duration": {
		"prefix": "dt-api-Duration",
		"body": [
			"Duration fastestMarathon = new Duration(hours:2, minutes:3, seconds:2);",
			"The Duration is the sum of all individual parts. This means that individual parts can be larger than the next-bigger unit. For example, inMinutes can be greater than 59.",
			"",
			"assert(fastestMarathon.inMinutes == 123);",
			"All individual parts are allowed to be negative.",
			"",
			"Use one of the properties, such as inDays, to retrieve the integer value of the Duration in the specified time unit. Note that the returned value is rounded down. For example,",
			"",
			"Duration aLongWeekend = new Duration(hours:88);",
			"assert(aLongWeekend.inDays == 3);",
		],
	},
	"dt-api-Future": {
		"prefix": "dt-api-Future",
		"body": [
			"Future<int> future = getFuture();",
			"future.then((value) => handleValue(value))",
			"      .catchError((error) => handleError(error));",
			"A Future can be completed in two ways: with a value (\"the future succeeds\") or with an error (\"the future fails\"). Users can install callbacks for each case.",
			"",
			"In some cases we say that a future is completed with another future. This is a short way of stating that the future is completed in the same way, with the same value or error, as the other future once that completes. Whenever a function in the core library may complete a future (for example Completer.complete or new Future.value), then it also accepts another future and does this work for the developer.",
			"",
			"The result of registering a pair of callbacks is a new Future (the \"successor\") which in turn is completed with the result of invoking the corresponding callback. The successor is completed with an error if the invoked callback throws. For example:",
			"",
			"Future<int> successor = future.then((int value) {",
			"    // Invoked when the future is completed with a value.",
			"    return 42;  // The successor is completed with the value 42.",
			"  },",
			"  onError: (e) {",
			"    // Invoked when the future is completed with an error.",
			"    if (canHandle(e)) {",
			"      return 499;  // The successor is completed with the value 499.",
			"    } else {",
			"      throw e;  // The successor is completed with the error e.",
			"    }",
			"  });",
			"If a future does not have a successor when it completes with an error, it forwards the error message to the global error-handler. This behavior makes sure that no error is silently dropped. However, it also means that error handlers should be installed early, so that they are present as soon as a future is completed with an error. The following example demonstrates this potential bug:",
			"",
			"var future = getFuture();",
			"new Timer(new Duration(milliseconds: 5), () {",
			"  // The error-handler is not attached until 5 ms after the future has",
			"  // been received. If the future fails before that, the error is",
			"  // forwarded to the global error-handler, even though there is code",
			"  // (just below) to eventually handle the error.",
			"  future.then((value) { useValue(value); },",
			"              onError: (e) { handleError(e); });",
			"});",
			"When registering callbacks, it's often more readable to register the two callbacks separately, by first using then with one argument (the value handler) and using a second catchError for handling errors. Each of these will forward the result that they don't handle to their successors, and together they handle both value and error result. It also has the additional benefit of the catchError handling errors in the then value callback too. Using sequential handlers instead of parallel ones often leads to code that is easier to reason about. It also makes asynchronous code very similar to synchronous code:",
			"",
			"// Synchronous code.",
			"try {",
			"  int value = foo();",
			"  return bar(value);",
			"} catch (e) {",
			"  return 499;",
			"}",
			"Equivalent asynchronous code, based on futures:",
			"",
			"Future<int> future = new Future(foo);  // Result of foo() as a future.",
			"future.then((int value) => bar(value))",
			"      .catchError((e) => 499);",
		],
	},
	"dt-api-RegExp": {
		"prefix": "dt-api-RegExp",
		"body": [
			"The following example finds all matches of a regular expression in a string.",
			"",
			"RegExp exp = new RegExp(r\"(\w+)\");",
			"String str = \"Parse my string\";",
			"Iterable<RegExpMatch> matches = exp.allMatches(str);",
		],
	},
	"dt-api-error": {
		"prefix": "dt-api-error",
		"body": [
			"AbstractClassInstantiationError",
			"ArgumentError",
			"AssertionError",
			"CastError",
			"ConcurrentModificationError",
			"CyclicInitializationError",
			"Error",
			"Exception",
			"FallThroughError",
			"FormatException",
			"IndexError",
			"IntegerDivisionByZeroException",
			"LateInitializationError",
			"NoSuchMethodError",
			"NullThrownError",
			"OutOfMemoryError",
			"RangeError",
			"StackOverflowError",
			"StateError",
			"TypeError",
			"UnimplementedError",
			"UnsupportedError",
		],
	},
	"dt-api-File": {
		"prefix": "dt-api-File",
		"body": [
			"import 'dart:async';",
			"import 'dart:io';",
			"",
			"void main() {",
			"  new File('file.txt').readAsString().then((String contents) {",
			"    print(contents);",
			"  });",
			"}",
			"A more flexible and useful way to read a file is with a Stream. Open the file with openRead, which returns a stream that provides the data in the file as chunks of bytes. Listen to the stream for data and process as needed. You can use various transformers in succession to manipulate the data into the required format or to prepare it for output.",
			"",
			"You might want to use a stream to read large files, to manipulate the data with transformers, or for compatibility with another API, such as WebSockets.",
			"",
			"import 'dart:io';",
			"import 'dart:convert';",
			"import 'dart:async';",
			"",
			"main() {",
			"  final file = new File('file.txt');",
			"  Stream<List<int>> inputStream = file.openRead();",
			"",
			"  inputStream",
			"    .transform(utf8.decoder)       // Decode bytes to UTF-8.",
			"    .transform(new LineSplitter()) // Convert stream to individual lines.",
			"    .listen((String line) {        // Process results.",
			"        print('$line: ${line.length} bytes');",
			"      },",
			"      onDone: () { print('File is now closed.'); },",
			"      onError: (e) { print(e.toString()); });",
			"}",
			"Write to a file",
			"To write a string to a file, use the writeAsString method:",
			"",
			"import 'dart:io';",
			"",
			"void main() {",
			"  final filename = 'file.txt';",
			"  new File(filename).writeAsString('some content')",
			"    .then((File file) {",
			"      // Do something with the file.",
			"    });",
			"}",
			"You can also write to a file using a Stream. Open the file with openWrite, which returns an IOSink to which you can write data. Be sure to close the sink with the IOSink.close method.",
			"",
			"import 'dart:io';",
			"",
			"void main() {",
			"  var file = new File('file.txt');",
			"  var sink = file.openWrite();",
			"  sink.write('FILE ACCESSED ${new DateTime.now()}\n');",
			"",
			"  // Close the IOSink to free system resources.",
			"  sink.close();",
			"}",
			"The use of Futures",
			"To avoid unintentional blocking of the program, several methods use a Future to return a value. For example, the length method, which gets the length of a file, returns a Future. Use then to register a callback function, which is called when the value is ready.",
			"",
			"import 'dart:io';",
			"",
			"main() {",
			"  final file = new File('file.txt');",
			"",
			"  file.length().then((len) {",
			"    print(len);",
			"  });",
			"}",
		],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-api-": {
		"prefix": "dt-api-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	},
	"dt-": {
		"prefix": "dt-",
		"body": [],
	}
}