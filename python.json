{
  "py-version": {
    "prefix": "py-version",
    "body": [
      "python -V"
    ]
  },
  "py-print": {
    "prefix": "py-print",
    "body": [
      "print(\"Hello, World!\")"
    ]
  },
  "py-commandList": {
    "prefix": "py-commandList",
    "body": [
      "-d在解析时显示调试信息",
      "-O生成优化代码 ( .pyo 文件 )",
      "-S启动时不引入查找Python路径的位置",
      "-V输出Python版本号",
      "-X从 1.6版本之后基于内建的异常（仅仅用于字符串）已过时。",
      "-c cmd 执行 Python 脚本，并将运行结果作为 cmd 字符串。",
      "file 在给定的python文件执行python脚本。"
    ]
  },
  "py-行与缩进": {
    "prefix": "py-行与缩进",
    "body": [
      "if True:",
      "    print (\"True\")",
      "else:",
      "    print (\"False\")"
    ]
  },
  "py-多行语句": {
    "prefix": "py-多行语句",
    "body": [
      "total = item_one + \\",
      "        item_two + \\",
      "        item_three",
      "",
      "在 [], {}, 或 () 中的多行语句，不需要使用反斜杠()，例如：",
      "",
      "total = ['item_one', 'item_two', 'item_three',",
      "        'item_four', 'item_five']"
    ]
  },
  "py-number-python中数字有四种类型": {
    "prefix": "py-number-python中数字有四种类型",
    "body": [
      "python中数字有四种类型：整数、布尔型、浮点数和复数。",
      "",
      "int (整数), 如 1, 只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。",
      "bool (布尔), 如 True。",
      "float (浮点数), 如 1.23、3E-2",
      "complex (复数), 如 1 + 2j、 1.1 + 2.2j"
    ]
  },
  "py-String": {
    "prefix": "py-String",
    "body": [
      "word = '字符串'",
      "sentence = \"这是一个句子。\"",
      "paragraph = \"\"\"这是一个段落，",
      "可以由多行组成\"\"\""
    ]
  },
  "py-String2": {
    "prefix": "py-String2",
    "body": [
      "",
      "str='Runoob'",
      " ",
      "print(str)                 # 输出字符串",
      "print(str[0:-1])           # 输出第一个到倒数第二个的所有字符",
      "print(str[0])              # 输出字符串第一个字符",
      "print(str[2:5])            # 输出从第三个开始到第五个的字符",
      "print(str[2:])             # 输出从第三个开始后的所有字符",
      "print(str * 2)             # 输出字符串两次",
      "print(str + '你好')        # 连接字符串",
      " ",
      "print('------------------------------')",
      " ",
      "print('hello\nrunoob')      # 使用反斜杠()+n转义特殊字符",
      "print(r'hello\nrunoob')     # 在字符串前面添加一个 r，表示原始字符串，不会发生转义"
    ]
  },
  "py-同一行显示多条语句": {
    "prefix": "py-同一行显示多条语句",
    "body": [
      "Python可以在同一行中使用多条语句，语句之间使用分号(;)分割，以下是一个简单的实例：",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "import sys; x = 'runoob'; sys.stdout.write(x + '\n')"
    ]
  },
  "py-Print 输出": {
    "prefix": "py-Print 输出",
    "body": [
      "print 默认输出是换行的，如果要实现不换行需要在变量末尾加上 end=\"\"：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "x=\"a\"",
      "y=\"b\"",
      "# 换行输出",
      "print( x )",
      "print( y )",
      " ",
      "print('---------')",
      "# 不换行输出",
      "print( x, end=\" \" )",
      "print( y, end=\" \" )",
      "print()"
    ]
  },
  "py-import 与 from...import": {
    "prefix": "py-import 与 from...import",
    "body": [
      "在 python 用 import 或者 from...import 来导入相应的模块。",
      "",
      "将整个模块(somemodule)导入，格式为： import somemodule",
      "",
      "从某个模块中导入某个函数,格式为： from somemodule import somefunction",
      "",
      "从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc",
      "",
      "将某个模块中的全部函数导入，格式为： from somemodule import *",
      "",
      "导入 sys 模块",
      "import sys",
      "print('================Python import mode==========================')",
      "print ('命令行参数为:')",
      "for i in sys.argv:",
      "    print (i)",
      "print ('\n python 路径为',sys.path)",
      "导入 sys 模块的 argv,path 成员",
      "from sys import argv,path  #  导入特定的成员",
      " ",
      "print('================python from import===================================')",
      "print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path"
    ]
  },
  "py-数据类型": {
    "prefix": "py-数据类型",
    "body": [
      "counter = 100          # 整型变量",
      "miles   = 1000.0       # 浮点型变量",
      "name    = \"runoob\"     # 字符串",
      "",
      "print (counter)",
      "print (miles)",
      "print (name)"
    ]
  },
  "py-多个变量赋值": {
    "prefix": "py-多个变量赋值",
    "body": [
      "Python允许你同时为多个变量赋值。例如：",
      "",
      "a = b = c = 1",
      "以上实例，创建一个整型对象，值为 1，从后向前赋值，三个变量被赋予相同的数值。",
      "",
      "您也可以为多个对象指定多个变量。例如：",
      "",
      "a, b, c = 1, 2, \"runoob\"",
      "以上实例，两个整型对象 1 和 2 的分配给变量 a 和 b，字符串对象 \"runoob\" 分配给变量 c。"
    ]
  },
  "py-标准数据类型": {
    "prefix": "py-标准数据类型",
    "body": [
      "Python3 中有六个标准的数据类型：",
      "",
      "Number（数字）",
      "String（字符串）",
      "List（列表）",
      "Tuple（元组）",
      "Set（集合）",
      "Dictionary（字典）",
      "Python3 的六个标准数据类型中：",
      "",
      "不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；",
      "可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。"
    ]
  },
  "py-Number2": {
    "prefix": "py-Number2",
    "body": [
      "Python3 支持 int、float、bool、complex（复数）。",
      "",
      "在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。",
      "",
      "像大多数语言一样，数值类型的赋值和计算都是很直观的。",
      "",
      "内置的 type() 函数可以用来查询变量所指的对象类型。",
      "",
      ">>> a, b, c, d = 20, 5.5, True, 4+3j",
      ">>> print(type(a), type(b), type(c), type(d))",
      "<class 'int'> <class 'float'> <class 'bool'> <class 'complex'>",
      "此外还可以用 isinstance 来判断：",
      "",
      "实例",
      ">>> a = 111",
      ">>> isinstance(a, int)",
      "True",
      ">>>",
      "isinstance 和 type 的区别在于：",
      "",
      "type()不会认为子类是一种父类类型。",
      "isinstance()会认为子类是一种父类类型。",
      ">>> class A:",
      "...     pass",
      "... ",
      ">>> class B(A):",
      "...     pass",
      "... ",
      ">>> isinstance(A(), A)",
      "True",
      ">>> type(A()) == A ",
      "True",
      ">>> isinstance(B(), A)",
      "True",
      ">>> type(B()) == A",
      "False"
    ]
  },
  "py-isinstance": {
    "prefix": "py-isinstance",
    "body": [
      ">>> class A:",
      "...     pass",
      "... ",
      ">>> class B(A):",
      "...     pass",
      "... ",
      ">>> isinstance(A(), A)",
      "True",
      ">>> type(A()) == A ",
      "True",
      ">>> isinstance(B(), A)",
      "True",
      ">>> type(B()) == A",
      "False"
    ]
  },
  "py-del": {
    "prefix": "py-del",
    "body": [
      "del语句的语法是：",
      "",
      "del var1[,var2[,var3[....,varN]]]",
      "您可以通过使用del语句删除单个或多个对象。例如：",
      "",
      "del var",
      "del var_a, var_b"
    ]
  },
  "py-数值运算": {
    "prefix": "py-数值运算",
    "body": [
      ">>> 5 + 4  # 加法",
      "9",
      ">>> 4.3 - 2 # 减法",
      "2.3",
      ">>> 3 * 7  # 乘法",
      "21",
      ">>> 2 / 4  # 除法，得到一个浮点数",
      "0.5",
      ">>> 2 // 4 # 除法，得到一个整数",
      "0",
      ">>> 17 % 3 # 取余",
      "2",
      ">>> 2 ** 5 # 乘方",
      "32"
    ]
  },
  "py-注意1": {
    "prefix": "py-注意1",
    "body": [
      "1、Python可以同时为多个变量赋值，如a, b = 1, 2。",
      "2、一个变量可以通过赋值指向不同类型的对象。",
      "3、数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。",
      "4、在混合计算时，Python会把整型转换成为浮点数。"
    ]
  },
  "py-String3": {
    "prefix": "py-String3",
    "body": [
      "",
      "str = 'Runoob'",
      "",
      "print (str)          # 输出字符串",
      "print (str[0:-1])    # 输出第一个到倒数第二个的所有字符",
      "print (str[0])       # 输出字符串第一个字符",
      "print (str[2:5])     # 输出从第三个开始到第五个的字符",
      "print (str[2:])      # 输出从第三个开始的后的所有字符",
      "print (str * 2)      # 输出字符串两次，也可以写成 print (2 * str)",
      "print (str + \"TEST\") # 连接字符串"
    ]
  },
  "py-Python 没有单独的字符类型，一个字符就是长度为1的字符串。": {
    "prefix": "py-Python 没有单独的字符类型，一个字符就是长度为1的字符串。",
    "body": [
      ">>> word = 'Python'",
      ">>> print(word[0], word[5])",
      "P n",
      ">>> print(word[-1], word[-6])",
      "n P"
    ]
  },
  "py-list": {
    "prefix": "py-list",
    "body": [
      "",
      "list = [ 'abcd', 786 , 2.23, 'runoob', 70.2 ]",
      "tinylist = [123, 'runoob']",
      "",
      "print (list)            # 输出完整列表",
      "print (list[0])         # 输出列表第一个元素",
      "print (list[1:3])       # 从第二个开始输出到第三个元素",
      "print (list[2:])        # 输出从第三个元素开始的所有元素",
      "print (tinylist * 2)    # 输出两次列表",
      "print (list + tinylist) # 连接列表",
      "以上实例输出结果：",
      "",
      "['abcd', 786, 2.23, 'runoob', 70.2]",
      "abcd",
      "[786, 2.23]",
      "[2.23, 'runoob', 70.2]",
      "[123, 'runoob', 123, 'runoob']",
      "['abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob']",
      "与Python字符串不一样的是，列表中的元素是可以改变的：",
      "",
      "实例",
      ">>> a = [1, 2, 3, 4, 5, 6]",
      ">>> a[0] = 9",
      ">>> a[2:5] = [13, 14, 15]",
      ">>> a",
      "[9, 2, 13, 14, 15, 6]",
      ">>> a[2:5] = []   # 将对应的元素值设置为 []",
      ">>> a",
      "[9, 2, 6]",
      "List 内置了有很多方法，例如 append()、pop() 等等，这在后面会讲到。",
      "",
      "注意：",
      "",
      "1、List写在方括号之间，元素用逗号隔开。",
      "2、和字符串一样，list可以被索引和切片。",
      "3、List可以使用+操作符进行拼接。",
      "4、List中的元素是可以改变的。",
      "Python 列表截取可以接收第三个参数，参数作用是截取的步长，以下实例在索引 1 到索引 4 的位置并设置为步长为 2（间隔一个位置）来截取字符串：",
      "",
      "",
      "",
      "如果第三个参数为负数表示逆向读取，以下实例用于翻转字符串：",
      "",
      "实例",
      "def reverseWords(input):",
      "     ",
      "    # 通过空格将字符串分隔符，把各个单词分隔为列表",
      "    inputWords = input.split(\" \")",
      " ",
      "    # 翻转字符串",
      "    # 假设列表 list = [1,2,3,4],  ",
      "    # list[0]=1, list[1]=2 ，而 -1 表示最后一个元素 list[-1]=4 ( 与 list[3]=4 一样)",
      "    # inputWords[-1::-1] 有三个参数",
      "    # 第一个参数 -1 表示最后一个元素",
      "    # 第二个参数为空，表示移动到列表末尾",
      "    # 第三个参数为步长，-1 表示逆向",
      "    inputWords=inputWords[-1::-1]",
      " ",
      "    # 重新组合字符串",
      "    output = ' '.join(inputWords)",
      "     ",
      "    return output",
      " ",
      "if __name__ == \"__main__\":",
      "    input = 'I like runoob'",
      "    rw = reverseWords(input)",
      "    print(rw)",
      "输出结果为：",
      "",
      "runoob like I"
    ]
  },
  "py-Tuple": {
    "prefix": "py-Tuple",
    "body": [
      "元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。",
      "",
      "元组中的元素类型也可以不相同：",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "tuple = ( 'abcd', 786 , 2.23, 'runoob', 70.2  )",
      "tinytuple = (123, 'runoob')",
      "",
      "print (tuple)             # 输出完整元组",
      "print (tuple[0])          # 输出元组的第一个元素",
      "print (tuple[1:3])        # 输出从第二个元素开始到第三个元素",
      "print (tuple[2:])         # 输出从第三个元素开始的所有元素",
      "print (tinytuple * 2)     # 输出两次元组",
      "print (tuple + tinytuple) # 连接元组",
      "以上实例输出结果：",
      "",
      "('abcd', 786, 2.23, 'runoob', 70.2)",
      "abcd",
      "(786, 2.23)",
      "(2.23, 'runoob', 70.2)",
      "(123, 'runoob', 123, 'runoob')",
      "('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')",
      "元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。",
      "",
      "其实，可以把字符串看作一种特殊的元组。",
      "",
      "实例",
      ">>> tup = (1, 2, 3, 4, 5, 6)",
      ">>> print(tup[0])",
      "1",
      ">>> print(tup[1:5])",
      "(2, 3, 4, 5)",
      ">>> tup[0] = 11  # 修改元组元素的操作是非法的",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 1, in <module>",
      "TypeError: 'tuple' object does not support item assignment",
      ">>>",
      "虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。",
      "",
      "构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：",
      "",
      "tup1 = ()    # 空元组",
      "tup2 = (20,) # 一个元素，需要在元素后添加逗号",
      "string、list 和 tuple 都属于 sequence（序列）。",
      "",
      "注意：",
      "",
      "1、与字符串一样，元组的元素不能修改。",
      "2、元组也可以被索引和切片，方法一样。",
      "3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。",
      "4、元组也可以使用+操作符进行拼接。"
    ]
  },
  "py-Set": {
    "prefix": "py-Set",
    "body": [
      "集合（set）是由一个或数个形态各异的大小整体组成的，构成集合的事物或对象称作元素或是成员。",
      "",
      "基本功能是进行成员关系测试和删除重复元素。",
      "",
      "可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。",
      "",
      "创建格式：",
      "",
      "parame = {value01,value02,...}",
      "或者",
      "set(value)",
      "实例",
      "#!/usr/bin/python3",
      "",
      "sites = {'Google', 'Taobao', 'Runoob', 'Facebook', 'Zhihu', 'Baidu'}",
      "",
      "print(sites)   # 输出集合，重复的元素被自动去掉",
      "",
      "# 成员测试",
      "if 'Runoob' in sites :",
      "    print('Runoob 在集合中')",
      "else :",
      "    print('Runoob 不在集合中')",
      "",
      "",
      "# set可以进行集合运算",
      "a = set('abracadabra')",
      "b = set('alacazam')",
      "",
      "print(a)",
      "",
      "print(a - b)     # a 和 b 的差集",
      "",
      "print(a | b)     # a 和 b 的并集",
      "",
      "print(a & b)     # a 和 b 的交集",
      "",
      "print(a ^ b)     # a 和 b 中不同时存在的元素",
      "以上实例输出结果：",
      "",
      "{'Zhihu', 'Baidu', 'Taobao', 'Runoob', 'Google', 'Facebook'}",
      "Runoob 在集合中",
      "{'b', 'c', 'a', 'r', 'd'}",
      "{'r', 'b', 'd'}",
      "{'b', 'c', 'a', 'z', 'm', 'r', 'l', 'd'}",
      "{'c', 'a'}",
      "{'z', 'b', 'm', 'r', 'l', 'd'}"
    ]
  },
  "py-Dictionary": {
    "prefix": "py-Dictionary",
    "body": [
      "字典（dictionary）是Python中另一个非常有用的内置数据类型。",
      "",
      "列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。",
      "",
      "字典是一种映射类型，字典用 { } 标识，它是一个无序的 键(key) : 值(value) 的集合。",
      "",
      "键(key)必须使用不可变类型。",
      "",
      "在同一个字典中，键(key)必须是唯一的。",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "dict = {}",
      "dict['one'] = \"1 - 菜鸟教程\"",
      "dict[2]     = \"2 - 菜鸟工具\"",
      "",
      "tinydict = {'name': 'runoob','code':1, 'site': 'www.runoob.com'}",
      "",
      "",
      "print (dict['one'])       # 输出键为 'one' 的值",
      "print (dict[2])           # 输出键为 2 的值",
      "print (tinydict)          # 输出完整的字典",
      "print (tinydict.keys())   # 输出所有键",
      "print (tinydict.values()) # 输出所有值",
      "以上实例输出结果：",
      "",
      "1 - 菜鸟教程",
      "2 - 菜鸟工具",
      "{'name': 'runoob', 'code': 1, 'site': 'www.runoob.com'}",
      "dict_keys(['name', 'code', 'site'])",
      "dict_values(['runoob', 1, 'www.runoob.com'])",
      "构造函数 dict() 可以直接从键值对序列中构建字典如下：",
      "",
      "实例",
      ">>> dict([('Runoob', 1), ('Google', 2), ('Taobao', 3)])",
      "{'Runoob': 1, 'Google': 2, 'Taobao': 3}",
      ">>> {x: x**2 for x in (2, 4, 6)}",
      "{2: 4, 4: 16, 6: 36}",
      ">>> dict(Runoob=1, Google=2, Taobao=3)",
      "{'Runoob': 1, 'Google': 2, 'Taobao': 3}",
      ">>>",
      "",
      "另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。",
      "",
      "注意：",
      "",
      "1、字典是一种映射类型，它的元素是键值对。",
      "2、字典的关键字必须为不可变类型，且不能重复。",
      "3、创建空字典使用 { }。"
    ]
  },
  "py-数据类型转换": {
    "prefix": "py-数据类型转换",
    "body": [
      "int(x [,base])",
      "",
      "将x转换为一个整数",
      "",
      "float(x)",
      "",
      "将x转换到一个浮点数",
      "",
      "complex(real [,imag])",
      "",
      "创建一个复数",
      "",
      "str(x)",
      "",
      "将对象 x 转换为字符串",
      "",
      "repr(x)",
      "",
      "将对象 x 转换为表达式字符串",
      "",
      "eval(str)",
      "",
      "用来计算在字符串中的有效Python表达式,并返回一个对象",
      "",
      "tuple(s)",
      "",
      "将序列 s 转换为一个元组",
      "",
      "list(s)",
      "",
      "将序列 s 转换为一个列表",
      "",
      "set(s)",
      "",
      "转换为可变集合",
      "",
      "dict(d)",
      "",
      "创建一个字典。d 必须是一个 (key, value)元组序列。",
      "",
      "frozenset(s)",
      "",
      "转换为不可变集合",
      "",
      "chr(x)",
      "",
      "将一个整数转换为一个字符",
      "",
      "ord(x)",
      "",
      "将一个字符转换为它的整数值",
      "",
      "hex(x)",
      "",
      "将一个整数转换为一个十六进制字符串",
      "",
      "oct(x)",
      "",
      "将一个整数转换为一个八进制字符串"
    ]
  },
  "py-算术运算符": {
    "prefix": "py-算术运算符",
    "body": [
      "+加 - 两个对象相加 a + b 输出结果 31",
      "-减 - 得到负数或是一个数减去另一个数  a - b 输出结果 -11",
      "*乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 210",
      "/除 - x 除以 y     b / a 输出结果 2.1",
      "%取模 - 返回除法的余数b % a 输出结果 1",
      "**幂 - 返回x的y次幂a**b 为10的21次方",
      "//取整除 - 向下取接近商的整数",
      ">>> 9//2",
      "4",
      ">>> -9//2",
      "-5",
      "",
      "a = 21",
      "b = 10",
      "c = 0",
      " ",
      "c = a + b",
      "print (\"1 - c 的值为：\", c)",
      " ",
      "c = a - b",
      "print (\"2 - c 的值为：\", c)",
      " ",
      "c = a * b",
      "print (\"3 - c 的值为：\", c)",
      " ",
      "c = a / b",
      "print (\"4 - c 的值为：\", c)",
      " ",
      "c = a % b",
      "print (\"5 - c 的值为：\", c)",
      " ",
      "# 修改变量 a 、b 、c",
      "a = 2",
      "b = 3",
      "c = a**b ",
      "print (\"6 - c 的值为：\", c)",
      " ",
      "a = 10",
      "b = 5",
      "c = a//b ",
      "print (\"7 - c 的值为：\", c)",
      "以上实例输出结果：",
      "",
      "1 - c 的值为： 31",
      "2 - c 的值为： 11",
      "3 - c 的值为： 210",
      "4 - c 的值为： 2.1",
      "5 - c 的值为： 1",
      "6 - c 的值为： 8",
      "7 - c 的值为： 2"
    ]
  },
  "py-比较运算符": {
    "prefix": "py-比较运算符",
    "body": [
      "以下假设变量a为10，变量b为20：",
      "",
      "运算符描述实例",
      "== 等于 - 比较对象是否相等 (a == b) 返回 False。",
      "!= 不等于 - 比较两个对象是否不相等 (a != b) 返回 True。",
      ">大于 - 返回x是否大于y (a > b) 返回 False。",
      "<小于 - 返回x是否小于y。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a < b) 返回 True。",
      ">=大于等于 - 返回x是否大于等于y。(a >= b) 返回 False。",
      "<=小于等于 - 返回x是否小于等于y。(a <= b) 返回 True。",
      "以下实例演示了Python所有比较运算符的操作：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 21",
      "b = 10",
      "c = 0",
      " ",
      "if ( a == b ):",
      "   print (\"1 - a 等于 b\")",
      "else:",
      "   print (\"1 - a 不等于 b\")",
      " ",
      "if ( a != b ):",
      "   print (\"2 - a 不等于 b\")",
      "else:",
      "   print (\"2 - a 等于 b\")",
      " ",
      "if ( a < b ):",
      "   print (\"3 - a 小于 b\")",
      "else:",
      "   print (\"3 - a 大于等于 b\")",
      " ",
      "if ( a > b ):",
      "   print (\"4 - a 大于 b\")",
      "else:",
      "   print (\"4 - a 小于等于 b\")",
      " ",
      "# 修改变量 a 和 b 的值",
      "a = 5;",
      "b = 20;",
      "if ( a <= b ):",
      "   print (\"5 - a 小于等于 b\")",
      "else:",
      "   print (\"5 - a 大于  b\")",
      " ",
      "if ( b >= a ):",
      "   print (\"6 - b 大于等于 a\")",
      "else:",
      "   print (\"6 - b 小于 a\")",
      "以上实例输出结果：",
      "",
      "1 - a 不等于 b",
      "2 - a 不等于 b",
      "3 - a 大于等于 b",
      "4 - a 大于 b",
      "5 - a 小于等于 b",
      "6 - b 大于等于 a"
    ]
  },
  "py-赋值运算符": {
    "prefix": "py-赋值运算符",
    "body": [
      "以下假设变量a为10，变量b为20：",
      "",
      "运算符描述实例",
      "= 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c",
      "+= 加法赋值运算符c += a 等效于 c = c + a",
      "-=减法赋值运算符c -= a 等效于 c = c - a",
      "*=乘法赋值运算符c *= a 等效于 c = c * a",
      "/=除法赋值运算符c /= a 等效于 c = c / a",
      "%=取模赋值运算符c %= a 等效于 c = c % a",
      "**=幂赋值运算符c **= a 等效于 c = c ** a",
      "//=取整除赋值运算符c //= a 等效于 c = c // a",
      ":=海象运算符 可在表达式内部为变量赋值 Python3.8 版本新增运算符。",
      "在这个示例中 赋值表达式可以避免调用 len() 两次:",
      "",
      "if (n := len(a)) > 10:",
      "    print(f\"List is too long ({n} elements, expected <= 10)\")",
      "以下实例演示了Python所有赋值运算符的操作：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 21",
      "b = 10",
      "c = 0",
      " ",
      "c = a + b",
      "print (\"1 - c 的值为：\", c)",
      " ",
      "c += a",
      "print (\"2 - c 的值为：\", c)",
      " ",
      "c *= a",
      "print (\"3 - c 的值为：\", c)",
      " ",
      "c /= a ",
      "print (\"4 - c 的值为：\", c)",
      " ",
      "c = 2",
      "c %= a",
      "print (\"5 - c 的值为：\", c)",
      " ",
      "c **= a",
      "print (\"6 - c 的值为：\", c)",
      " ",
      "c //= a",
      "print (\"7 - c 的值为：\", c)",
      "以上实例输出结果：",
      "",
      "1 - c 的值为： 31",
      "2 - c 的值为： 52",
      "3 - c 的值为： 1092",
      "4 - c 的值为： 52.0",
      "5 - c 的值为： 2",
      "6 - c 的值为： 2097152",
      "7 - c 的值为： 99864"
    ]
  },
  "py-位运算符": {
    "prefix": "py-位运算符",
    "body": [
      "按位运算符是把数字看作二进制来进行计算的。Python中的按位运算法则如下：",
      "",
      "下表中变量 a 为 60，b 为 13二进制格式如下：",
      "",
      "a = 0011 1100",
      "",
      "b = 0000 1101",
      "",
      "-----------------",
      "",
      "a&b = 0000 1100",
      "",
      "a|b = 0011 1101",
      "",
      "a^b = 0011 0001",
      "",
      "~a  = 1100 0011",
      "运算符描述实例",
      "&按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0(a & b) 输出结果 12 ，二进制解释： 0000 1100",
      "|按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。(a | b) 输出结果 61 ，二进制解释： 0011 1101",
      "^按位异或运算符：当两对应的二进位相异时结果为1 (a ^ b) 输出结果 49 二进制解释：0011 0001",
      "~按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。",
      "<<左移动运算符：运算数的各二进位全部左移若干位，由\"<<\"右边的数指定移动的位数，高位丢弃，低位补0。a << 2 输出结果 240 ，二进制解释： 1111 0000",
      ">>右移动运算符：把\">>\"左边的运算数的各二进位全部右移若干位，\">>\"右边的数指定移动的位数a >> 2 输出结果 15 ，二进制解释： 0000 1111",
      "以下实例演示了Python所有位运算符的操作：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 60            # 60 = 0011 1100 ",
      "b = 13            # 13 = 0000 1101 ",
      "c = 0",
      " ",
      "c = a & b;        # 12 = 0000 1100",
      "print (\"1 - c 的值为：\", c)",
      " ",
      "c = a | b;        # 61 = 0011 1101 ",
      "print (\"2 - c 的值为：\", c)",
      " ",
      "c = a ^ b;        # 49 = 0011 0001",
      "print (\"3 - c 的值为：\", c)",
      " ",
      "c = ~a;           # -61 = 1100 0011",
      "print (\"4 - c 的值为：\", c)",
      " ",
      "c = a << 2;       # 240 = 1111 0000",
      "print (\"5 - c 的值为：\", c)",
      " ",
      "c = a >> 2;       # 15 = 0000 1111",
      "print (\"6 - c 的值为：\", c)",
      "以上实例输出结果：",
      "",
      "1 - c 的值为： 12",
      "2 - c 的值为： 61",
      "3 - c 的值为： 49",
      "4 - c 的值为： -61",
      "5 - c 的值为： 240",
      "6 - c 的值为： 15"
    ]
  },
  "py-逻辑运算符": {
    "prefix": "py-逻辑运算符",
    "body": [
      "Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:",
      "",
      "运算符	逻辑表达式	描述	实例",
      "and	x and y	布尔\"与\" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。	(a and b) 返回 20。",
      "or	x or y	布尔\"或\" - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。	(a or b) 返回 10。",
      "not	not x	布尔\"非\" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。	not(a and b) 返回 False",
      "以上实例输出结果：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 10",
      "b = 20",
      " ",
      "if ( a and b ):",
      "   print (\"1 - 变量 a 和 b 都为 true\")",
      "else:",
      "   print (\"1 - 变量 a 和 b 有一个不为 true\")",
      " ",
      "if ( a or b ):",
      "   print (\"2 - 变量 a 和 b 都为 true，或其中一个变量为 true\")",
      "else:",
      "   print (\"2 - 变量 a 和 b 都不为 true\")",
      " ",
      "# 修改变量 a 的值",
      "a = 0",
      "if ( a and b ):",
      "   print (\"3 - 变量 a 和 b 都为 true\")",
      "else:",
      "   print (\"3 - 变量 a 和 b 有一个不为 true\")",
      " ",
      "if ( a or b ):",
      "   print (\"4 - 变量 a 和 b 都为 true，或其中一个变量为 true\")",
      "else:",
      "   print (\"4 - 变量 a 和 b 都不为 true\")",
      " ",
      "if not( a and b ):",
      "   print (\"5 - 变量 a 和 b 都为 false，或其中一个变量为 false\")",
      "else:",
      "   print (\"5 - 变量 a 和 b 都为 true\")",
      "以上实例输出结果：",
      "",
      "1 - 变量 a 和 b 都为 true",
      "2 - 变量 a 和 b 都为 true，或其中一个变量为 true",
      "3 - 变量 a 和 b 有一个不为 true",
      "4 - 变量 a 和 b 都为 true，或其中一个变量为 true",
      "5 - 变量 a 和 b 都为 false，或其中一个变量为 false"
    ]
  },
  "py-身份运算符": {
    "prefix": "py-身份运算符",
    "body": [
      "身份运算符用于比较两个对象的存储单元",
      "",
      "运算符描述实例",
      "is is 是判断两个标识符是不是引用自一个对象 x is y, 类似 id(x) == id(y) , 如果引用的是同一个对象则返回 True，否则返回 False",
      "is not    is not 是判断两个标识符是不是引用自不同对象  x is not y ， 类似 id(a) != id(b)。如果引用的不是同一个对象则返回结果 True，否则返回 False。",
      "注： id() 函数用于获取对象内存地址。",
      "",
      "以下实例演示了Python所有身份运算符的操作：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 20",
      "b = 20",
      " ",
      "if ( a is b ):",
      "   print (\"1 - a 和 b 有相同的标识\")",
      "else:",
      "   print (\"1 - a 和 b 没有相同的标识\")",
      " ",
      "if ( id(a) == id(b) ):",
      "   print (\"2 - a 和 b 有相同的标识\")",
      "else:",
      "   print (\"2 - a 和 b 没有相同的标识\")",
      " ",
      "# 修改变量 b 的值",
      "b = 30",
      "if ( a is b ):",
      "   print (\"3 - a 和 b 有相同的标识\")",
      "else:",
      "   print (\"3 - a 和 b 没有相同的标识\")",
      " ",
      "if ( a is not b ):",
      "   print (\"4 - a 和 b 没有相同的标识\")",
      "else:",
      "   print (\"4 - a 和 b 有相同的标识\")",
      "以上实例输出结果：",
      "",
      "1 - a 和 b 有相同的标识",
      "2 - a 和 b 有相同的标识",
      "3 - a 和 b 没有相同的标识",
      "4 - a 和 b 没有相同的标识"
    ]
  },
  "py-is 与 == 区别：": {
    "prefix": "py-is 与 == 区别",
    "body": [
      "is 与 == 区别：",
      "",
      "is 用于判断两个变量引用对象是否为同一个， == 用于判断引用变量的值是否相等。",
      "",
      ">>>a = [1, 2, 3]",
      ">>> b = a",
      ">>> b is a ",
      "True",
      ">>> b == a",
      "True",
      ">>> b = a[:]",
      ">>> b is a",
      "False",
      ">>> b == a",
      "True"
    ]
  },
  "py-and 拥有更高优先级": {
    "prefix": "py-and 拥有更高优先级",
    "body": [
      "and 拥有更高优先级:",
      "",
      "实例",
      "x = True",
      "y = False",
      "z = False",
      " ",
      "if x or y and z:",
      "    print(\"yes\")",
      "else:",
      "    print(\"no\")",
      "以上实例输出结果：",
      "",
      "yes"
    ]
  },
  "py-Number": {
    "prefix": "py-Number",
    "body": [
      "Python 支持三种不同的数值类型：",
      "",
      "整型(Int) - 通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。",
      "浮点型(float) - 浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）",
      "复数( (complex)) - 复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。",
      "我们可以使用十六进制和八进制来代表整数：",
      "",
      ">>> number = 0xA0F # 十六进制",
      ">>> number",
      "2575",
      "",
      ">>> number=0o37 # 八进制",
      ">>> number",
      "31"
    ]
  },
  "py-数字类型转换": {
    "prefix": "py-数字类型转换",
    "body": [
      "有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。",
      "",
      "int(x) 将x转换为一个整数。",
      "",
      "float(x) 将x转换到一个浮点数。",
      "",
      "complex(x) 将x转换到一个复数，实数部分为 x，虚数部分为 0。",
      "",
      "complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。",
      "",
      "以下实例将浮点数变量 a 转换为整数：",
      "",
      ">>> a = 1.0",
      ">>> int(a)",
      "1"
    ]
  },
  "py- 数字运算": {
    "prefix": "py- 数字运算",
    "body": [
      "Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。",
      "",
      "表达式的语法很直白： +, -, * 和 /, 和其它语言（如Pascal或C）里一样。例如：",
      "",
      ">>> 2 + 2",
      "4",
      ">>> 50 - 5*6",
      "20",
      ">>> (50 - 5*6) / 4",
      "5.0",
      ">>> 8 / 5  # 总是返回一个浮点数",
      "1.6",
      "注意：在不同的机器上浮点运算的结果可能会不一样。",
      "",
      "在整数除法中，除法 / 总是返回一个浮点数，如果只想得到整数的结果，丢弃可能的分数部分，可以使用运算符 // ：",
      "",
      ">>> 17 / 3  # 整数除法返回浮点型",
      "5.666666666666667",
      ">>>",
      ">>> 17 // 3  # 整数除法返回向下取整后的结果",
      "5",
      ">>> 17 % 3  # ％操作符返回除法的余数",
      "2",
      ">>> 5 * 3 + 2 ",
      "17",
      "注意：// 得到的并不一定是整数类型的数，它与分母分子的数据类型有关系。",
      "",
      ">>> 7//2",
      "3",
      ">>> 7.0//2",
      "3.0",
      ">>> 7//2.0",
      "3.0",
      ">>> ",
      "等号 = 用于给变量赋值。赋值之后，除了下一个提示符，解释器不会显示任何结果。",
      "",
      ">>> width = 20",
      ">>> height = 5*9",
      ">>> width * height",
      "900",
      "Python 可以使用 ** 操作来进行幂运算：",
      "",
      ">>> 5 ** 2  # 5 的平方",
      "25",
      ">>> 2 ** 7  # 2的7次方",
      "128",
      "变量在使用前必须先\"定义\"（即赋予变量一个值），否则会出现错误：",
      "",
      ">>> n   # 尝试访问一个未定义的变量",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 1, in <module>",
      "NameError: name 'n' is not defined",
      "不同类型的数混合运算时会将整数转换为浮点数：",
      "",
      ">>> 3 * 3.75 / 1.5",
      "7.5",
      ">>> 7.0 / 2",
      "3.5",
      "在交互模式中，最后被输出的表达式结果被赋值给变量 _ 。例如：",
      "",
      ">>> tax = 12.5 / 100",
      ">>> price = 100.50",
      ">>> price * tax",
      "12.5625",
      ">>> price + _",
      "113.0625",
      ">>> round(_, 2)",
      "113.06",
      "此处， _ 变量应被用户视为只读变量。"
    ]
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-数学函数": {
    "prefix": "py-数学函数",
    "body": [
      "abs(x)返回数字的绝对值，如abs(-10) 返回 10",
      "ceil(x)返回数字的上入整数，如math.ceil(4.1) 返回 5",
      "cmp(x, y)",
      "",
      "如果 x < y 返回 -1, 如果 x == y 返回 0, 如果 x > y 返回 1。 Python 3 已废弃，使用 (x>y)-(x<y) 替换。",
      "exp(x)返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045",
      "fabs(x)返回数字的绝对值，如math.fabs(-10) 返回10.0",
      "floor(x)返回数字的下舍整数，如math.floor(4.9)返回 4",
      "log(x)如math.log(math.e)返回1.0,math.log(100,10)返回2.0",
      "log10(x)返回以10为基数的x的对数，如math.log10(100)返回 2.0",
      "max(x1, x2,...)返回给定参数的最大值，参数可以为序列。",
      "min(x1, x2,...)返回给定参数的最小值，参数可以为序列。",
      "modf(x)返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。",
      "pow(x, y)x**y 运算后的值。",
      "round(x [,n])",
      "返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。",
      "",
      "其实准确的说是保留值将保留到离上一位更近的一端。",
      "",
      "sqrt(x)返回数字x的平方根。"
    ]
  },
  "py-随机数函数": {
    "prefix": "py-随机数函数",
    "body": [
      "随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。",
      "",
      "Python包含以下常用随机数函数：",
      "",
      "函数描述",
      "choice(seq)从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。",
      "randrange ([start,] stop [,step])从指定范围内，按指定基数递增的集合中获取一个随机数，基数默认值为 1",
      "random()随机生成下一个实数，它在[0,1)范围内。",
      "seed([x])改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。",
      "shuffle(lst)将序列的所有元素随机排序",
      "uniform(x, y)随机生成下一个实数，它在[x,y]范围内。"
    ]
  },
  "py-数学常量": {
    "prefix": "py-数学常量",
    "body": [
      "pi数学常量 pi（圆周率，一般以π来表示）",
      "e数学常量 e，e即自然常数（自然常数）。"
    ]
  },
  "py-String4": {
    "prefix": "py-String4",
    "body": [
      "Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。",
      "",
      "Python 访问子字符串，可以使用方括号来截取字符串，如下实例：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "var1 = 'Hello World!'",
      "var2 = \"Runoob\"",
      " ",
      "print (\"var1[0]: \", var1[0])",
      "print (\"var2[1:5]: \", var2[1:5])",
      "以上实例执行结果：",
      "",
      "var1[0]:  H",
      "var2[1:5]:  unoo"
    ]
  },
  "py-字符串更新": {
    "prefix": "py-字符串更新",
    "body": [
      "你可以截取字符串的一部分并与其他字段拼接，如下实例：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "var1 = 'Hello World!'",
      " ",
      "print (\"已更新字符串 : \", var1[:6] + 'Runoob!')",
      "以上实例执行结果",
      "",
      "已更新字符串 :  Hello Runoob!"
    ]
  },
  "py-String字符串运算符": {
    "prefix": "py-String字符串运算符",
    "body": [
      "下表实例变量a值为字符串 \"Hello\"，b变量值为 \"Python\"：",
      "",
      "操作符	描述	实例",
      "+	字符串连接	a + b 输出结果： HelloPython",
      "*	重复输出字符串	a*2 输出结果：HelloHello",
      "[]	通过索引获取字符串中字符	a[1] 输出结果 e",
      "[ : ]	截取字符串中的一部分，遵循左闭右开原则，str[0:2] 是不包含第 3 个字符的。	a[1:4] 输出结果 ell",
      "in	成员运算符 - 如果字符串中包含给定的字符返回 True	'H' in a 输出结果 True",
      "not in	成员运算符 - 如果字符串中不包含给定的字符返回 True	'M' not in a 输出结果 True",
      "r/R	原始字符串 - 原始字符串：所有的字符串都是直接按照字面的意思来使用，没有转义特殊或不能打印的字符。 原始字符串除在字符串的第一个引号前加上字母 r（可以大小写）以外，与普通字符串有着几乎完全相同的语法。	",
      "print( r'\n' )",
      "print( R'\n' )",
      "%	格式字符串	请看下一节内容。",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = \"Hello\"",
      "b = \"Python\"",
      " ",
      "print(\"a + b 输出结果：\", a + b)",
      "print(\"a * 2 输出结果：\", a * 2)",
      "print(\"a[1] 输出结果：\", a[1])",
      "print(\"a[1:4] 输出结果：\", a[1:4])",
      " ",
      "if( \"H\" in a) :",
      "    print(\"H 在变量 a 中\")",
      "else :",
      "    print(\"H 不在变量 a 中\")",
      " ",
      "if( \"M\" not in a) :",
      "    print(\"M 不在变量 a 中\")",
      "else :",
      "    print(\"M 在变量 a 中\")",
      " ",
      "print (r'\n')",
      "print (R'\n')",
      "以上实例输出结果为：",
      "",
      "a + b 输出结果： HelloPython",
      "a * 2 输出结果： HelloHello",
      "a[1] 输出结果： e",
      "a[1:4] 输出结果： ell",
      "H 在变量 a 中",
      "M 不在变量 a 中",
      "\n",
      "\n"
    ]
  },
  "py-String字符串格式化": {
    "prefix": "py-String字符串格式化",
    "body": [
      "Python字符串格式化",
      "Python 支持格式化字符串的输出 。尽管这样可能会用到非常复杂的表达式，但最基本的用法是将一个值插入到一个有字符串格式符 %s 的字符串中。",
      "",
      "在 Python 中，字符串格式化使用与 C 中 sprintf 函数一样的语法。",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "print (\"我叫 %s 今年 %d 岁!\" % ('小明', 10))",
      "以上实例输出结果：",
      "",
      "我叫 小明 今年 10 岁!",
      "python字符串格式化符号:",
      "",
      "   符号描述",
      "      %c格式化字符及其ASCII码",
      "      %s格式化字符串",
      "      %d格式化整数",
      "      %u格式化无符号整型",
      "      %o格式化无符号八进制数",
      "      %x格式化无符号十六进制数",
      "      %X格式化无符号十六进制数（大写）",
      "      %f格式化浮点数字，可指定小数点后的精度",
      "      %e用科学计数法格式化浮点数",
      "      %E作用同%e，用科学计数法格式化浮点数",
      "      %g  %f和%e的简写",
      "      %G  %f 和 %E 的简写",
      "      %p用十六进制数格式化变量的地址",
      "格式化操作符辅助指令:",
      "",
      "符号功能",
      "*定义宽度或者小数点精度",
      "-用做左对齐",
      "+在正数前面显示加号( + )",
      "<sp>在正数前面显示空格",
      "#在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X')",
      "0显示的数字前面填充'0'而不是默认的空格",
      "%    '%%'输出一个单一的'%'",
      "(var) 映射变量(字典参数)",
      "m.n.    m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)",
      "Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。"
    ]
  },
  "py-string三引号": {
    "prefix": "py-string三引号",
    "body": [
      "python三引号允许一个字符串跨多行，字符串中可以包含换行符、制表符以及其他特殊字符。实例如下",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "para_str = \"\"\"这是一个多行字符串的实例",
      "多行字符串可以使用制表符",
      "TAB ( \t )。",
      "也可以使用换行符 [ \n ]。",
      "\"\"\"",
      "print (para_str)",
      "以上实例执行结果为：",
      "",
      "这是一个多行字符串的实例",
      "多行字符串可以使用制表符",
      "TAB (    )。",
      "也可以使用换行符 [ ",
      " ]。",
      "三引号让程序员从引号和特殊字符串的泥潭里面解脱出来，自始至终保持一小块字符串的格式是所谓的WYSIWYG（所见即所得）格式的。",
      "",
      "一个典型的用例是，当你需要一块HTML或者SQL时，这时用字符串组合，特殊字符串转义将会非常的繁琐。",
      "",
      "errHTML = '''",
      "<HTML><HEAD><TITLE>",
      "Friends CGI Demo</TITLE></HEAD>",
      "<BODY><H3>ERROR</H3>",
      "<B>%s</B><P>",
      "<FORM><INPUT TYPE=button VALUE=Back",
      "ONCLICK=\"window.history.back()\"></FORM>",
      "</BODY></HTML>",
      "'''",
      "cursor.execute('''",
      "CREATE TABLE users (  ",
      "login VARCHAR(8), ",
      "uid INTEGER,",
      "prid INTEGER)",
      "''')"
    ]
  },
  "py-f-string": {
    "prefix": "py-f-string",
    "body": [
      "f-string 是 python3.6 之后版本添加的，称之为字面量格式化字符串，是新的格式化字符串的语法。",
      "",
      "之前我们习惯用百分号 (%):",
      "",
      "实例",
      ">>> name = 'Runoob'",
      ">>> 'Hello %s' % name",
      "'Hello Runoob'",
      "f-string 格式化字符串以 f 开头，后面跟着字符串，字符串中的表达式用大括号 {} 包起来，它会将变量或表达式计算后的值替换进去，实例如下：",
      "",
      "实例",
      ">>> name = 'Runoob'",
      ">>> f'Hello {name}'  # 替换变量",
      "",
      ">>> f'{1+2}'         # 使用表达式",
      "'3'",
      "",
      ">>> w = {'name': 'Runoob', 'url': 'www.runoob.com'}",
      ">>> f'{w[\"name\"]}: {w[\"url\"]}'",
      "'Runoob: www.runoob.com'",
      "用了这种方式明显更简单了，不用再去判断使用 %s，还是 %d。",
      "",
      "在 Python 3.8 的版本中可以使用 = 符号来拼接运算表达式与结果：",
      "",
      "实例",
      ">>> x = 1",
      ">>> print(f'{x+1}')   # Python 3.6",
      "2",
      "",
      ">>> x = 1",
      ">>> print(f'{x+1=}')   # Python 3.8",
      "'x+1=2'"
    ]
  },
  "py-String字符串内建函数": {
    "prefix": "py-String字符串内建函数",
    "body": [
      "",
      "序号方法及描述",
      "1",
      "capitalize()",
      "将字符串的第一个字符转换为大写",
      "",
      "2",
      "center(width, fillchar)",
      "",
      "",
      "返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。",
      "3",
      "count(str, beg= 0,end=len(string))",
      "",
      "",
      "返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数",
      "4",
      "bytes.decode(encoding=\"utf-8\", errors=\"strict\")",
      "",
      "",
      "Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。",
      "5",
      "encode(encoding='UTF-8',errors='strict')",
      "",
      "",
      "以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace'",
      "6",
      "endswith(suffix, beg=0, end=len(string))",
      "检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False.",
      "",
      "7",
      "expandtabs(tabsize=8)",
      "",
      "",
      "把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。",
      "8",
      "find(str, beg=0, end=len(string))",
      "",
      "",
      "检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1",
      "9",
      "index(str, beg=0, end=len(string))",
      "",
      "",
      "跟find()方法一样，只不过如果str不在字符串中会报一个异常.",
      "10",
      "isalnum()",
      "",
      "",
      "如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True,否则返回 False",
      "11",
      "isalpha()",
      "",
      "",
      "如果字符串至少有一个字符并且所有字符都是字母则返回 True, 否则返回 False",
      "12",
      "isdigit()",
      "",
      "",
      "如果字符串只包含数字则返回 True 否则返回 False..",
      "13",
      "islower()",
      "",
      "",
      "如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False",
      "14",
      "isnumeric()",
      "",
      "",
      "如果字符串中只包含数字字符，则返回 True，否则返回 False",
      "15",
      "isspace()",
      "",
      "",
      "如果字符串中只包含空白，则返回 True，否则返回 False.",
      "16",
      "istitle()",
      "",
      "",
      "如果字符串是标题化的(见 title())则返回 True，否则返回 False",
      "17",
      "isupper()",
      "",
      "",
      "如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False",
      "18",
      "join(seq)",
      "",
      "",
      "以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串",
      "19",
      "len(string)",
      "",
      "",
      "返回字符串长度",
      "20",
      "ljust(width[, fillchar])",
      "",
      "",
      "返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。",
      "21",
      "lower()",
      "",
      "",
      "转换字符串中所有大写字符为小写.",
      "22",
      "lstrip()",
      "",
      "",
      "截掉字符串左边的空格或指定字符。",
      "23",
      "maketrans()",
      "",
      "",
      "创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。",
      "24",
      "max(str)",
      "",
      "",
      "返回字符串 str 中最大的字母。",
      "25",
      "min(str)",
      "",
      "",
      "返回字符串 str 中最小的字母。",
      "26",
      "replace(old, new [, max])",
      "",
      "",
      "把 将字符串中的 str1 替换成 str2,如果 max 指定，则替换不超过 max 次。",
      "27",
      "rfind(str, beg=0,end=len(string))",
      "",
      "",
      "类似于 find()函数，不过是从右边开始查找.",
      "28",
      "rindex( str, beg=0, end=len(string))",
      "",
      "",
      "类似于 index()，不过是从右边开始.",
      "29",
      "rjust(width,[, fillchar])",
      "",
      "",
      "返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串",
      "30	",
      "rstrip()",
      "",
      "",
      "删除字符串字符串末尾的空格.",
      "31",
      "split(str=\"\", num=string.count(str))",
      "",
      "",
      "num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串",
      "32",
      "splitlines([keepends])",
      "",
      "",
      "按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。",
      "33",
      "startswith(substr, beg=0,end=len(string))",
      "",
      "",
      "检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。",
      "34",
      "strip([chars])",
      "",
      "",
      "在字符串上执行 lstrip()和 rstrip()",
      "35",
      "swapcase()",
      "",
      "",
      "将字符串中大写转换为小写，小写转换为大写",
      "36",
      "title()",
      "",
      "",
      "返回\"标题化\"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle())",
      "37",
      "translate(table, deletechars=\"\")",
      "",
      "",
      "根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中",
      "38",
      "upper()",
      "",
      "",
      "转换字符串中的小写字母为大写",
      "39",
      "zfill (width)",
      "",
      "",
      "返回长度为 width 的字符串，原字符串右对齐，前面填充0",
      "40",
      "isdecimal()",
      "",
      "",
      "检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false"
    ]
  },
  "py-list1": {
    "prefix": "py-list1",
    "body": [
      "使用下标索引来访问列表中的值，同样你也可以使用方括号的形式截取字符，如下所示：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "list1 = ['Google', 'Runoob', 1997, 2000]",
      "list2 = [1, 2, 3, 4, 5, 6, 7 ]",
      " ",
      "print (\"list1[0]: \", list1[0])",
      "print (\"list2[1:5]: \", list2[1:5])",
      "",
      "运行实例 »",
      "以上实例输出结果：",
      "",
      "list1[0]:  Google",
      "list2[1:5]:  [2, 3, 4, 5]",
      "更新列表",
      "你可以对列表的数据项进行修改或更新，你也可以使用append()方法来添加列表项，如下所示：",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "list = ['Google', 'Runoob', 1997, 2000]",
      " ",
      "print (\"第三个元素为 : \", list[2])",
      "list[2] = 2001",
      "print (\"更新后的第三个元素为 : \", list[2])",
      "注意：我们会在接下来的章节讨论append()方法的使用",
      "",
      "以上实例输出结果：",
      "",
      "第三个元素为 :  1997",
      "更新后的第三个元素为 :  2001",
      "删除列表元素",
      "可以使用 del 语句来删除列表的的元素，如下实例：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "list = ['Google', 'Runoob', 1997, 2000]",
      " ",
      "print (\"原始列表 : \", list)",
      "del list[2]",
      "print (\"删除第三个元素 : \", list)",
      "以上实例输出结果：",
      "",
      "原始列表 :  ['Google', 'Runoob', 1997, 2000]",
      "删除第三个元素 :  ['Google', 'Runoob', 2000]",
      "注意：我们会在接下来的章节讨论 remove() 方法的使用",
      "",
      "Python列表脚本操作符",
      "列表对 + 和 * 的操作符与字符串相似。+ 号用于组合列表，* 号用于重复列表。",
      "",
      "如下所示：",
      "",
      "Python 表达式 结果 描述",
      "len([1, 2, 3]) 3 长度",
      "[1, 2, 3] + [4, 5, 6]   [1, 2, 3, 4, 5, 6] 组合",
      "['Hi!'] * 4   ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复",
      "3 in [1, 2, 3]    True     元素是否存在于列表中",
      "for x in [1, 2, 3]: print(x, end=\" \")    1 2 3   迭代",
      "Python列表截取与拼接",
      "Python的列表截取与字符串操作类型，如下所示：",
      "",
      "L=['Google', 'Runoob', 'Taobao']",
      "操作：",
      "",
      "Python 表达式 结果   描述",
      "L[2]  'Taobao'  读取第三个元素",
      "L[-2] 'Runoob'  从右侧开始读取倒数第二个元素: count from the right",
      "L[1:]  ['Runoob', 'Taobao']   输出从第二个元素开始后的所有元素",
      ">>>L=['Google', 'Runoob', 'Taobao']",
      ">>> L[2]",
      "'Taobao'",
      ">>> L[-2]",
      "'Runoob'",
      ">>> L[1:]",
      "['Runoob', 'Taobao']",
      ">>>",
      "列表还支持拼接操作：",
      "",
      ">>>squares = [1, 4, 9, 16, 25]",
      ">>> squares += [36, 49, 64, 81, 100]",
      ">>> squares",
      "[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]",
      ">>>",
      "嵌套列表",
      "使用嵌套列表即在列表里创建其它列表，例如：",
      "",
      ">>>a = ['a', 'b', 'c']",
      ">>> n = [1, 2, 3]",
      ">>> x = [a, n]",
      ">>> x",
      "[['a', 'b', 'c'], [1, 2, 3]]",
      ">>> x[0]",
      "['a', 'b', 'c']",
      ">>> x[0][1]",
      "'b'",
      "Python列表函数&方法",
      "Python包含以下函数:",
      "",
      "序号函数",
      "1 len(list)",
      "列表元素个数",
      "2 max(list)",
      "返回列表元素最大值",
      "3min(list)",
      "返回列表元素最小值",
      "4list(seq)",
      "将元组转换为列表",
      "Python包含以下方法:",
      "",
      "序号方法",
      "1list.append(obj)",
      "在列表末尾添加新的对象",
      "2list.count(obj)",
      "统计某个元素在列表中出现的次数",
      "3list.extend(seq)",
      "在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）",
      "4list.index(obj)",
      "从列表中找出某个值第一个匹配项的索引位置",
      "5list.insert(index, obj)",
      "将对象插入列表",
      "6list.pop([index=-1])",
      "移除列表中的一个元素（默认最后一个元素），并且返回该元素的值",
      "7list.remove(obj)",
      "移除列表中某个值的第一个匹配项",
      "8list.reverse()",
      "反向列表中元素",
      "9list.sort( key=None, reverse=False)",
      "对原列表进行排序",
      "10list.clear()",
      "清空列表",
      "11list.copy()",
      "复制列表"
    ]
  },
  "py-tuple1": {
    "prefix": "py-tuple1",
    "body": [
      "Python 的元组与列表类似，不同之处在于元组的元素不能修改。",
      "",
      "元组使用小括号，列表使用方括号。",
      "",
      "元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。",
      "",
      "实例(Python 3.0+)",
      ">>>tup1 = ('Google', 'Runoob', 1997, 2000)",
      ">>> tup2 = (1, 2, 3, 4, 5 )",
      ">>> tup3 = \"a\", \"b\", \"c\", \"d\"   #  不需要括号也可以",
      ">>> type(tup3)",
      "<class 'tuple'>",
      "创建空元组",
      "",
      "tup1 = ()",
      "元组中只包含一个元素时，需要在元素后面添加逗号，否则括号会被当作运算符使用：",
      "",
      "实例(Python 3.0+)",
      ">>>tup1 = (50)",
      ">>> type(tup1)     # 不加逗号，类型为整型",
      "<class 'int'>",
      " ",
      ">>> tup1 = (50,)",
      ">>> type(tup1)     # 加上逗号，类型为元组",
      "<class 'tuple'>",
      "元组与字符串类似，下标索引从0开始，可以进行截取，组合等。",
      "",
      "访问元组",
      "元组可以使用下标索引来访问元组中的值，如下实例:",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "tup1 = ('Google', 'Runoob', 1997, 2000)",
      "tup2 = (1, 2, 3, 4, 5, 6, 7 )",
      " ",
      "print (\"tup1[0]: \", tup1[0])",
      "print (\"tup2[1:5]: \", tup2[1:5])",
      "以上实例输出结果：",
      "",
      "tup1[0]:  Google",
      "tup2[1:5]:  (2, 3, 4, 5)",
      "修改元组",
      "元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例:",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "tup1 = (12, 34.56)",
      "tup2 = ('abc', 'xyz')",
      " ",
      "# 以下修改元组元素操作是非法的。",
      "# tup1[0] = 100",
      " ",
      "# 创建一个新的元组",
      "tup3 = tup1 + tup2",
      "print (tup3)",
      "以上实例输出结果：",
      "",
      "(12, 34.56, 'abc', 'xyz')",
      "删除元组",
      "元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例:",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "tup = ('Google', 'Runoob', 1997, 2000)",
      " ",
      "print (tup)",
      "del tup",
      "print (\"删除后的元组 tup : \")",
      "print (tup)",
      "以上实例元组被删除后，输出变量会有异常信息，输出如下所示：",
      "",
      "删除后的元组 tup : ",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 8, in <module>",
      "    print (tup)",
      "NameError: name 'tup' is not defined",
      "元组运算符",
      "与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。",
      "",
      "Python 表达式结果描述",
      "len((1, 2, 3)) 3 计算元素个数",
      "(1, 2, 3) + (4, 5, 6)   (1, 2, 3, 4, 5, 6) 连接",
      "('Hi!',) * 4   ('Hi!', 'Hi!', 'Hi!', 'Hi!')复制",
      "3 in (1, 2, 3)  True   元素是否存在",
      "for x in (1, 2, 3): print (x,)   1 2 3   迭代",
      "元组索引，截取",
      "因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：",
      "",
      "元组：",
      "",
      "L = ('Google', 'Taobao', 'Runoob')",
      "Python 表达式结果描述",
      "L[2]'Runoob'读取第三个元素",
      "L[-2]'Taobao'反向读取，读取倒数第二个元素",
      "L[1:]('Taobao','Runoob') 截取元素，从第二个开始后的所有元素。",
      "运行实例如下：",
      "",
      ">>> L = ('Google', 'Taobao', 'Runoob')",
      ">>> L[2]",
      "'Runoob'",
      ">>> L[-2]",
      "'Taobao'",
      ">>> L[1:]",
      "('Taobao', 'Runoob')",
      "元组内置函数",
      "Python元组包含了以下内置函数",
      "",
      "序号方法及描述实例",
      "1len(tuple)",
      "计算元组元素个数。",
      ">>> tuple1 = ('Google', 'Runoob', 'Taobao')",
      ">>> len(tuple1)",
      "3",
      ">>> ",
      "2max(tuple)",
      "返回元组中元素最大值。",
      ">>> tuple2 = ('5', '4', '8')",
      ">>> max(tuple2)",
      "'8'",
      ">>> ",
      "3min(tuple)",
      "返回元组中元素最小值",
      ">>> tuple2 = ('5', '4', '8')",
      ">>> min(tuple2)",
      "'4'",
      ">>> ",
      "4 tuple(iterable)",
      "将可迭代系列转换为元组 ",
      ">>> list1= ['Google', 'Taobao', 'Runoob', 'Baidu']",
      ">>> tuple1=tuple(list1)",
      ">>> tuple1",
      "('Google', 'Taobao', 'Runoob', 'Baidu')",
      "关于元组是不可变的",
      "所谓元组的不可变指的是元组所指向的内存中的内容不可变。",
      "",
      ">>> tup = ('r', 'u', 'n', 'o', 'o', 'b')",
      ">>> tup[0] = 'g'     # 不支持修改元素",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 1, in <module>",
      "TypeError: 'tuple' object does not support item assignment",
      ">>> id(tup)     # 查看内存地址",
      "4440687904",
      ">>> tup = (1,2,3)",
      ">>> id(tup)",
      "4441088800    # 内存地址不一样了",
      "从以上实例可以看出，重新赋值的元组 tup，绑定到新的对象了，不是修改了原来的对象。"
    ]
  },
  "py-字典": {
    "prefix": "py-字典",
    "body": [
      "字典是另一种可变容器模型，且可存储任意类型对象。",
      "",
      "字典的每个键值(key=>value)对用冒号(:)分割，每个对之间用逗号(,)分割，整个字典包括在花括号({})中 ,格式如下所示：",
      "",
      "d = {key1 : value1, key2 : value2 }",
      "键必须是唯一的，但值则不必。",
      "",
      "值可以取任何数据类型，但键必须是不可变的，如字符串，数字或元组。",
      "",
      "一个简单的字典实例：",
      "",
      "dict = {'Alice': '2341', 'Beth': '9102', 'Cecil': '3258'}",
      "也可如此创建字典：",
      "",
      "dict1 = { 'abc': 456 }",
      "dict2 = { 'abc': 123, 98.6: 37 }",
      "访问字典里的值",
      "把相应的键放入到方括号中，如下实例:",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      " ",
      "print (\"dict['Name']: \", dict['Name'])",
      "print (\"dict['Age']: \", dict['Age'])",
      "以上实例输出结果：",
      "",
      "dict['Name']:  Runoob",
      "dict['Age']:  7",
      "如果用字典里没有的键访问数据，会输出错误如下：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      " ",
      "print (\"dict['Alice']: \", dict['Alice'])",
      "以上实例输出结果：",
      "",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 5, in <module>",
      "    print (\"dict['Alice']: \", dict['Alice'])",
      "KeyError: 'Alice'",
      "修改字典",
      "向字典添加新内容的方法是增加新的键/值对，修改或删除已有键/值对如下实例:",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      " ",
      "dict['Age'] = 8               # 更新 Age",
      "dict['School'] = \"菜鸟教程\"  # 添加信息",
      " ",
      " ",
      "print (\"dict['Age']: \", dict['Age'])",
      "print (\"dict['School']: \", dict['School'])",
      "以上实例输出结果：",
      "dict['Age']:  8",
      "dict['School']:  菜鸟教程",
      "删除字典元素",
      "能删单一的元素也能清空字典，清空只需一项操作。",
      "",
      "显示删除一个字典用del命令，如下实例：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      " ",
      "del dict['Name'] # 删除键 'Name'",
      "dict.clear()     # 清空字典",
      "del dict         # 删除字典",
      " ",
      "print (\"dict['Age']: \", dict['Age'])",
      "print (\"dict['School']: \", dict['School'])",
      "但这会引发一个异常，因为用执行 del 操作后字典不再存在：",
      "",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 9, in <module>",
      "    print (\"dict['Age']: \", dict['Age'])",
      "TypeError: 'type' object is not subscriptable",
      "注：del() 方法后面也会讨论。",
      "",
      "",
      "字典键的特性",
      "字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的，但键不行。",
      "",
      "两个重要的点需要记住：",
      "",
      "1）不允许同一个键出现两次。创建时如果同一个键被赋值两次，后一个值会被记住，如下实例：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "dict = {'Name': 'Runoob', 'Age': 7, 'Name': '小菜鸟'}",
      " ",
      "print (\"dict['Name']: \", dict['Name'])",
      "以上实例输出结果：",
      "",
      "dict['Name']:  小菜鸟",
      "2）键必须不可变，所以可以用数字，字符串或元组充当，而用列表就不行，如下实例：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "dict = {['Name']: 'Runoob', 'Age': 7}",
      " ",
      "print (\"dict['Name']: \", dict['Name'])",
      "以上实例输出结果：",
      "",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 3, in <module>",
      "    dict = {['Name']: 'Runoob', 'Age': 7}",
      "TypeError: unhashable type: 'list'",
      "字典内置函数&方法",
      "Python字典包含了以下内置函数：",
      "",
      "序号函数及描述实例",
      "1len(dict)",
      "计算字典元素个数，即键的总数。",
      ">>> dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      ">>> len(dict)",
      "3",
      "2str(dict)",
      "输出字典，以可打印的字符串表示。",
      ">>> dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      ">>> str(dict)",
      "\"{'Name': 'Runoob', 'Class': 'First', 'Age': 7}\"",
      "3type(variable)",
      "返回输入的变量类型，如果变量是字典就返回字典类型。",
      ">>> dict = {'Name': 'Runoob', 'Age': 7, 'Class': 'First'}",
      ">>> type(dict)",
      "<class 'dict'>",
      "Python字典包含了以下内置方法：",
      "",
      "序号函数及描述",
      "1radiansdict.clear()",
      "删除字典内所有元素",
      "2radiansdict.copy()",
      "返回一个字典的浅复制",
      "3radiansdict.fromkeys()",
      "创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值",
      "4radiansdict.get(key, default=None)",
      "返回指定键的值，如果值不在字典中返回default值",
      "5key in dict",
      "如果键在字典dict里返回true，否则返回false",
      "6radiansdict.items()",
      "以列表返回可遍历的(键, 值) 元组数组",
      "7radiansdict.keys()",
      "返回一个迭代器，可以使用 list() 来转换为列表",
      "8radiansdict.setdefault(key, default=None)",
      "和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default",
      "9radiansdict.update(dict2)",
      "把字典dict2的键/值对更新到dict里",
      "10radiansdict.values()",
      "返回一个迭代器，可以使用 list() 来转换为列表",
      "11pop(key[,default])",
      "删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。",
      "12popitem()",
      "随机返回并删除字典中的最后一对键和值。"
    ]
  },
  "py-set": {
    "prefix": "py-set",
    "body": [
      "集合（set）是一个无序的不重复元素序列。",
      "",
      "可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。",
      "",
      "创建格式：",
      "",
      "parame = {value01,value02,...}",
      "或者",
      "set(value)",
      "实例(Python 3.0+)",
      ">>>basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}",
      ">>> print(basket)                      # 这里演示的是去重功能",
      "{'orange', 'banana', 'pear', 'apple'}",
      ">>> 'orange' in basket                 # 快速判断元素是否在集合内",
      "True",
      ">>> 'crabgrass' in basket",
      "False",
      " ",
      ">>> # 下面展示两个集合间的运算.",
      "...",
      ">>> a = set('abracadabra')",
      ">>> b = set('alacazam')",
      ">>> a                                  ",
      "{'a', 'r', 'b', 'c', 'd'}",
      ">>> a - b                              # 集合a中包含而集合b中不包含的元素",
      "{'r', 'd', 'b'}",
      ">>> a | b                              # 集合a或b中包含的所有元素",
      "{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}",
      ">>> a & b                              # 集合a和b中都包含了的元素",
      "{'a', 'c'}",
      ">>> a ^ b                              # 不同时包含于a和b的元素",
      "{'r', 'd', 'b', 'm', 'z', 'l'}",
      "类似列表推导式，同样集合支持集合推导式(Set comprehension):",
      "",
      "实例(Python 3.0+)",
      ">>>a = {x for x in 'abracadabra' if x not in 'abc'}",
      ">>> a",
      "{'r', 'd'}",
      "集合的基本操作",
      "1、添加元素",
      "语法格式如下：",
      "",
      "s.add( x )",
      "将元素 x 添加到集合 s 中，如果元素已存在，则不进行任何操作。",
      "",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> thisset.add(\"Facebook\")",
      ">>> print(thisset)",
      "{'Taobao', 'Facebook', 'Google', 'Runoob'}",
      "还有一个方法，也可以添加元素，且参数可以是列表，元组，字典等，语法格式如下：",
      "",
      "s.update( x )",
      "x 可以有多个，用逗号分开。",
      "",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> thisset.update({1,3})",
      ">>> print(thisset)",
      "{1, 3, 'Google', 'Taobao', 'Runoob'}",
      ">>> thisset.update([1,4],[5,6])  ",
      ">>> print(thisset)",
      "{1, 3, 4, 5, 6, 'Google', 'Taobao', 'Runoob'}",
      ">>>",
      "2、移除元素",
      "语法格式如下：",
      "",
      "s.remove( x )",
      "将元素 x 从集合 s 中移除，如果元素不存在，则会发生错误。",
      "",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> thisset.remove(\"Taobao\")",
      ">>> print(thisset)",
      "{'Google', 'Runoob'}",
      ">>> thisset.remove(\"Facebook\")   # 不存在会发生错误",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 1, in <module>",
      "KeyError: 'Facebook'",
      ">>>",
      "此外还有一个方法也是移除集合中的元素，且如果元素不存在，不会发生错误。格式如下所示：",
      "",
      "s.discard( x )",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> thisset.discard(\"Facebook\")  # 不存在不会发生错误",
      ">>> print(thisset)",
      "{'Taobao', 'Google', 'Runoob'}",
      "我们也可以设置随机删除集合中的一个元素，语法格式如下：",
      "",
      "s.pop() ",
      "脚本模式实例(Python 3.0+)",
      "thisset = set((\"Google\", \"Runoob\", \"Taobao\", \"Facebook\"))",
      "x = thisset.pop()",
      " ",
      "print(x)",
      "输出结果：",
      "",
      "$ python3 test.py ",
      "Runoob",
      "多次执行测试结果都不一样。",
      "",
      "set 集合的 pop 方法会对集合进行无序的排列，然后将这个无序排列集合的左面第一个元素进行删除。",
      "",
      "3、计算集合元素个数",
      "语法格式如下：",
      "",
      "len(s)",
      "计算集合 s 元素个数。",
      "",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> len(thisset)",
      "3",
      "4、清空集合",
      "语法格式如下：",
      "",
      "s.clear()",
      "清空集合 s。",
      "",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> thisset.clear()",
      ">>> print(thisset)",
      "set()",
      "5、判断元素是否在集合中存在",
      "语法格式如下：",
      "",
      "x in s",
      "判断元素 x 是否在集合 s 中，存在返回 True，不存在返回 False。",
      "",
      "实例(Python 3.0+)",
      ">>>thisset = set((\"Google\", \"Runoob\", \"Taobao\"))",
      ">>> \"Runoob\" in thisset",
      "True",
      ">>> \"Facebook\" in thisset",
      "False",
      ">>>",
      "集合内置方法完整列表",
      "方法描述",
      "add()为集合添加元素",
      "clear()移除集合中的所有元素",
      "copy()拷贝一个集合",
      "difference()返回多个集合的差集",
      "difference_update()移除集合中的元素，该元素在指定的集合也存在。",
      "discard()删除集合中指定的元素",
      "intersection()返回集合的交集",
      "intersection_update()返回集合的交集。",
      "isdisjoint()判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。",
      "issubset()判断指定集合是否为该方法参数集合的子集。",
      "issuperset()判断该方法的参数集合是否为指定集合的子集",
      "pop(随机移除元素",
      "remove()移除指定元素",
      "symmetric_difference()返回两个集合中不重复的元素集合。",
      "symmetric_difference_update()移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。",
      "union()返回两个集合的并集",
      "update()给集合添加元素"
    ]
  },
  "py-end 关键字": {
    "prefix": "py-end 关键字",
    "body": [
      "end 关键字",
      "关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符，实例如下：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "# Fibonacci series: 斐波纳契数列",
      "# 两个元素的总和确定了下一个数",
      "a, b = 0, 1",
      "while b < 1000:",
      "    print(b, end=',')",
      "    a, b = b, a+b",
      "执行以上程序，输出结果为：",
      "",
      "1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,"
    ]
  },
  "py-if 语句": {
    "prefix": "py-if 语句",
    "body": [
      "if 语句",
      "Python中if语句的一般形式如下所示：",
      "",
      "if condition_1:",
      "    statement_block_1",
      "elif condition_2:",
      "    statement_block_2",
      "else:",
      "    statement_block_3",
      "如果 \"condition_1\" 为 True 将执行 \"statement_block_1\" 块语句",
      "如果 \"condition_1\" 为False，将判断 \"condition_2\"",
      "如果\"condition_2\" 为 True 将执行 \"statement_block_2\" 块语句",
      "如果 \"condition_2\" 为False，将执行\"statement_block_3\"块语句",
      "Python 中用 elif 代替了 else if，所以if语句的关键字为：if – elif – else。",
      "",
      "注意：",
      "",
      "1、每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。",
      "2、使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块。",
      "3、在Python中没有switch – case语句。",
      "Gif 演示：",
      "",
      "",
      "",
      "实例",
      "以下是一个简单的 if 实例：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "var1 = 100",
      "if var1:",
      "    print (\"1 - if 表达式条件为 true\")",
      "    print (var1)",
      " ",
      "var2 = 0",
      "if var2:",
      "    print (\"2 - if 表达式条件为 true\")",
      "    print (var2)",
      "print (\"Good bye!\")",
      "执行以上代码，输出结果为：",
      "",
      "1 - if 表达式条件为 true",
      "100",
      "Good bye!",
      "从结果可以看到由于变量 var2 为 0，所以对应的 if 内的语句没有执行。",
      "",
      "以下实例演示了狗的年龄计算判断：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "age = int(input(\"请输入你家狗狗的年龄: \"))",
      "print(\"\")",
      "if age <= 0:",
      "    print(\"你是在逗我吧!\")",
      "elif age == 1:",
      "    print(\"相当于 14 岁的人。\")",
      "elif age == 2:",
      "    print(\"相当于 22 岁的人。\")",
      "elif age > 2:",
      "    human = 22 + (age -2)*5",
      "    print(\"对应人类年龄: \", human)",
      " ",
      "### 退出提示",
      "input(\"点击 enter 键退出\")",
      "将以上脚本保存在dog.py文件中，并执行该脚本：",
      "",
      "$ python3 dog.py ",
      "请输入你家狗狗的年龄: 1",
      "",
      "相当于 14 岁的人。",
      "点击 enter 键退出",
      "以下为if中常用的操作运算符:",
      "",
      "操作符 描述",
      "<小于",
      "<=小于或等于",
      ">大于",
      ">=大于或等于",
      "==等于，比较两个值是否相等",
      "!=不等于",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "# 程序演示了 == 操作符",
      "# 使用数字",
      "print(5 == 6)",
      "# 使用变量",
      "x = 5",
      "y = 8",
      "print(x == y)",
      "以上实例输出结果：",
      "",
      "False",
      "False",
      "high_low.py文件演示了数字的比较运算：",
      "",
      "实例",
      "#!/usr/bin/python3 ",
      " ",
      "# 该实例演示了数字猜谜游戏",
      "number = 7",
      "guess = -1",
      "print(\"数字猜谜游戏!\")",
      "while guess != number:",
      "    guess = int(input(\"请输入你猜的数字：\"))",
      " ",
      "    if guess == number:",
      "        print(\"恭喜，你猜对了！\")",
      "    elif guess < number:",
      "        print(\"猜的数字小了...\")",
      "    elif guess > number:",
      "        print(\"猜的数字大了...\")",
      "执行以上脚本，实例输出结果如下：",
      "",
      "$ python3 high_low.py ",
      "数字猜谜游戏!",
      "请输入你猜的数字：1",
      "猜的数字小了...",
      "请输入你猜的数字：9",
      "猜的数字大了...",
      "请输入你猜的数字：7",
      "恭喜，你猜对了！",
      "if 嵌套",
      "在嵌套 if 语句中，可以把 if...elif...else 结构放在另外一个 if...elif...else 结构中。",
      "",
      "if 表达式1:",
      "    语句",
      "    if 表达式2:",
      "        语句",
      "    elif 表达式3:",
      "        语句",
      "    else:",
      "        语句",
      "elif 表达式4:",
      "    语句",
      "else:",
      "    语句",
      "实例",
      "# !/usr/bin/python3",
      " ",
      "num=int(input(\"输入一个数字：\"))",
      "if num%2==0:",
      "    if num%3==0:",
      "        print (\"你输入的数字可以整除 2 和 3\")",
      "    else:",
      "        print (\"你输入的数字可以整除 2，但不能整除 3\")",
      "else:",
      "    if num%3==0:",
      "        print (\"你输入的数字可以整除 3，但不能整除 2\")",
      "    else:",
      "        print  (\"你输入的数字不能整除 2 和 3\")",
      "将以上程序保存到 test_if.py 文件中，执行后输出结果为：",
      "",
      "$ python3 test.py ",
      "输入一个数字：6",
      "你输入的数字可以整除 2 和 3"
    ]
  },
  "py-while循环": {
    "prefix": "py-while循环",
    "body": [
      "以下实例使用了 while 来计算 1 到 100 的总和：",
      "",
      "实例",
      "#!/usr/bin/env python3",
      " ",
      "n = 100",
      " ",
      "sum = 0",
      "counter = 1",
      "while counter <= n:",
      "    sum = sum + counter",
      "    counter += 1",
      " ",
      "print(\"1 到 %d 之和为: %d\" % (n,sum))",
      "执行结果如下：",
      "",
      "1 到 100 之和为: 5050",
      "无限循环",
      "我们可以通过设置条件表达式永远不为 false 来实现无限循环，实例如下：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "var = 1",
      "while var == 1 :  # 表达式永远为 true",
      "   num = int(input(\"输入一个数字  :\"))",
      "   print (\"你输入的数字是: \", num)",
      " ",
      "print (\"Good bye!\")",
      "执行以上脚本，输出结果如下：",
      "",
      "输入一个数字  :5",
      "你输入的数字是:  5",
      "输入一个数字  :",
      "你可以使用 CTRL+C 来退出当前的无限循环。",
      "",
      "无限循环在服务器上客户端的实时请求非常有用。",
      "",
      "while 循环使用 else 语句",
      "在 while … else 在条件语句为 false 时执行 else 的语句块。",
      "",
      "语法格式如下：",
      "",
      "while <expr>:",
      "    <statement(s)>",
      "else:",
      "    <additional_statement(s)>",
      "循环输出数字，并判断大小：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "count = 0",
      "while count < 5:",
      "   print (count, \" 小于 5\")",
      "   count = count + 1",
      "else:",
      "   print (count, \" 大于或等于 5\")",
      "执行以上脚本，输出结果如下：",
      "",
      "0  小于 5",
      "1  小于 5",
      "2  小于 5",
      "3  小于 5",
      "4  小于 5",
      "5  大于或等于 5",
      "简单语句组",
      "类似if语句的语法，如果你的while循环体中只有一条语句，你可以将该语句与while写在同一行中， 如下所示：",
      "",
      "实例",
      "#!/usr/bin/python",
      " ",
      "flag = 1",
      " ",
      "while (flag): print ('欢迎访问菜鸟教程!')",
      " ",
      "print (\"Good bye!\")",
      "注意：以上的无限循环你可以使用 CTRL+C 来中断循环。",
      "",
      "执行以上脚本，输出结果如下：",
      "",
      "欢迎访问菜鸟教程!",
      "欢迎访问菜鸟教程!",
      "欢迎访问菜鸟教程!",
      "欢迎访问菜鸟教程!",
      "欢迎访问菜鸟教程!",
      "……"
    ]
  },
  "py-for循环": {
    "prefix": "py-for循环",
    "body": [
      "Python for循环可以遍历任何序列的项目，如一个列表或者一个字符串。",
      "",
      "for循环的一般格式如下：",
      "",
      "for <variable> in <sequence>:",
      "    <statements>",
      "else:",
      "    <statements>",
      "流程图：",
      "",
      "",
      "",
      "Python for 循环实例：",
      "",
      "实例",
      ">>>languages = [\"C\", \"C++\", \"Perl\", \"Python\"] ",
      ">>> for x in languages:",
      "...     print (x)",
      "... ",
      "C",
      "C++",
      "Perl",
      "Python",
      ">>>",
      "以下 for 实例中使用了 break 语句，break 语句用于跳出当前循环体：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "sites = [\"Baidu\", \"Google\",\"Runoob\",\"Taobao\"]",
      "for site in sites:",
      "    if site == \"Runoob\":",
      "        print(\"菜鸟教程!\")",
      "        break",
      "    print(\"循环数据 \" + site)",
      "else:",
      "    print(\"没有循环数据!\")",
      "print(\"完成循环!\")",
      "执行脚本后，在循环到 \"Runoob\"时会跳出循环体：",
      "",
      "循环数据 Baidu",
      "循环数据 Google",
      "菜鸟教程!",
      "完成循环!"
    ]
  },
  "py-range()函数": {
    "prefix": "py-range()函数",
    "body": [
      "如果你需要遍历数字序列，可以使用内置range()函数。它会生成数列，例如:",
      "",
      "实例",
      ">>>for i in range(5):",
      "...     print(i)",
      "...",
      "0",
      "1",
      "2",
      "3",
      "4",
      "你也可以使用range指定区间的值：",
      "",
      "实例",
      ">>>for i in range(5,9) :",
      "    print(i)",
      " ",
      "    ",
      "5",
      "6",
      "7",
      "8",
      ">>>",
      "也可以使range以指定数字开始并指定不同的增量(甚至可以是负数，有时这也叫做'步长'):",
      "",
      "实例",
      ">>>for i in range(0, 10, 3) :",
      "    print(i)",
      " ",
      "    ",
      "0",
      "3",
      "6",
      "9",
      ">>>",
      "负数：",
      "",
      "实例",
      ">>>for i in range(-10, -100, -30) :",
      "    print(i)",
      " ",
      "    ",
      "-10",
      "-40",
      "-70",
      ">>>",
      "您可以结合range()和len()函数以遍历一个序列的索引,如下所示:",
      "",
      "实例",
      ">>>a = ['Google', 'Baidu', 'Runoob', 'Taobao', 'QQ']",
      ">>> for i in range(len(a)):",
      "...     print(i, a[i])",
      "... ",
      "0 Google",
      "1 Baidu",
      "2 Runoob",
      "3 Taobao",
      "4 QQ",
      ">>>",
      "还可以使用range()函数来创建一个列表：",
      "",
      "实例",
      ">>>list(range(5))",
      "[0, 1, 2, 3, 4]",
      ">>>"
    ]
  },
  "py-break": {
    "prefix": "py-break",
    "body": [
      "while 中使用 break：",
      "",
      "实例",
      "n = 5",
      "while n > 0:",
      "    n -= 1",
      "    if n == 2:",
      "        break",
      "    print(n)",
      "print('循环结束。')",
      "输出结果为：",
      "",
      "4",
      "3",
      "循环结束。"
    ]
  },
  "py-continue": {
    "prefix": "py-continue",
    "body": [
      "while 中使用 continue：",
      "",
      "实例",
      "n = 5",
      "while n > 0:",
      "    n -= 1",
      "    if n == 2:",
      "        continue",
      "    print(n)",
      "print('循环结束。')",
      "输出结果为：",
      "",
      "4",
      "3",
      "1",
      "0",
      "循环结束。",
      "更多实例如下：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "for letter in 'Runoob':     # 第一个实例",
      "   if letter == 'b':",
      "      break",
      "   print ('当前字母为 :', letter)",
      "  ",
      "var = 10                    # 第二个实例",
      "while var > 0:              ",
      "   print ('当期变量值为 :', var)",
      "   var = var -1",
      "   if var == 5:",
      "      break",
      " ",
      "print (\"Good bye!\")",
      "执行以上脚本输出结果为：",
      "",
      "当前字母为 : R",
      "当前字母为 : u",
      "当前字母为 : n",
      "当前字母为 : o",
      "当前字母为 : o",
      "当期变量值为 : 10",
      "当期变量值为 : 9",
      "当期变量值为 : 8",
      "当期变量值为 : 7",
      "当期变量值为 : 6",
      "Good bye!",
      "以下实例循环字符串 Runoob，碰到字母 o 跳过输出：",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "for letter in 'Runoob':     # 第一个实例",
      "   if letter == 'o':        # 字母为 o 时跳过输出",
      "      continue",
      "   print ('当前字母 :', letter)",
      " ",
      "var = 10                    # 第二个实例",
      "while var > 0:              ",
      "   var = var -1",
      "   if var == 5:             # 变量为 5 时跳过输出",
      "      continue",
      "   print ('当前变量值 :', var)",
      "print (\"Good bye!\")",
      "执行以上脚本输出结果为：",
      "",
      "当前字母 : R",
      "当前字母 : u",
      "当前字母 : n",
      "当前字母 : b",
      "当前变量值 : 9",
      "当前变量值 : 8",
      "当前变量值 : 7",
      "当前变量值 : 6",
      "当前变量值 : 4",
      "当前变量值 : 3",
      "当前变量值 : 2",
      "当前变量值 : 1",
      "当前变量值 : 0",
      "Good bye!",
      "循环语句可以有 else 子句，它在穷尽列表(以for循环)或条件变为 false (以while循环)导致循环终止时被执行，但循环被 break 终止时不执行。",
      "",
      "如下实例用于查询质数的循环例子:",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "for n in range(2, 10):",
      "    for x in range(2, n):",
      "        if n % x == 0:",
      "            print(n, '等于', x, '*', n//x)",
      "            break",
      "    else:",
      "        # 循环中没有找到元素",
      "        print(n, ' 是质数')",
      "执行以上脚本输出结果为：",
      "",
      "2  是质数",
      "3  是质数",
      "4 等于 2 * 2",
      "5  是质数",
      "6 等于 2 * 3",
      "7  是质数",
      "8 等于 2 * 4",
      "9 等于 3 * 3"
    ]
  },
  "py-pass 语句": {
    "prefix": "py-pass 语句",
    "body": [
      "Python pass是空语句，是为了保持程序结构的完整性。",
      "",
      "pass 不做任何事情，一般用做占位语句，如下实例",
      "",
      "实例",
      ">>>while True:",
      "...     pass  # 等待键盘中断 (Ctrl+C)",
      "最小的类:",
      "",
      "实例",
      ">>>class MyEmptyClass:",
      "...     pass",
      "以下实例在字母为 o 时 执行 pass 语句块:",
      "",
      "实例",
      "#!/usr/bin/python3",
      " ",
      "for letter in 'Runoob': ",
      "   if letter == 'o':",
      "      pass",
      "      print ('执行 pass 块')",
      "   print ('当前字母 :', letter)",
      " ",
      "print (\"Good bye!\")",
      "执行以上脚本输出结果为：",
      "",
      "当前字母 : R",
      "当前字母 : u",
      "当前字母 : n",
      "执行 pass 块",
      "当前字母 : o",
      "执行 pass 块",
      "当前字母 : o",
      "当前字母 : b",
      "Good bye!"
    ]
  },
  "py-iter迭代": {
    "prefix": "py-iter迭代",
    "body": [
      "迭代器有两个基本的方法：iter() 和 next()。",
      "",
      "字符串，列表或元组对象都可用于创建迭代器：",
      "",
      "实例(Python 3.0+)",
      ">>> list=[1,2,3,4]",
      ">>> it = iter(list)    # 创建迭代器对象",
      ">>> print (next(it))   # 输出迭代器的下一个元素",
      "1",
      ">>> print (next(it))",
      "2",
      ">>>",
      "迭代器对象可以使用常规for语句进行遍历：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "list=[1,2,3,4]",
      "it = iter(list)    # 创建迭代器对象",
      "for x in it:",
      "    print (x, end=\" \")",
      "执行以上程序，输出结果如下：",
      "",
      "1 2 3 4",
      "也可以使用 next() 函数：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "import sys         # 引入 sys 模块",
      " ",
      "list=[1,2,3,4]",
      "it = iter(list)    # 创建迭代器对象",
      " ",
      "while True:",
      "    try:",
      "        print (next(it))",
      "    except StopIteration:",
      "        sys.exit()",
      "执行以上程序，输出结果如下：",
      "",
      "1",
      "2",
      "3",
      "4"
    ]
  },
  "py-函数func": {
    "prefix": "py-函数func",
    "body": [
      "你可以定义一个由自己想要功能的函数，以下是简单的规则：",
      "",
      "函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()。",
      "任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。",
      "函数的第一行语句可以选择性地使用文档字符串—用于存放函数说明。",
      "函数内容以冒号起始，并且缩进。",
      "return [表达式] 结束函数，选择性地返回一个值给调用方。不带表达式的return相当于返回 None。",
      "语法",
      "Python 定义函数使用 def 关键字，一般格式如下：",
      "",
      "def 函数名（参数列表）:",
      "    函数体",
      "默认情况下，参数值和参数名称是按函数声明中定义的顺序匹配起来的。",
      "",
      "实例",
      "让我们使用函数来输出\"Hello World！\"：",
      "",
      ">>>def hello() :",
      "   print(\"Hello World!\")",
      " ",
      "   ",
      ">>> hello()",
      "Hello World!",
      ">>>",
      "更复杂点的应用，函数中带上参数变量:",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "# 计算面积函数",
      "def area(width, height):",
      "    return width * height",
      " ",
      "def print_welcome(name):",
      "    print(\"Welcome\", name)",
      " ",
      "print_welcome(\"Runoob\")",
      "w = 4",
      "h = 5",
      "print(\"width =\", w, \" height =\", h, \" area =\", area(w, h))",
      "以上实例输出结果：",
      "",
      "Welcome Runoob",
      "width = 4  height = 5  area = 20"
    ]
  },
  "py-函数调用": {
    "prefix": "py-函数调用",
    "body": [
      "函数调用",
      "定义一个函数：给了函数一个名称，指定了函数里包含的参数，和代码块结构。",
      "",
      "这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从 Python 命令提示符执行。",
      "",
      "如下实例调用了 printme() 函数：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "# 定义函数",
      "def printme( str ):",
      "   # 打印任何传入的字符串",
      "   print (str)",
      "   return",
      " ",
      "# 调用函数",
      "printme(\"我要调用用户自定义函数!\")",
      "printme(\"再次调用同一函数\")",
      "以上实例输出结果：",
      "",
      "我要调用用户自定义函数!",
      "再次调用同一函数"
    ]
  },
  "py-参数传递": {
    "prefix": "py-参数传递",
    "body": [
      "在 python 中，类型属于对象，变量是没有类型的：",
      "",
      "a=[1,2,3]",
      "",
      "a=\"Runoob\"",
      "以上代码中，[1,2,3] 是 List 类型，\"Runoob\" 是 String 类型，而变量 a 是没有类型，她仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。",
      "",
      "可更改(mutable)与不可更改(immutable)对象",
      "在 python 中，strings, tuples, 和 numbers 是不可更改的对象，而 list,dict 等则是可以修改的对象。",
      "",
      "不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。",
      "",
      "可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将 list la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。",
      "",
      "python 函数的参数传递：",
      "",
      "不可变类型：类似 c++ 的值传递，如 整数、字符串、元组。如fun（a），传递的只是a的值，没有影响a对象本身。比如在 fun（a）内部修改 a 的值，只是修改另一个复制的对象，不会影响 a 本身。",
      "",
      "可变类型：类似 c++ 的引用传递，如 列表，字典。如 fun（la），则是将 la 真正的传过去，修改后fun外部的la也会受影响",
      "",
      "python 中一切都是对象，严格意义我们不能说值传递还是引用传递，我们应该说传不可变对象和传可变对象。",
      "",
      "python 传不可变对象实例",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "def ChangeInt( a ):",
      "    a = 10",
      " ",
      "b = 2",
      "ChangeInt(b)",
      "print( b ) # 结果是 2",
      "实例中有 int 对象 2，指向它的变量是 b，在传递给 ChangeInt 函数时，按传值的方式复制了变量 b，a 和 b 都指向了同一个 Int 对象，在 a=10 时，则新生成一个 int 值对象 10，并让 a 指向它。",
      "",
      "传可变对象实例",
      "可变对象在函数里修改了参数，那么在调用这个函数的函数里，原始的参数也被改变了。例如：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "# 可写函数说明",
      "def changeme( mylist ):",
      "   \"修改传入的列表\"",
      "   mylist.append([1,2,3,4])",
      "   print (\"函数内取值: \", mylist)",
      "   return",
      " ",
      "# 调用changeme函数",
      "mylist = [10,20,30]",
      "changeme( mylist )",
      "print (\"函数外取值: \", mylist)",
      "传入函数的和在末尾添加新内容的对象用的是同一个引用。故输出结果如下：",
      "",
      "函数内取值:  [10, 20, 30, [1, 2, 3, 4]]",
      "函数外取值:  [10, 20, 30, [1, 2, 3, 4]]"
    ]
  },
  "py-函数参数": {
    "prefix": "py-函数参数",
    "body": [
      "以下是调用函数时可使用的正式参数类型：",
      "",
      "必需参数",
      "关键字参数",
      "默认参数",
      "不定长参数",
      "必需参数",
      "必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样。",
      "",
      "调用 printme() 函数，你必须传入一个参数，不然会出现语法错误：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#可写函数说明",
      "def printme( str ):",
      "   \"打印任何传入的字符串\"",
      "   print (str)",
      "   return",
      " ",
      "# 调用 printme 函数，不加参数会报错",
      "printme()",
      "以上实例输出结果：",
      "",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 10, in <module>",
      "    printme()",
      "TypeError: printme() missing 1 required positional argument: 'str'",
      "关键字参数",
      "关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。",
      "",
      "使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。",
      "",
      "以下实例在函数 printme() 调用时使用参数名：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#可写函数说明",
      "def printme( str ):",
      "   \"打印任何传入的字符串\"",
      "   print (str)",
      "   return",
      " ",
      "#调用printme函数",
      "printme( str = \"菜鸟教程\")",
      "以上实例输出结果：",
      "",
      "菜鸟教程",
      "以下实例中演示了函数参数的使用不需要使用指定顺序：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#可写函数说明",
      "def printinfo( name, age ):",
      "   \"打印任何传入的字符串\"",
      "   print (\"名字: \", name)",
      "   print (\"年龄: \", age)",
      "   return",
      " ",
      "#调用printinfo函数",
      "printinfo( age=50, name=\"runoob\" )",
      "以上实例输出结果：",
      "",
      "名字:  runoob",
      "年龄:  50",
      "默认参数",
      "调用函数时，如果没有传递参数，则会使用默认参数。以下实例中如果没有传入 age 参数，则使用默认值：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#可写函数说明",
      "def printinfo( name, age = 35 ):",
      "   \"打印任何传入的字符串\"",
      "   print (\"名字: \", name)",
      "   print (\"年龄: \", age)",
      "   return",
      " ",
      "#调用printinfo函数",
      "printinfo( age=50, name=\"runoob\" )",
      "print (\"------------------------\")",
      "printinfo( name=\"runoob\" )",
      "以上实例输出结果：",
      "",
      "名字:  runoob",
      "年龄:  50",
      "------------------------",
      "名字:  runoob",
      "年龄:  35",
      "不定长参数",
      "你可能需要一个函数能处理比当初声明时更多的参数。这些参数叫做不定长参数，和上述 2 种参数不同，声明时不会命名。基本语法如下：",
      "",
      "def functionname([formal_args,] *var_args_tuple ):",
      "   \"函数_文档字符串\"",
      "   function_suite",
      "   return [expression]",
      "加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数。",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      "  ",
      "# 可写函数说明",
      "def printinfo( arg1, *vartuple ):",
      "   \"打印任何传入的参数\"",
      "   print (\"输出: \")",
      "   print (arg1)",
      "   print (vartuple)",
      " ",
      "# 调用printinfo 函数",
      "printinfo( 70, 60, 50 )",
      "以上实例输出结果：",
      "",
      "输出: ",
      "70",
      "(60, 50)",
      "如果在函数调用时没有指定参数，它就是一个空元组。我们也可以不向函数传递未命名的变量。如下实例：",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "# 可写函数说明",
      "def printinfo( arg1, *vartuple ):",
      "   \"打印任何传入的参数\"",
      "   print (\"输出: \")",
      "   print (arg1)",
      "   for var in vartuple:",
      "      print (var)",
      "   return",
      " ",
      "# 调用printinfo 函数",
      "printinfo( 10 )",
      "printinfo( 70, 60, 50 )",
      "以上实例输出结果：",
      "",
      "输出:",
      "10",
      "输出:",
      "70",
      "60",
      "50",
      "还有一种就是参数带两个星号 **基本语法如下：",
      "",
      "def functionname([formal_args,] **var_args_dict ):",
      "   \"函数_文档字符串\"",
      "   function_suite",
      "   return [expression]",
      "加了两个星号 ** 的参数会以字典的形式导入。",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      "  ",
      "# 可写函数说明",
      "def printinfo( arg1, **vardict ):",
      "   \"打印任何传入的参数\"",
      "   print (\"输出: \")",
      "   print (arg1)",
      "   print (vardict)",
      " ",
      "# 调用printinfo 函数",
      "printinfo(1, a=2,b=3)",
      "以上实例输出结果：",
      "",
      "输出: ",
      "1",
      "{'a': 2, 'b': 3}",
      "声明函数时，参数中星号 * 可以单独出现，例如:",
      "",
      "def f(a,b,*,c):",
      "    return a+b+c",
      "如果单独出现星号 * 后的参数必须用关键字传入。",
      "",
      ">>> def f(a,b,*,c):",
      "...     return a+b+c",
      "... ",
      ">>> f(1,2,3)   # 报错",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 1, in <module>",
      "TypeError: f() takes 2 positional arguments but 3 were given",
      ">>> f(1,2,c=3) # 正常",
      "6",
      ">>>"
    ]
  },
  "py-lambda": {
    "prefix": "py-lambda",
    "body": [
      "python 使用 lambda 来创建匿名函数。",
      "",
      "所谓匿名，意即不再使用 def 语句这样标准的形式定义一个函数。",
      "",
      "lambda 只是一个表达式，函数体比 def 简单很多。",
      "lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。",
      "lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。",
      "虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。",
      "语法",
      "lambda 函数的语法只包含一个语句，如下：",
      "",
      "lambda [arg1 [,arg2,.....argn]]:expression",
      "如下实例：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "# 可写函数说明",
      "sum = lambda arg1, arg2: arg1 + arg2",
      " ",
      "# 调用sum函数",
      "print (\"相加后的值为 : \", sum( 10, 20 ))",
      "print (\"相加后的值为 : \", sum( 20, 20 ))",
      "以上实例输出结果：",
      "",
      "相加后的值为 :  30",
      "相加后的值为 :  40"
    ]
  },
  "py-List": {
    "prefix": "py-List",
    "body": [
      "列表",
      "Python中列表是可变的，这是它区别于字符串和元组的最重要的特点，一句话概括即：列表可以修改，而字符串和元组不能。",
      "",
      "以下是 Python 中列表的方法：",
      "",
      "方法 描述",
      "list.append(x) 把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。",
      "list.extend(L) 通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。",
      "list.insert(i, x) 在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。",
      "list.remove(x) 删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。",
      "list.pop([i]) 从列表的指定位置移除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被移除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。）",
      "list.clear() 移除列表中的所有项，等于del a[:]。",
      "list.index(x) 返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。",
      "list.count(x) 返回 x 在列表中出现的次数。",
      "list.sort() 对列表中的元素进行排序。",
      "list.reverse() 倒排列表中的元素。",
      "list.copy() 返回列表的浅复制，等于a[:]。",
      "下面示例演示了列表的大部分方法：",
      "",
      "实例",
      ">>> a = [66.25, 333, 333, 1, 1234.5]",
      ">>> print(a.count(333), a.count(66.25), a.count('x'))",
      "2 1 0",
      ">>> a.insert(2, -1)",
      ">>> a.append(333)",
      ">>> a",
      "[66.25, 333, -1, 333, 1, 1234.5, 333]",
      ">>> a.index(333)",
      "1",
      ">>> a.remove(333)",
      ">>> a",
      "[66.25, -1, 333, 1, 1234.5, 333]",
      ">>> a.reverse()",
      ">>> a",
      "[333, 1234.5, 1, 333, -1, 66.25]",
      ">>> a.sort()",
      ">>> a",
      "[-1, 1, 66.25, 333, 333, 1234.5]",
      "注意：类似 insert, remove 或 sort 等修改列表的方法没有返回值。"
    ]
  },
  "py-将列表当做堆栈使用": {
    "prefix": "py-将列表当做堆栈使用",
    "body": [
      "列表方法使得列表可以很方便的作为一个堆栈来使用，堆栈作为特定的数据结构，最先进入的元素最后一个被释放（后进先出）。用 append() 方法可以把一个元素添加到堆栈顶。用不指定索引的 pop() 方法可以把一个元素从堆栈顶释放出来。例如：",
      "",
      "实例",
      ">>> stack = [3, 4, 5]",
      ">>> stack.append(6)",
      ">>> stack.append(7)",
      ">>> stack",
      "[3, 4, 5, 6, 7]",
      ">>> stack.pop()",
      "7",
      ">>> stack",
      "[3, 4, 5, 6]",
      ">>> stack.pop()",
      "6",
      ">>> stack.pop()",
      "5",
      ">>> stack",
      "[3, 4]"
    ]
  },
  "py-将列表当作队列使用": {
    "prefix": "py-将列表当作队列使用",
    "body": [
      "也可以把列表当做队列用，只是在队列里第一加入的元素，第一个取出来；但是拿列表用作这样的目的效率不高。在列表的最后添加或者弹出元素速度快，然而在列表里插入或者从头部弹出速度却不快（因为所有其他的元素都得一个一个地移动）。",
      "",
      "实例",
      ">>> from collections import deque",
      ">>> queue = deque([\"Eric\", \"John\", \"Michael\"])",
      ">>> queue.append(\"Terry\")           # Terry arrives",
      ">>> queue.append(\"Graham\")          # Graham arrives",
      ">>> queue.popleft()                 # The first to arrive now leaves",
      "'Eric'",
      ">>> queue.popleft()                 # The second to arrive now leaves",
      "'John'",
      ">>> queue                           # Remaining queue in order of arrival",
      "deque(['Michael', 'Terry', 'Graham'])"
    ]
  },
  "py-列表推导式List": {
    "prefix": "py-列表推导式List",
    "body": [
      "列表推导式",
      "列表推导式提供了从序列创建列表的简单途径。通常应用程序将一些操作应用于某个序列的每个元素，用其获得的结果作为生成新列表的元素，或者根据确定的判定条件创建子序列。",
      "",
      "每个列表推导式都在 for 之后跟一个表达式，然后有零到多个 for 或 if 子句。返回结果是一个根据表达从其后的 for 和 if 上下文环境中生成出来的列表。如果希望表达式推导出一个元组，就必须使用括号。",
      "",
      "这里我们将列表中每个数值乘三，获得一个新的列表：",
      "",
      ">>> vec = [2, 4, 6]",
      ">>> [3*x for x in vec]",
      "[6, 12, 18]",
      "现在我们玩一点小花样：",
      "",
      ">>> [[x, x**2] for x in vec]",
      "[[2, 4], [4, 16], [6, 36]]",
      "这里我们对序列里每一个元素逐个调用某方法：",
      "",
      "实例",
      ">>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']",
      ">>> [weapon.strip() for weapon in freshfruit]",
      "['banana', 'loganberry', 'passion fruit']",
      "我们可以用 if 子句作为过滤器：",
      "",
      ">>> [3*x for x in vec if x > 3]",
      "[12, 18]",
      ">>> [3*x for x in vec if x < 2]",
      "[]",
      "以下是一些关于循环和其它技巧的演示：",
      "",
      ">>> vec1 = [2, 4, 6]",
      ">>> vec2 = [4, 3, -9]",
      ">>> [x*y for x in vec1 for y in vec2]",
      "[8, 6, -18, 16, 12, -36, 24, 18, -54]",
      ">>> [x+y for x in vec1 for y in vec2]",
      "[6, 5, -7, 8, 7, -5, 10, 9, -3]",
      ">>> [vec1[i]*vec2[i] for i in range(len(vec1))]",
      "[8, 12, -54]",
      "列表推导式可以使用复杂表达式或嵌套函数：",
      "",
      ">>> [str(round(355/113, i)) for i in range(1, 6)]",
      "['3.1', '3.14', '3.142', '3.1416', '3.14159']"
    ]
  },
  "py-del 语句": {
    "prefix": "py-del 语句",
    "body": [
      "使用 del 语句可以从一个列表中依索引而不是值来删除一个元素。这与使用 pop() 返回一个值不同。可以用 del 语句从列表中删除一个切割，或清空整个列表（我们以前介绍的方法是给该切割赋一个空列表）。例如：",
      "",
      ">>> a = [-1, 1, 66.25, 333, 333, 1234.5]",
      ">>> del a[0]",
      ">>> a",
      "[1, 66.25, 333, 333, 1234.5]",
      ">>> del a[2:4]",
      ">>> a",
      "[1, 66.25, 1234.5]",
      ">>> del a[:]",
      ">>> a",
      "[]",
      "也可以用 del 删除实体变量：",
      "",
      ">>> del a"
    ]
  },
  "py-元组和序列": {
    "prefix": "py-元组和序列",
    "body": [
      "元组由若干逗号分隔的值组成，例如：",
      "",
      ">>> t = 12345, 54321, 'hello!'",
      ">>> t[0]",
      "12345",
      ">>> t",
      "(12345, 54321, 'hello!')",
      ">>> # Tuples may be nested:",
      "... u = t, (1, 2, 3, 4, 5)",
      ">>> u",
      "((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))",
      "如你所见，元组在输出时总是有括号的，以便于正确表达嵌套结构。在输入时可能有或没有括号， 不过括号通常是必须的（如果元组是更大的表达式的一部分）"
    ]
  },
  "py-集合set": {
    "prefix": "py-集合set",
    "body": [
      "集合是一个无序不重复元素的集。基本功能包括关系测试和消除重复元素。",
      "",
      "可以用大括号({})创建集合。注意：如果要创建一个空集合，你必须用 set() 而不是 {} ；后者创建一个空的字典，下一节我们会介绍这个数据结构。",
      "",
      "以下是一个简单的演示：",
      "",
      ">>> basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}",
      ">>> print(basket)                      # 删除重复的",
      "{'orange', 'banana', 'pear', 'apple'}",
      ">>> 'orange' in basket                 # 检测成员",
      "True",
      ">>> 'crabgrass' in basket",
      "False",
      "",
      ">>> # 以下演示了两个集合的操作",
      "...",
      ">>> a = set('abracadabra')",
      ">>> b = set('alacazam')",
      ">>> a                                  # a 中唯一的字母",
      "{'a', 'r', 'b', 'c', 'd'}",
      ">>> a - b                              # 在 a 中的字母，但不在 b 中",
      "{'r', 'd', 'b'}",
      ">>> a | b                              # 在 a 或 b 中的字母",
      "{'a', 'c', 'r', 'd', 'b', 'm', 'z', 'l'}",
      ">>> a & b                              # 在 a 和 b 中都有的字母",
      "{'a', 'c'}",
      ">>> a ^ b                              # 在 a 或 b 中的字母，但不同时在 a 和 b 中",
      "{'r', 'd', 'b', 'm', 'z', 'l'}",
      "集合也支持推导式：",
      "",
      ">>> a = {x for x in 'abracadabra' if x not in 'abc'}",
      ">>> a",
      "{'r', 'd'}"
    ]
  },
  "py-字典2": {
    "prefix": "py-字典2",
    "body": [
      "另一个非常有用的 Python 内建数据类型是字典。",
      "",
      "序列是以连续的整数为索引，与此不同的是，字典以关键字为索引，关键字可以是任意不可变类型，通常用字符串或数值。",
      "",
      "理解字典的最佳方式是把它看做无序的键=>值对集合。在同一个字典之内，关键字必须是互不相同。",
      "",
      "一对大括号创建一个空的字典：{}。",
      "",
      "这是一个字典运用的简单例子：",
      "",
      ">>> tel = {'jack': 4098, 'sape': 4139}",
      ">>> tel['guido'] = 4127",
      ">>> tel",
      "{'sape': 4139, 'guido': 4127, 'jack': 4098}",
      ">>> tel['jack']",
      "4098",
      ">>> del tel['sape']",
      ">>> tel['irv'] = 4127",
      ">>> tel",
      "{'guido': 4127, 'irv': 4127, 'jack': 4098}",
      ">>> list(tel.keys())",
      "['irv', 'guido', 'jack']",
      ">>> sorted(tel.keys())",
      "['guido', 'irv', 'jack']",
      ">>> 'guido' in tel",
      "True",
      ">>> 'jack' not in tel",
      "False",
      "构造函数 dict() 直接从键值对元组列表中构建字典。如果有固定的模式，列表推导式指定特定的键值对：",
      "",
      ">>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])",
      "{'sape': 4139, 'jack': 4098, 'guido': 4127}",
      "此外，字典推导可以用来创建任意键和值的表达式词典：",
      "",
      ">>> {x: x**2 for x in (2, 4, 6)}",
      "{2: 4, 4: 16, 6: 36}",
      "如果关键字只是简单的字符串，使用关键字参数指定键值对有时候更方便：",
      "",
      ">>> dict(sape=4139, guido=4127, jack=4098)",
      "{'sape': 4139, 'jack': 4098, 'guido': 4127}"
    ]
  },
  "py-遍历技巧": {
    "prefix": "py-遍历技巧",
    "body": [
      "在字典中遍历时，关键字和对应的值可以使用 items() 方法同时解读出来：",
      "",
      ">>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}",
      ">>> for k, v in knights.items():",
      "...     print(k, v)",
      "...",
      "gallahad the pure",
      "robin the brave",
      "在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：",
      "",
      ">>> for i, v in enumerate(['tic', 'tac', 'toe']):",
      "...     print(i, v)",
      "...",
      "0 tic",
      "1 tac",
      "2 toe",
      "同时遍历两个或更多的序列，可以使用 zip() 组合：",
      "",
      ">>> questions = ['name', 'quest', 'favorite color']",
      ">>> answers = ['lancelot', 'the holy grail', 'blue']",
      ">>> for q, a in zip(questions, answers):",
      "...     print('What is your {0}?  It is {1}.'.format(q, a))",
      "...",
      "What is your name?  It is lancelot.",
      "What is your quest?  It is the holy grail.",
      "What is your favorite color?  It is blue.",
      "要反向遍历一个序列，首先指定这个序列，然后调用 reversed() 函数：",
      "",
      ">>> for i in reversed(range(1, 10, 2)):",
      "...     print(i)",
      "...",
      "9",
      "7",
      "5",
      "3",
      "1",
      "要按顺序遍历一个序列，使用 sorted() 函数返回一个已排序的序列，并不修改原值：",
      "",
      ">>> basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']",
      ">>> for f in sorted(set(basket)):",
      "...     print(f)",
      "...",
      "apple",
      "banana",
      "orange",
      "pear"
    ]
  },
  "py-import": {
    "prefix": "py-import",
    "body": [
      "想使用 Python 源文件，只需在另一个源文件里执行 import 语句，语法如下：",
      "",
      "import module1[, module2[,... moduleN]",
      "当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。",
      "",
      "搜索路径是一个解释器会先进行搜索的所有目录的列表。如想要导入模块 support，需要把命令放在脚本的顶端：",
      "",
      "support.py 文件代码",
      "#!/usr/bin/python3",
      "# Filename: support.py",
      " ",
      "def print_func( par ):",
      "    print (\"Hello : \", par)",
      "    return",
      "test.py 引入 support 模块：",
      "",
      "test.py 文件代码",
      "#!/usr/bin/python3",
      "# Filename: test.py",
      " ",
      "# 导入模块",
      "import support",
      " ",
      "# 现在可以调用模块里包含的函数了",
      "support.print_func(\"Runoob\")",
      "以上实例输出结果：",
      "",
      "$ python3 test.py ",
      "Hello :  Runoob",
      "一个模块只会被导入一次，不管你执行了多少次import。这样可以防止导入模块被一遍又一遍地执行。",
      "",
      "当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？",
      "",
      "这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。",
      "",
      "这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。",
      "",
      "搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量，做一个简单的实验，在交互式解释器中，输入以下代码：",
      "",
      ">>> import sys",
      ">>> sys.path",
      "['', '/usr/lib/python3.4', '/usr/lib/python3.4/plat-x86_64-linux-gnu', '/usr/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/dist-packages', '/usr/lib/python3/dist-packages']",
      ">>> ",
      "sys.path 输出是一个列表，其中第一项是空串''，代表当前目录（若是从一个脚本中打印出来的话，可以更清楚地看出是哪个目录），亦即我们执行python解释器的目录（对于脚本的话就是运行的脚本所在的目录）。",
      "",
      "因此若像我一样在当前目录下存在与要引入模块同名的文件，就会把要引入的模块屏蔽掉。",
      "",
      "了解了搜索路径的概念，就可以在脚本中修改sys.path来引入一些不在搜索路径中的模块。",
      "",
      "现在，在解释器的当前目录或者 sys.path 中的一个目录里面来创建一个fibo.py的文件，代码如下：",
      "",
      "实例",
      "# 斐波那契(fibonacci)数列模块",
      " ",
      "def fib(n):    # 定义到 n 的斐波那契数列",
      "    a, b = 0, 1",
      "    while b < n:",
      "        print(b, end=' ')",
      "        a, b = b, a+b",
      "    print()",
      " ",
      "def fib2(n): # 返回到 n 的斐波那契数列",
      "    result = []",
      "    a, b = 0, 1",
      "    while b < n:",
      "        result.append(b)",
      "        a, b = b, a+b",
      "    return result",
      "然后进入Python解释器，使用下面的命令导入这个模块：",
      "",
      ">>> import fibo",
      "这样做并没有把直接定义在fibo中的函数名称写入到当前符号表里，只是把模块fibo的名字写到了那里。",
      "",
      "可以使用模块名称来访问函数：",
      "",
      "实例",
      ">>>fibo.fib(1000)",
      "1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987",
      ">>> fibo.fib2(100)",
      "[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]",
      ">>> fibo.__name__",
      "'fibo'",
      "如果你打算经常使用一个函数，你可以把它赋给一个本地的名称：",
      "",
      ">>> fib = fibo.fib",
      ">>> fib(500)",
      "1 1 2 3 5 8 13 21 34 55 89 144 233 377"
    ]
  },
  "py-from … import": {
    "prefix": "py-from … import",
    "body": [
      "Python 的 from 语句让你从模块中导入一个指定的部分到当前命名空间中，语法如下：",
      "",
      "from modname import name1[, name2[, ... nameN]]",
      "例如，要导入模块 fibo 的 fib 函数，使用如下语句：",
      "",
      ">>> from fibo import fib, fib2",
      ">>> fib(500)",
      "1 1 2 3 5 8 13 21 34 55 89 144 233 377",
      "这个声明不会把整个fibo模块导入到当前的命名空间中，它只会将fibo里的fib函数引入进来。"
    ]
  },
  "py-from … import *": {
    "prefix": "py-from … import *",
    "body": [
      "把一个模块的所有内容全都导入到当前的命名空间也是可行的，只需使用如下声明：",
      "",
      "from modname import *",
      "这提供了一个简单的方法来导入一个模块中的所有项目。然而这种声明不该被过多地使用。"
    ]
  },
  "py-dir() 函数": {
    "prefix": "py-dir() 函数",
    "body": []
  },
  "py-包": {
    "prefix": "py-包",
    "body": [
      "用户可以每次只导入一个包里面的特定模块，比如:",
      "",
      "import sound.effects.echo",
      "这将会导入子模块:sound.effects.echo。 他必须使用全名去访问:",
      "",
      "sound.effects.echo.echofilter(input, output, delay=0.7, atten=4)",
      "还有一种导入子模块的方法是:",
      "",
      "from sound.effects import echo",
      "这同样会导入子模块: echo，并且他不需要那些冗长的前缀，所以他可以这样使用:",
      "",
      "echo.echofilter(input, output, delay=0.7, atten=4)",
      "还有一种变化就是直接导入一个函数或者变量:",
      "",
      "from sound.effects.echo import echofilter",
      "同样的，这种方法会导入子模块: echo，并且可以直接使用他的 echofilter() 函数:",
      "",
      "echofilter(input, output, delay=0.7, atten=4)",
      "注意当使用 from package import item 这种形式的时候，对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量。",
      "",
      "import 语法会首先把 item 当作一个包定义的名称，如果没找到，再试图按照一个模块去导入。如果还没找到，抛出一个 :exc:ImportError 异常。",
      "",
      "反之，如果使用形如 import item.subitem.subsubitem 这种导入形式，除了最后一项，都必须是包，而最后一项则可以是模块或者是包，但是不可以是类，函数或者变量的名字。"
    ]
  },
  "py-输出格式美化": {
    "prefix": "py-输出格式美化",
    "body": [
      "Python两种输出值的方式: 表达式语句和 print() 函数。",
      "",
      "第三种方式是使用文件对象的 write() 方法，标准输出文件可以用 sys.stdout 引用。",
      "",
      "如果你希望输出的形式更加多样，可以使用 str.format() 函数来格式化输出值。",
      "",
      "如果你希望将输出的值转成字符串，可以使用 repr() 或 str() 函数来实现。",
      "",
      "str()： 函数返回一个用户易读的表达形式。",
      "repr()： 产生一个解释器易读的表达形式。",
      "例如",
      ">>> s = 'Hello, Runoob'",
      ">>> str(s)",
      "'Hello, Runoob'",
      ">>> repr(s)",
      "\"'Hello, Runoob'\"",
      ">>> str(1/7)",
      "'0.14285714285714285'",
      ">>> x = 10 * 3.25",
      ">>> y = 200 * 200",
      ">>> s = 'x 的值为： ' + repr(x) + ',  y 的值为：' + repr(y) + '...'",
      ">>> print(s)",
      "x 的值为： 32.5,  y 的值为：40000...",
      ">>> #  repr() 函数可以转义字符串中的特殊字符",
      "... hello = 'hello, runoob\n'",
      ">>> hellos = repr(hello)",
      ">>> print(hellos)",
      "'hello, runoob\n'",
      ">>> # repr() 的参数可以是 Python 的任何对象",
      "... repr((x, y, ('Google', 'Runoob')))",
      "\"(32.5, 40000, ('Google', 'Runoob'))\"",
      "这里有两种方式输出一个平方与立方的表:",
      "",
      ">>> for x in range(1, 11):",
      "...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')",
      "...     # 注意前一行 'end' 的使用",
      "...     print(repr(x*x*x).rjust(4))",
      "...",
      " 1   1    1",
      " 2   4    8",
      " 3   9   27",
      " 4  16   64",
      " 5  25  125",
      " 6  36  216",
      " 7  49  343",
      " 8  64  512",
      " 9  81  729",
      "10 100 1000",
      "",
      ">>> for x in range(1, 11):",
      "...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))",
      "...",
      " 1   1    1",
      " 2   4    8",
      " 3   9   27",
      " 4  16   64",
      " 5  25  125",
      " 6  36  216",
      " 7  49  343",
      " 8  64  512",
      " 9  81  729",
      "10 100 1000",
      "注意：在第一个例子中, 每列间的空格由 print() 添加。",
      "",
      "这个例子展示了字符串对象的 rjust() 方法, 它可以将字符串靠右, 并在左边填充空格。",
      "",
      "还有类似的方法, 如 ljust() 和 center()。 这些方法并不会写任何东西, 它们仅仅返回新的字符串。"
    ]
  },
  "py-zfill": {
    "prefix": "py-zfill",
    "body": [
      "另一个方法 zfill(), 它会在数字的左边填充 0，如下所示：",
      "",
      ">>> '12'.zfill(5)",
      "'00012'",
      ">>> '-3.14'.zfill(7)",
      "'-003.14'",
      ">>> '3.14159265359'.zfill(5)",
      "'3.14159265359'"
    ]
  },
  "py-format": {
    "prefix": "py-format",
    "body": [
      "str.format() 的基本使用如下:",
      "",
      ">>> print('{}网址： \"{}!\"'.format('菜鸟教程', 'www.runoob.com'))",
      "菜鸟教程网址： \"www.runoob.com!\"",
      "括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换。",
      "",
      "在括号中的数字用于指向传入对象在 format() 中的位置，如下所示：",
      "",
      ">>> print('{0} 和 {1}'.format('Google', 'Runoob'))",
      "Google 和 Runoob",
      ">>> print('{1} 和 {0}'.format('Google', 'Runoob'))",
      "Runoob 和 Google",
      "如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数。",
      "",
      ">>> print('{name}网址： {site}'.format(name='菜鸟教程', site='www.runoob.com'))",
      "菜鸟教程网址： www.runoob.com",
      "位置及关键字参数可以任意的结合:",
      "",
      ">>> print('站点列表 {0}, {1}, 和 {other}。'.format('Google', 'Runoob', other='Taobao'))",
      "站点列表 Google, Runoob, 和 Taobao。"
    ]
  },
  "py-可选项 : 和格式标识符可以跟着字段名": {
    "prefix": "py-可选项 : 和格式标识符可以跟着字段名",
    "body": [
      "可选项 : 和格式标识符可以跟着字段名。 这就允许对值进行更好的格式化。 下面的例子将 Pi 保留到小数点后三位：",
      "",
      ">>> import math",
      ">>> print('常量 PI 的值近似为 {0:.3f}。'.format(math.pi))",
      "常量 PI 的值近似为 3.142。",
      "在 : 后传入一个整数, 可以保证该域至少有这么多的宽度。 用于美化表格时很有用。",
      "",
      ">>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}",
      ">>> for name, number in table.items():",
      "...     print('{0:10} ==> {1:10d}'.format(name, number))",
      "...",
      "Google     ==>          1",
      "Runoob     ==>          2",
      "Taobao     ==>          3",
      "如果你有一个很长的格式化字符串, 而你不想将它们分开, 那么在格式化时通过变量名而非位置会是很好的事情。",
      "",
      "最简单的就是传入一个字典, 然后使用方括号 [] 来访问键值 :",
      "",
      ">>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}",
      ">>> print('Runoob: {0[Runoob]:d}; Google: {0[Google]:d}; Taobao: {0[Taobao]:d}'.format(table))",
      "Runoob: 2; Google: 1; Taobao: 3",
      "也可以通过在 table 变量前使用 ** 来实现相同的功能：",
      "",
      ">>> table = {'Google': 1, 'Runoob': 2, 'Taobao': 3}",
      ">>> print('Runoob: {Runoob:d}; Google: {Google:d}; Taobao: {Taobao:d}'.format(**table))",
      "Runoob: 2; Google: 1; Taobao: 3"
    ]
  },
  "py-旧式字符串格式化": {
    "prefix": "py-旧式字符串格式化",
    "body": [
      "% 操作符也可以实现字符串格式化。 它将左边的参数作为类似 sprintf() 式的格式化字符串, 而将右边的代入, 然后返回格式化后的字符串. 例如:",
      "",
      ">>> import math",
      ">>> print('常量 PI 的值近似为：%5.3f。' % math.pi)",
      "常量 PI 的值近似为：3.142。",
      "因为 str.format() 是比较新的函数， 大多数的 Python 代码仍然使用 % 操作符。但是因为这种旧式的格式化最终会从该语言中移除, 应该更多的使用 str.format()."
    ]
  },
  "py-读取键盘输入": {
    "prefix": "py-读取键盘输入",
    "body": [
      "Python提供了 input() 内置函数从标准输入读入一行文本，默认的标准输入是键盘。",
      "",
      "input 可以接收一个Python表达式作为输入，并将运算结果返回。",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "str = input(\"请输入：\");",
      "print (\"你输入的内容是: \", str)",
      "这会产生如下的对应着输入的结果：",
      "",
      "请输入：菜鸟教程",
      "你输入的内容是:  菜鸟教程"
    ]
  },
  "py-读和写文件": {
    "prefix": "py-读和写文件",
    "body": [
      "open() 将会返回一个 file 对象，基本语法格式如下:",
      "",
      "open(filename, mode)",
      "filename：包含了你要访问的文件名称的字符串值。",
      "mode：决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。",
      "以下实例将字符串写入到文件 foo.txt 中：",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo.txt\", \"w\")",
      "",
      "f.write( \"Python 是一个非常好的语言。\n是的，的确非常好!!\n\" )",
      "",
      "# 关闭打开的文件",
      "f.close()",
      "第一个参数为要打开的文件名。",
      "第二个参数描述文件如何使用的字符。 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。",
      "此时打开文件 foo.txt,显示如下：",
      "",
      "$ cat /tmp/foo.txt ",
      "Python 是一个非常好的语言。",
      "是的，的确非常好!!"
    ]
  },
  "py-文件对象的方法": {
    "prefix": "py-文件对象的方法",
    "body": [
      "本节中剩下的例子假设已经创建了一个称为 f 的文件对象。",
      "",
      "f.read()",
      "为了读取一个文件的内容，调用 f.read(size), 这将读取一定数目的数据, 然后作为字符串或字节对象返回。",
      "",
      "size 是一个可选的数字类型的参数。 当 size 被忽略了或者为负, 那么该文件的所有内容都将被读取并且返回。",
      "",
      "以下实例假定文件 foo.txt 已存在（上面实例中已创建）：",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo.txt\", \"r\")",
      "",
      "str = f.read()",
      "print(str)",
      "",
      "# 关闭打开的文件",
      "f.close()",
      "执行以上程序，输出结果为：",
      "",
      "Python 是一个非常好的语言。",
      "是的，的确非常好!!",
      "f.readline()",
      "f.readline() 会从文件中读取单独的一行。换行符为 '\n'。f.readline() 如果返回一个空字符串, 说明已经已经读取到最后一行。",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo.txt\", \"r\")",
      "",
      "str = f.readline()",
      "print(str)",
      "",
      "# 关闭打开的文件",
      "f.close()",
      "执行以上程序，输出结果为：",
      "",
      "Python 是一个非常好的语言。",
      "f.readlines()",
      "f.readlines() 将返回该文件中包含的所有行。",
      "",
      "如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo.txt\", \"r\")",
      "",
      "str = f.readlines()",
      "print(str)",
      "",
      "# 关闭打开的文件",
      "f.close()",
      "执行以上程序，输出结果为：",
      "",
      "['Python 是一个非常好的语言。\n', '是的，的确非常好!!\n']",
      "另一种方式是迭代一个文件对象然后读取每行:",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo.txt\", \"r\")",
      "",
      "for line in f:",
      "    print(line, end='')",
      "",
      "# 关闭打开的文件",
      "f.close()",
      "执行以上程序，输出结果为：",
      "",
      "Python 是一个非常好的语言。",
      "是的，的确非常好!!",
      "这个方法很简单, 但是并没有提供一个很好的控制。 因为两者的处理机制不同, 最好不要混用。",
      "",
      "f.write()",
      "f.write(string) 将 string 写入到文件中, 然后返回写入的字符数。",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo.txt\", \"w\")",
      "",
      "num = f.write( \"Python 是一个非常好的语言。\n是的，的确非常好!!\n\" )",
      "print(num)",
      "# 关闭打开的文件",
      "f.close()",
      "执行以上程序，输出结果为：",
      "",
      "29",
      "如果要写入一些不是字符串的东西, 那么将需要先进行转换:",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "# 打开一个文件",
      "f = open(\"/tmp/foo1.txt\", \"w\")",
      "",
      "value = ('www.runoob.com', 14)",
      "s = str(value)",
      "f.write(s)",
      "",
      "# 关闭打开的文件",
      "f.close()",
      "执行以上程序，打开 foo1.txt 文件：",
      "",
      "$ cat /tmp/foo1.txt ",
      "('www.runoob.com', 14)",
      "f.tell()",
      "f.tell() 返回文件对象当前所处的位置, 它是从文件开头开始算起的字节数。",
      "",
      "f.seek()",
      "如果要改变文件当前的位置, 可以使用 f.seek(offset, from_what) 函数。",
      "",
      "from_what 的值, 如果是 0 表示开头, 如果是 1 表示当前位置, 2 表示文件的结尾，例如：",
      "",
      "seek(x,0) ： 从起始位置即文件首行首字符开始移动 x 个字符",
      "seek(x,1) ： 表示从当前位置往后移动x个字符",
      "seek(-x,2)：表示从文件的结尾往前移动x个字符",
      "from_what 值为默认为0，即文件开头。下面给出一个完整的例子：",
      "",
      ">>> f = open('/tmp/foo.txt', 'rb+')",
      ">>> f.write(b'0123456789abcdef')",
      "16",
      ">>> f.seek(5)     # 移动到文件的第六个字节",
      "5",
      ">>> f.read(1)",
      "b'5'",
      ">>> f.seek(-3, 2) # 移动到文件的倒数第三字节",
      "13",
      ">>> f.read(1)",
      "b'd'",
      "f.close()",
      "在文本文件中 (那些打开文件的模式下没有 b 的), 只会相对于文件起始位置进行定位。",
      "",
      "当你处理完一个文件后, 调用 f.close() 来关闭文件并释放系统的资源，如果尝试再调用该文件，则会抛出异常。",
      "",
      ">>> f.close()",
      ">>> f.read()",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 1, in ?",
      "ValueError: I/O operation on closed file",
      "当处理一个文件对象时, 使用 with 关键字是非常好的方式。在结束后, 它会帮你正确的关闭文件。 而且写起来也比 try - finally 语句块要简短:",
      "",
      ">>> with open('/tmp/foo.txt', 'r') as f:",
      "...     read_data = f.read()",
      ">>> f.closed",
      "True",
      "文件对象还有其他方法, 如 isatty() 和 trucate(), 但这些通常比较少用。"
    ]
  },
  "py-pickle序列化": {
    "prefix": "py-pickle序列化",
    "body": [
      "python的pickle模块实现了基本的数据序列和反序列化。",
      "",
      "通过pickle模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。",
      "",
      "通过pickle模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。",
      "",
      "基本接口：",
      "",
      "pickle.dump(obj, file, [,protocol])",
      "有了 pickle 这个对象, 就能对 file 以读取的形式打开:",
      "",
      "x = pickle.load(file)",
      "注解：从 file 中读取一个字符串，并将它重构为原来的python对象。",
      "",
      "file: 类文件对象，有read()和readline()接口。",
      "",
      "实例 1",
      "#!/usr/bin/python3",
      "import pickle",
      "",
      "# 使用pickle模块将数据对象保存到文件",
      "data1 = {'a': [1, 2.0, 3, 4+6j],",
      "         'b': ('string', u'Unicode string'),",
      "         'c': None}",
      "",
      "selfref_list = [1, 2, 3]",
      "selfref_list.append(selfref_list)",
      "",
      "output = open('data.pkl', 'wb')",
      "",
      "# Pickle dictionary using protocol 0.",
      "pickle.dump(data1, output)",
      "",
      "# Pickle the list using the highest protocol available.",
      "pickle.dump(selfref_list, output, -1)",
      "",
      "output.close()",
      "实例 2",
      "#!/usr/bin/python3",
      "import pprint, pickle",
      "",
      "#使用pickle模块从文件中重构python对象",
      "pkl_file = open('data.pkl', 'rb')",
      "",
      "data1 = pickle.load(pkl_file)",
      "pprint.pprint(data1)",
      "",
      "data2 = pickle.load(pkl_file)",
      "pprint.pprint(data2)",
      "",
      "pkl_file.close()"
    ]
  },
  "py-File(文件) 方法": {
    "prefix": "py-File(文件) 方法",
    "body": [
      "open() 方法",
      "Python open() 方法用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 OSError。",
      "",
      "注意：使用 open() 方法一定要保证关闭文件对象，即调用 close() 方法。",
      "",
      "open() 函数常用形式是接收两个参数：文件名(file)和模式(mode)。",
      "",
      "open(file, mode='r')",
      "完整的语法格式为：",
      "",
      "open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)",
      "参数说明:",
      "",
      "file: 必需，文件路径（相对或者绝对路径）。",
      "mode: 可选，文件打开模式",
      "buffering: 设置缓冲",
      "encoding: 一般使用utf8",
      "errors: 报错级别",
      "newline: 区分换行符",
      "closefd: 传入的file参数类型",
      "opener:",
      "mode 参数有：",
      "",
      "模式描述",
      "t文本模式 (默认)。",
      "x写模式，新建一个文件，如果该文件已存在则会报错。",
      "b二进制模式。",
      "+打开一个文件进行更新(可读可写)。",
      "U通用换行模式（Python 3 不支持）。",
      "r以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。",
      "rb以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。",
      "r+打开一个文件用于读写。文件指针将会放在文件的开头。",
      "rb+以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。",
      "w打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。",
      "wb以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。",
      "w+打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。",
      "wb+以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。",
      "a打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。",
      "ab以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。",
      "a+打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。",
      "ab+以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。",
      "默认为文本模式，如果要以二进制模式打开，加上 b 。",
      "",
      "file 对象",
      "file 对象使用 open 函数来创建，下表列出了 file 对象常用的函数：",
      "",
      "序号方法及描述",
      "1",
      "file.close()",
      "",
      "关闭文件。关闭后文件不能再进行读写操作。",
      "",
      "2",
      "file.flush()",
      "",
      "刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。",
      "",
      "3",
      "file.fileno()",
      "",
      "返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。",
      "",
      "4",
      "file.isatty()",
      "",
      "如果文件连接到一个终端设备返回 True，否则返回 False。",
      "",
      "5",
      "file.next()",
      "",
      "Python 3 中的 File 对象不支持 next() 方法。",
      "",
      "返回文件下一行。",
      "",
      "6",
      "file.read([size])",
      "",
      "从文件读取指定的字节数，如果未给定或为负则读取所有。",
      "",
      "7",
      "file.readline([size])",
      "",
      "读取整行，包括 \"\n\" 字符。",
      "",
      "8",
      "file.readlines([sizeint])",
      "",
      "读取所有行并返回列表，若给定sizeint>0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。",
      "",
      "9",
      "file.seek(offset[, whence])",
      "",
      "移动文件读取指针到指定位置",
      "",
      "10",
      "file.tell()",
      "",
      "返回文件当前位置。",
      "",
      "11",
      "file.truncate([size])",
      "",
      "从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。",
      "",
      "12",
      "file.write(str)",
      "",
      "将字符串写入文件，返回的是写入的字符长度。",
      "",
      "13",
      "file.writelines(sequence)",
      "",
      "向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。"
    ]
  },
  "py-OS 文件/目录方法": {
    "prefix": "py-OS 文件/目录方法",
    "body": [
      "os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示：",
      "",
      "序号方法及描述",
      "1",
      "os.access(path, mode)",
      "",
      "",
      "检验权限模式",
      "2",
      "os.chdir(path)",
      "",
      "",
      "改变当前工作目录",
      "3",
      "os.chflags(path, flags)",
      "",
      "",
      "设置路径的标记为数字标记。",
      "4",
      "os.chmod(path, mode)",
      "",
      "",
      "更改权限",
      "5",
      "os.chown(path, uid, gid)",
      "",
      "",
      "更改文件所有者",
      "6",
      "os.chroot(path)",
      "",
      "",
      "改变当前进程的根目录",
      "7	",
      "os.close(fd)",
      "",
      "",
      "关闭文件描述符 fd",
      "8",
      "os.closerange(fd_low, fd_high)",
      "",
      "",
      "关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略",
      "9",
      "os.dup(fd)",
      "",
      "",
      "复制文件描述符 fd",
      "10",
      "os.dup2(fd, fd2)",
      "",
      "",
      "将一个文件描述符 fd 复制到另一个 fd2",
      "11",
      "os.fchdir(fd)",
      "",
      "",
      "通过文件描述符改变当前工作目录",
      "12",
      "os.fchmod(fd, mode)",
      "",
      "",
      "改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。",
      "13",
      "os.fchown(fd, uid, gid)",
      "",
      "",
      "修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。",
      "14",
      "os.fdatasync(fd)",
      "",
      "",
      "强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。",
      "15",
      "os.fdopen(fd[, mode[, bufsize]])",
      "",
      "",
      "通过文件描述符 fd 创建一个文件对象，并返回这个文件对象",
      "16",
      "os.fpathconf(fd, name)",
      "",
      "",
      "返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。",
      "17",
      "os.fstat(fd)",
      "",
      "",
      "返回文件描述符fd的状态，像stat()。",
      "18",
      "os.fstatvfs(fd)",
      "",
      "",
      "返回包含文件描述符fd的文件的文件系统的信息，Python 3.3 相等于 statvfs()。",
      "19",
      "os.fsync(fd)",
      "",
      "",
      "强制将文件描述符为fd的文件写入硬盘。",
      "20",
      "os.ftruncate(fd, length)",
      "",
      "",
      "裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。",
      "21",
      "os.getcwd()",
      "",
      "",
      "返回当前工作目录",
      "22",
      "os.getcwdu()",
      "",
      "",
      "返回一个当前工作目录的Unicode对象",
      "23",
      "os.isatty(fd)",
      "",
      "",
      "如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。",
      "24",
      "os.lchflags(path, flags)",
      "",
      "",
      "设置路径的标记为数字标记，类似 chflags()，但是没有软链接",
      "25",
      "os.lchmod(path, mode)",
      "",
      "",
      "修改连接文件权限",
      "26",
      "os.lchown(path, uid, gid)",
      "",
      "",
      "更改文件所有者，类似 chown，但是不追踪链接。",
      "27",
      "os.link(src, dst)",
      "",
      "",
      "创建硬链接，名为参数 dst，指向参数 src",
      "28",
      "os.listdir(path)",
      "",
      "",
      "返回path指定的文件夹包含的文件或文件夹的名字的列表。",
      "29",
      "os.lseek(fd, pos, how)",
      "",
      "",
      "设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效",
      "30",
      "os.lstat(path)",
      "",
      "",
      "像stat(),但是没有软链接",
      "31",
      "os.major(device)",
      "",
      "",
      "从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。",
      "32",
      "os.makedev(major, minor)",
      "",
      "",
      "以major和minor设备号组成一个原始设备号",
      "33	",
      "os.makedirs(path[, mode])",
      "",
      "",
      "递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。",
      "34",
      "os.minor(device)",
      "",
      "",
      "从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。",
      "35",
      "os.mkdir(path[, mode])",
      "",
      "",
      "以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。",
      "36",
      "os.mkfifo(path[, mode])",
      "",
      "",
      "创建命名管道，mode 为数字，默认为 0666 (八进制)",
      "37",
      "os.mknod(filename[, mode=0600, device])",
      "创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。",
      "",
      "38",
      "os.open(file, flags[, mode])",
      "",
      "",
      "打开一个文件，并且设置需要的打开选项，mode参数是可选的",
      "39",
      "os.openpty()",
      "",
      "",
      "打开一个新的伪终端对。返回 pty 和 tty的文件描述符。",
      "40",
      "os.pathconf(path, name)",
      "",
      "",
      "返回相关文件的系统配置信息。",
      "41",
      "os.pipe()",
      "",
      "",
      "创建一个管道. 返回一对文件描述符(r, w) 分别为读和写",
      "42",
      "os.popen(command[, mode[, bufsize]])",
      "",
      "",
      "从一个 command 打开一个管道",
      "43",
      "os.read(fd, n)",
      "",
      "",
      "从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。",
      "44",
      "os.readlink(path)",
      "",
      "",
      "返回软链接所指向的文件",
      "45",
      "os.remove(path)",
      "",
      "",
      "删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()删除一个 directory。",
      "46",
      "os.removedirs(path)",
      "",
      "",
      "递归删除目录。",
      "47",
      "os.rename(src, dst)",
      "",
      "",
      "重命名文件或目录，从 src 到 dst",
      "48",
      "os.renames(old, new)",
      "",
      "",
      "递归地对目录进行更名，也可以对文件进行更名。",
      "49",
      "os.rmdir(path)",
      "",
      "",
      "删除path指定的空目录，如果目录非空，则抛出一个OSError异常。",
      "50",
      "os.stat(path)",
      "",
      "",
      "获取path指定的路径的信息，功能等同于C API中的stat()系统调用。",
      "51",
      "os.stat_float_times([newvalue])",
      "决定stat_result是否以float对象显示时间戳",
      "",
      "52",
      "os.statvfs(path)",
      "",
      "",
      "获取指定路径的文件系统统计信息",
      "53",
      "os.symlink(src, dst)",
      "",
      "",
      "创建一个软链接",
      "54",
      "os.tcgetpgrp(fd)",
      "",
      "",
      "返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组",
      "55",
      "os.tcsetpgrp(fd, pg)",
      "",
      "",
      "设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。",
      "56",
      "os.tempnam([dir[, prefix]])",
      "",
      "",
      "Python3 中已删除。返回唯一的路径名用于创建临时文件。",
      "57",
      "os.tmpfile()",
      "",
      "",
      "Python3 中已删除。返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。",
      "58",
      "os.tmpnam()",
      "",
      "",
      "Python3 中已删除。为创建一个临时文件返回一个唯一的路径",
      "59",
      "os.ttyname(fd)",
      "",
      "",
      "返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。",
      "60",
      "os.unlink(path)",
      "",
      "",
      "删除文件路径",
      "61",
      "os.utime(path, times)",
      "",
      "",
      "返回指定的path文件的访问和修改的时间。",
      "62",
      "os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])",
      "",
      "",
      "输出在文件夹中的文件名通过在树中游走，向上或者向下。",
      "63",
      "os.write(fd, str)",
      "",
      "",
      "写入字符串到文件描述符 fd中. 返回实际写入的字符串长度",
      "64",
      "os.path 模块",
      "",
      "",
      "获取文件的属性信息。",
      "65",
      "os.pardir()",
      "",
      "",
      "获取当前目录的父目录，以字符串形式显示目录名"
    ]
  },
  "py-try/except": {
    "prefix": "py-try/except",
    "body": [
      "以下例子中，让用户输入一个合法的整数，但是允许用户中断这个程序（使用 Control-C 或者操作系统提供的方法）。用户中断的信息会引发一个 KeyboardInterrupt 异常。",
      "",
      "while True:",
      "    try:",
      "        x = int(input(\"请输入一个数字: \"))",
      "        break",
      "    except ValueError:",
      "        print(\"您输入的不是数字，请再次尝试输入！\")",
      "try 语句按照如下方式工作；",
      "",
      "首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。",
      "",
      "如果没有异常发生，忽略 except 子句，try 子句执行后结束。",
      "",
      "如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。",
      "",
      "如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。",
      "",
      "一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。",
      "",
      "处理程序将只针对对应的 try 子句中的异常进行处理，而不是其他的 try 的处理程序中的异常。",
      "",
      "一个except子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组，例如:",
      "",
      "except (RuntimeError, TypeError, NameError):",
      "    pass",
      "最后一个except子句可以忽略异常的名称，它将被当作通配符使用。你可以使用这种方法打印一个错误信息，然后再次把异常抛出。",
      "",
      "import sys",
      "",
      "try:",
      "    f = open('myfile.txt')",
      "    s = f.readline()",
      "    i = int(s.strip())",
      "except OSError as err:",
      "    print(\"OS error: {0}\".format(err))",
      "except ValueError:",
      "    print(\"Could not convert data to an integer.\")",
      "except:",
      "    print(\"Unexpected error:\", sys.exc_info()[0])",
      "    raise",
      "try/except...else",
      "try/except 语句还有一个可选的 else 子句，如果使用这个子句，那么必须放在所有的 except 子句之后。",
      "",
      "else 子句将在 try 子句没有发生任何异常的时候执行。",
      "",
      "",
      "",
      "以下实例在 try 语句中判断文件是否可以打开，如果打开文件时正常的没有发生异常则执行 else 部分的语句，读取文件内容：",
      "",
      "for arg in sys.argv[1:]:",
      "    try:",
      "        f = open(arg, 'r')",
      "    except IOError:",
      "        print('cannot open', arg)",
      "    else:",
      "        print(arg, 'has', len(f.readlines()), 'lines')",
      "        f.close()",
      "使用 else 子句比把所有的语句都放在 try 子句里面要好，这样可以避免一些意想不到，而 except 又无法捕获的异常。",
      "",
      "异常处理并不仅仅处理那些直接发生在 try 子句中的异常，而且还能处理子句中调用的函数（甚至间接调用的函数）里抛出的异常。例如:",
      "",
      ">>> def this_fails():",
      "        x = 1/0",
      "   ",
      ">>> try:",
      "        this_fails()",
      "    except ZeroDivisionError as err:",
      "        print('Handling run-time error:', err)",
      "   ",
      "Handling run-time error: int division or modulo by zero",
      "try-finally 语句",
      "try-finally 语句无论是否发生异常都将执行最后的代码。",
      "",
      "",
      "",
      "以下实例中 finally 语句无论异常是否发生都会执行：",
      "",
      "实例",
      "try:",
      "    runoob()",
      "except AssertionError as error:",
      "    print(error)",
      "else:",
      "    try:",
      "        with open('file.log') as file:",
      "            read_data = file.read()",
      "    except FileNotFoundError as fnf_error:",
      "        print(fnf_error)",
      "finally:",
      "    print('这句话，无论异常是否发生都会执行。')"
    ]
  },
  "py-抛出异常": {
    "prefix": "py-抛出异常",
    "body": [
      "Python 使用 raise 语句抛出一个指定的异常。",
      "",
      "raise语法格式如下：",
      "",
      "raise [Exception [, args [, traceback]]]",
      "",
      "",
      "以下实例如果 x 大于 5 就触发异常:",
      "",
      "x = 10",
      "if x > 5:",
      "    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))",
      "执行以上代码会触发异常：",
      "",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 3, in <module>",
      "    raise Exception('x 不能大于 5。x 的值为: {}'.format(x))",
      "Exception: x 不能大于 5。x 的值为: 10",
      "raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。",
      "",
      "如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。",
      "",
      ">>> try:",
      "        raise NameError('HiThere')",
      "    except NameError:",
      "        print('An exception flew by!')",
      "        raise",
      "   ",
      "An exception flew by!",
      "Traceback (most recent call last):",
      "  File \"<stdin>\", line 2, in ?",
      "NameError: HiThere"
    ]
  },
  "py-class类定义": {
    "prefix": "py-class类定义",
    "body": [
      "类定义",
      "语法格式如下：",
      "",
      "class ClassName:",
      "    <statement-1>",
      "    .",
      "    .",
      "    .",
      "    <statement-N>",
      "类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。",
      "",
      "类对象",
      "类对象支持两种操作：属性引用和实例化。",
      "",
      "属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。",
      "",
      "类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样:",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "class MyClass:",
      "    \"\"\"一个简单的类实例\"\"\"",
      "    i = 12345",
      "    def f(self):",
      "        return 'hello world'",
      " ",
      "# 实例化类",
      "x = MyClass()",
      " ",
      "# 访问类的属性和方法",
      "print(\"MyClass 类的属性 i 为：\", x.i)",
      "print(\"MyClass 类的方法 f 输出为：\", x.f())",
      "以上创建了一个新的类实例并将该对象赋给局部变量 x，x 为空的对象。",
      "",
      "执行以上程序输出结果为：",
      "",
      "MyClass 类的属性 i 为： 12345",
      "MyClass 类的方法 f 输出为： hello world",
      "类有一个名为 __init__() 的特殊方法（构造方法），该方法在类实例化时会自动调用，像下面这样：",
      "",
      "def __init__(self):",
      "    self.data = []",
      "类定义了 __init__() 方法，类的实例化操作会自动调用 __init__() 方法。如下实例化类 MyClass，对应的 __init__() 方法就会被调用:",
      "",
      "x = MyClass()",
      "当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "class Complex:",
      "    def __init__(self, realpart, imagpart):",
      "        self.r = realpart",
      "        self.i = imagpart",
      "x = Complex(3.0, -4.5)",
      "print(x.r, x.i)   # 输出结果：3.0 -4.5",
      "self代表类的实例，而非类",
      "类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。",
      "",
      "class Test:",
      "    def prt(self):",
      "        print(self)",
      "        print(self.__class__)",
      " ",
      "t = Test()",
      "t.prt()",
      "以上实例执行结果为：",
      "",
      "<__main__.Test instance at 0x100771878>",
      "__main__.Test",
      "从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。",
      "",
      "self 不是 python 关键字，我们把他换成 runoob 也是可以正常执行的:",
      "",
      "class Test:",
      "    def prt(runoob):",
      "        print(runoob)",
      "        print(runoob.__class__)",
      " ",
      "t = Test()",
      "t.prt()",
      "以上实例执行结果为：",
      "",
      "<__main__.Test instance at 0x100771878>",
      "__main__.Test"
    ]
  },
  "py-class类的方法": {
    "prefix": "py-class类的方法",
    "body": [
      "在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self, 且为第一个参数，self 代表的是类的实例。",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#类定义",
      "class people:",
      "    #定义基本属性",
      "    name = ''",
      "    age = 0",
      "    #定义私有属性,私有属性在类外部无法直接进行访问",
      "    __weight = 0",
      "    #定义构造方法",
      "    def __init__(self,n,a,w):",
      "        self.name = n",
      "        self.age = a",
      "        self.__weight = w",
      "    def speak(self):",
      "        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))",
      " ",
      "# 实例化类",
      "p = people('runoob',10,30)",
      "p.speak()",
      "执行以上程序输出结果为：",
      "",
      "runoob 说: 我 10 岁。"
    ]
  },
  "py-class继承": {
    "prefix": "py-class继承",
    "body": [
      "Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示:",
      "",
      "class DerivedClassName(BaseClassName1):",
      "    <statement-1>",
      "    .",
      "    .",
      "    .",
      "    <statement-N>",
      "BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用:",
      "",
      "class DerivedClassName(modname.BaseClassName):",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#类定义",
      "class people:",
      "    #定义基本属性",
      "    name = ''",
      "    age = 0",
      "    #定义私有属性,私有属性在类外部无法直接进行访问",
      "    __weight = 0",
      "    #定义构造方法",
      "    def __init__(self,n,a,w):",
      "        self.name = n",
      "        self.age = a",
      "        self.__weight = w",
      "    def speak(self):",
      "        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))",
      " ",
      "#单继承示例",
      "class student(people):",
      "    grade = ''",
      "    def __init__(self,n,a,w,g):",
      "        #调用父类的构函",
      "        people.__init__(self,n,a,w)",
      "        self.grade = g",
      "    #覆写父类的方法",
      "    def speak(self):",
      "        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))",
      " ",
      " ",
      " ",
      "s = student('ken',10,60,3)",
      "s.speak()",
      "执行以上程序输出结果为：",
      "",
      "ken 说: 我 10 岁了，我在读 3 年级"
    ]
  },
  "py-class多继承": {
    "prefix": "py-class多继承",
    "body": [
      "Python同样有限的支持多继承形式。多继承的类定义形如下例:",
      "",
      "class DerivedClassName(Base1, Base2, Base3):",
      "    <statement-1>",
      "    .",
      "    .",
      "    .",
      "    <statement-N>",
      "需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "#类定义",
      "class people:",
      "    #定义基本属性",
      "    name = ''",
      "    age = 0",
      "    #定义私有属性,私有属性在类外部无法直接进行访问",
      "    __weight = 0",
      "    #定义构造方法",
      "    def __init__(self,n,a,w):",
      "        self.name = n",
      "        self.age = a",
      "        self.__weight = w",
      "    def speak(self):",
      "        print(\"%s 说: 我 %d 岁。\" %(self.name,self.age))",
      " ",
      "#单继承示例",
      "class student(people):",
      "    grade = ''",
      "    def __init__(self,n,a,w,g):",
      "        #调用父类的构函",
      "        people.__init__(self,n,a,w)",
      "        self.grade = g",
      "    #覆写父类的方法",
      "    def speak(self):",
      "        print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade))",
      " ",
      "#另一个类，多重继承之前的准备",
      "class speaker():",
      "    topic = ''",
      "    name = ''",
      "    def __init__(self,n,t):",
      "        self.name = n",
      "        self.topic = t",
      "    def speak(self):",
      "        print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic))",
      " ",
      "#多重继承",
      "class sample(speaker,student):",
      "    a =''",
      "    def __init__(self,n,a,w,g,t):",
      "        student.__init__(self,n,a,w,g)",
      "        speaker.__init__(self,n,t)",
      " ",
      "test = sample(\"Tim\",25,80,4,\"Python\")",
      "test.speak()   #方法名同，默认调用的是在括号中排前地父类的方法",
      "执行以上程序输出结果为：",
      "",
      "我叫 Tim，我是一个演说家，我演讲的主题是 Python"
    ]
  },
  "py-class方法重写": {
    "prefix": "py-class方法重写",
    "body": [
      "如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "class Parent:        # 定义父类",
      "   def myMethod(self):",
      "      print ('调用父类方法')",
      " ",
      "class Child(Parent): # 定义子类",
      "   def myMethod(self):",
      "      print ('调用子类方法')",
      " ",
      "c = Child()          # 子类实例",
      "c.myMethod()         # 子类调用重写方法",
      "super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法",
      "super() 函数是用于调用父类(超类)的一个方法。",
      "",
      "执行以上程序输出结果为：",
      "",
      "调用子类方法",
      "调用父类方法"
    ]
  },
  "py-class类属性与方法": {
    "prefix": "py-class类属性与方法",
    "body": [
      "类的私有属性",
      "__private_attrs：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 self.__private_attrs。",
      "",
      "类的方法",
      "在类的内部，使用 def 关键字来定义一个方法，与一般函数定义不同，类方法必须包含参数 self，且为第一个参数，self 代表的是类的实例。",
      "",
      "self 的名字并不是规定死的，也可以使用 this，但是最好还是按照约定是用 self。",
      "",
      "类的私有方法",
      "__private_method：两个下划线开头，声明该方法为私有方法，只能在类的内部调用 ，不能在类的外部调用。self.__private_methods。",
      "",
      "实例",
      "类的私有属性实例如下：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "class JustCounter:",
      "    __secretCount = 0  # 私有变量",
      "    publicCount = 0    # 公开变量",
      " ",
      "    def count(self):",
      "        self.__secretCount += 1",
      "        self.publicCount += 1",
      "        print (self.__secretCount)",
      " ",
      "counter = JustCounter()",
      "counter.count()",
      "counter.count()",
      "print (counter.publicCount)",
      "print (counter.__secretCount)  # 报错，实例不能访问私有变量",
      "执行以上程序输出结果为：",
      "",
      "1",
      "2",
      "2",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 16, in <module>",
      "    print (counter.__secretCount)  # 报错，实例不能访问私有变量",
      "AttributeError: 'JustCounter' object has no attribute '__secretCount'",
      "类的私有方法实例如下：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "class Site:",
      "    def __init__(self, name, url):",
      "        self.name = name       # public",
      "        self.__url = url   # private",
      " ",
      "    def who(self):",
      "        print('name  : ', self.name)",
      "        print('url : ', self.__url)",
      " ",
      "    def __foo(self):          # 私有方法",
      "        print('这是私有方法')",
      " ",
      "    def foo(self):            # 公共方法",
      "        print('这是公共方法')",
      "        self.__foo()",
      " ",
      "x = Site('菜鸟教程', 'www.runoob.com')",
      "x.who()        # 正常输出",
      "x.foo()        # 正常输出",
      "x.__foo()      # 报错"
    ]
  },
  "py-全局变量和局部变量": {
    "prefix": "py-全局变量和局部变量",
    "body": [
      "定义在函数内部的变量拥有一个局部作用域，定义在函数外的拥有全局作用域。",
      "",
      "局部变量只能在其被声明的函数内部访问，而全局变量可以在整个程序范围内访问。调用函数时，所有在函数内声明的变量名称都将被加入到作用域中。如下实例：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "total = 0 # 这是一个全局变量",
      "# 可写函数说明",
      "def sum( arg1, arg2 ):",
      "    #返回2个参数的和.\"",
      "    total = arg1 + arg2 # total在这里是局部变量.",
      "    print (\"函数内是局部变量 : \", total)",
      "    return total",
      " ",
      "#调用sum函数",
      "sum( 10, 20 )",
      "print (\"函数外是全局变量 : \", total)",
      "以上实例输出结果：",
      "",
      "函数内是局部变量 :  30",
      "函数外是全局变量 :  0",
      "global 和 nonlocal关键字",
      "当内部作用域想修改外部作用域的变量时，就要用到global和nonlocal关键字了。",
      "",
      "以下实例修改全局变量 num：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "num = 1",
      "def fun1():",
      "    global num  # 需要使用 global 关键字声明",
      "    print(num) ",
      "    num = 123",
      "    print(num)",
      "fun1()",
      "print(num)",
      "以上实例输出结果：",
      "",
      "1",
      "123",
      "123",
      "如果要修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量则需要 nonlocal 关键字了，如下实例：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "def outer():",
      "    num = 10",
      "    def inner():",
      "        nonlocal num   # nonlocal关键字声明",
      "        num = 100",
      "        print(num)",
      "    inner()",
      "    print(num)",
      "outer()",
      "以上实例输出结果：",
      "",
      "100",
      "100",
      "另外有一种特殊情况，假设下面这段代码被运行：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 10",
      "def test():",
      "    a = a + 1",
      "    print(a)",
      "test()",
      "以上程序执行，报错信息如下：",
      "",
      "Traceback (most recent call last):",
      "  File \"test.py\", line 7, in <module>",
      "    test()",
      "  File \"test.py\", line 5, in test",
      "    a = a + 1",
      "UnboundLocalError: local variable 'a' referenced before assignment",
      "错误信息为局部作用域引用错误，因为 test 函数中的 a 使用的是局部，未定义，无法修改。",
      "",
      "修改 a 为全局变量，通过函数参数传递，可以正常执行输出结果为：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "a = 10",
      "def test(a):",
      "    a = a + 1",
      "    print(a)",
      "test(a)",
      "执行输出结果为：",
      "",
      "11"
    ]
  },
  "py-标准库": {
    "prefix": "py-标准库",
    "body": [
      "操作系统接口",
      "os模块提供了不少与操作系统相关联的函数。",
      "",
      ">>> import os",
      ">>> os.getcwd()      # 返回当前的工作目录",
      "'C:\\Python34'",
      ">>> os.chdir('/server/accesslogs')   # 修改当前的工作目录",
      ">>> os.system('mkdir today')   # 执行系统命令 mkdir ",
      "0",
      "建议使用 \"import os\" 风格而非 \"from os import *\"。这样可以保证随操作系统不同而有所变化的 os.open() 不会覆盖内置函数 open()。",
      "",
      "在使用 os 这样的大型模块时内置的 dir() 和 help() 函数非常有用:",
      "",
      ">>> import os",
      ">>> dir(os)",
      "<returns a list of all module functions>",
      ">>> help(os)",
      "<returns an extensive manual page created from the module's docstrings>",
      "针对日常的文件和目录管理任务，:mod:shutil 模块提供了一个易于使用的高级接口:",
      "",
      ">>> import shutil",
      ">>> shutil.copyfile('data.db', 'archive.db')",
      ">>> shutil.move('/build/executables', 'installdir')",
      "文件通配符",
      "glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:",
      "",
      ">>> import glob",
      ">>> glob.glob('*.py')",
      "['primes.py', 'random.py', 'quote.py']",
      "命令行参数",
      "通用工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量。例如在命令行中执行 \"python demo.py one two three\" 后可以得到以下输出结果:",
      "",
      ">>> import sys",
      ">>> print(sys.argv)",
      "['demo.py', 'one', 'two', 'three']",
      "错误输出重定向和程序终止",
      "sys 还有 stdin，stdout 和 stderr 属性，即使在 stdout 被重定向时，后者也可以用于显示警告和错误信息。",
      "",
      ">>> sys.stderr.write('Warning, log file not found starting a new one\n')",
      "Warning, log file not found starting a new one",
      "大多脚本的定向终止都使用 \"sys.exit()\"。",
      "",
      "字符串正则匹配",
      "re模块为高级字符串处理提供了正则表达式工具。对于复杂的匹配和处理，正则表达式提供了简洁、优化的解决方案:",
      "",
      ">>> import re",
      ">>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')",
      "['foot', 'fell', 'fastest']",
      ">>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')",
      "'cat in the hat'",
      "如果只需要简单的功能，应该首先考虑字符串方法，因为它们非常简单，易于阅读和调试:",
      "",
      ">>> 'tea for too'.replace('too', 'two')",
      "'tea for two'",
      "数学",
      "math模块为浮点运算提供了对底层C函数库的访问:",
      "",
      ">>> import math",
      ">>> math.cos(math.pi / 4)",
      "0.70710678118654757",
      ">>> math.log(1024, 2)",
      "10.0",
      "random提供了生成随机数的工具。",
      "",
      ">>> import random",
      ">>> random.choice(['apple', 'pear', 'banana'])",
      "'apple'",
      ">>> random.sample(range(100), 10)   # sampling without replacement",
      "[30, 83, 16, 4, 8, 81, 41, 50, 18, 33]",
      ">>> random.random()    # random float",
      "0.17970987693706186",
      ">>> random.randrange(6)    # random integer chosen from range(6)",
      "4",
      "访问 互联网",
      "有几个模块用于访问互联网以及处理网络通信协议。其中最简单的两个是用于处理从 urls 接收的数据的 urllib.request 以及用于发送电子邮件的 smtplib:",
      "",
      ">>> from urllib.request import urlopen",
      ">>> for line in urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):",
      "...     line = line.decode('utf-8')  # Decoding the binary data to text.",
      "...     if 'EST' in line or 'EDT' in line:  # look for Eastern Time",
      "...         print(line)",
      "",
      "<BR>Nov. 25, 09:43:32 PM EST",
      "",
      ">>> import smtplib",
      ">>> server = smtplib.SMTP('localhost')",
      ">>> server.sendmail('soothsayer@example.org', 'jcaesar@example.org',",
      "... \"\"\"To: jcaesar@example.org",
      "... From: soothsayer@example.org",
      "...",
      "... Beware the Ides of March.",
      "... \"\"\")",
      ">>> server.quit()",
      "注意第二个例子需要本地有一个在运行的邮件服务器。",
      "",
      "日期和时间",
      "datetime模块为日期和时间处理同时提供了简单和复杂的方法。",
      "",
      "支持日期和时间算法的同时，实现的重点放在更有效的处理和格式化输出。",
      "",
      "该模块还支持时区处理:",
      "",
      ">>> # dates are easily constructed and formatted",
      ">>> from datetime import date",
      ">>> now = date.today()",
      ">>> now",
      "datetime.date(2003, 12, 2)",
      ">>> now.strftime(\"%m-%d-%y. %d %b %Y is a %A on the %d day of %B.\")",
      "'12-02-03. 02 Dec 2003 is a Tuesday on the 02 day of December.'",
      "",
      ">>> # dates support calendar arithmetic",
      ">>> birthday = date(1964, 7, 31)",
      ">>> age = now - birthday",
      ">>> age.days",
      "14368",
      "数据压缩",
      "以下模块直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile。",
      "",
      ">>> import zlib",
      ">>> s = b'witch which has which witches wrist watch'",
      ">>> len(s)",
      "41",
      ">>> t = zlib.compress(s)",
      ">>> len(t)",
      "37",
      ">>> zlib.decompress(t)",
      "b'witch which has which witches wrist watch'",
      ">>> zlib.crc32(s)",
      "226805979",
      "性能度量",
      "有些用户对了解解决同一问题的不同方法之间的性能差异很感兴趣。Python 提供了一个度量工具，为这些问题提供了直接答案。",
      "",
      "例如，使用元组封装和拆封来交换元素看起来要比使用传统的方法要诱人的多,timeit 证明了现代的方法更快一些。",
      "",
      ">>> from timeit import Timer",
      ">>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()",
      "0.57535828626024577",
      ">>> Timer('a,b = b,a', 'a=1; b=2').timeit()",
      "0.54962537085770791",
      "相对于 timeit 的细粒度，:mod:profile 和 pstats 模块提供了针对更大代码块的时间度量工具。"
    ]
  },
  "py-Socket": {
    "prefix": "py-Socket",
    "body": [
      "Python 提供了两个级别访问的网络服务。：",
      "",
      "低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。",
      "高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。",
      "什么是 Socket?",
      "Socket又称\"套接字\"，应用程序通常通过\"套接字\"向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。",
      "",
      "socket()函数",
      "Python 中，我们用 socket() 函数来创建套接字，语法格式如下：",
      "",
      "socket.socket([family[, type[, proto]]])",
      "参数",
      "family: 套接字家族可以是 AF_UNIX 或者 AF_INET",
      "type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM",
      "protocol: 一般不填默认为0.",
      "简单实例",
      "服务端",
      "我们使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。",
      "",
      "现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 port(端口)。",
      "",
      "接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端。",
      "",
      "完整代码如下：",
      "",
      "#!/usr/bin/python3",
      "# 文件名：server.py",
      "",
      "# 导入 socket、sys 模块",
      "import socket",
      "import sys",
      "",
      "# 创建 socket 对象",
      "serversocket = socket.socket(",
      "            socket.AF_INET, socket.SOCK_STREAM) ",
      "",
      "# 获取本地主机名",
      "host = socket.gethostname()",
      "",
      "port = 9999",
      "",
      "# 绑定端口号",
      "serversocket.bind((host, port))",
      "",
      "# 设置最大连接数，超过后排队",
      "serversocket.listen(5)",
      "",
      "while True:",
      "    # 建立客户端连接",
      "    clientsocket,addr = serversocket.accept()      ",
      "",
      "    print(\"连接地址: %s\" % str(addr))",
      "    ",
      "    msg='欢迎访问菜鸟教程！'+ \"\r\n\"",
      "    clientsocket.send(msg.encode('utf-8'))",
      "    clientsocket.close()",
      "客户端",
      "接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 9999。",
      "",
      "socket.connect(hosname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。",
      "",
      "完整代码如下：",
      "",
      "#!/usr/bin/python3",
      "# 文件名：client.py",
      "",
      "# 导入 socket、sys 模块",
      "import socket",
      "import sys",
      "",
      "# 创建 socket 对象",
      "s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) ",
      "",
      "# 获取本地主机名",
      "host = socket.gethostname() ",
      "",
      "# 设置端口号",
      "port = 9999",
      "",
      "# 连接服务，指定主机和端口",
      "s.connect((host, port))",
      "",
      "# 接收小于 1024 字节的数据",
      "msg = s.recv(1024)",
      "",
      "s.close()",
      "",
      "print (msg.decode('utf-8'))",
      "现在我们打开两个终端，第一个终端执行 server.py 文件：",
      "",
      "$ python3 server.py",
      "第二个终端执行 client.py 文件：",
      "",
      "$ python3 client.py ",
      "欢迎访问菜鸟教程！",
      "这时我们再打开第一个终端，就会看到有以下信息输出：",
      "",
      "连接地址： ('192.168.0.118', 33397)"
    ]
  },
  "py-Python线程": {
    "prefix": "py-Python线程",
    "body": [
      "开始学习Python线程",
      "Python中使用线程有两种方式：函数或者用类来包装线程对象。",
      "",
      "函数式：调用 _thread 模块中的start_new_thread()函数来产生新线程。语法如下:",
      "",
      "_thread.start_new_thread ( function, args[, kwargs] )",
      "参数说明:",
      "",
      "function - 线程函数。",
      "args - 传递给线程函数的参数,他必须是个tuple类型。",
      "kwargs - 可选参数。",
      "实例",
      "#!/usr/bin/python3",
      "",
      "import _thread",
      "import time",
      "",
      "# 为线程定义一个函数",
      "def print_time( threadName, delay):",
      "   count = 0",
      "   while count < 5:",
      "      time.sleep(delay)",
      "      count += 1",
      "      print (\"%s: %s\" % ( threadName, time.ctime(time.time()) ))",
      "",
      "# 创建两个线程",
      "try:",
      "   _thread.start_new_thread( print_time, (\"Thread-1\", 2, ) )",
      "   _thread.start_new_thread( print_time, (\"Thread-2\", 4, ) )",
      "except:",
      "   print (\"Error: 无法启动线程\")",
      "",
      "while 1:",
      "   pass",
      "执行以上程序输出结果如下：",
      "",
      "Thread-1: Wed Apr  6 11:36:31 2016",
      "Thread-1: Wed Apr  6 11:36:33 2016",
      "Thread-2: Wed Apr  6 11:36:33 2016",
      "Thread-1: Wed Apr  6 11:36:35 2016",
      "Thread-1: Wed Apr  6 11:36:37 2016",
      "Thread-2: Wed Apr  6 11:36:37 2016",
      "Thread-1: Wed Apr  6 11:36:39 2016",
      "Thread-2: Wed Apr  6 11:36:41 2016",
      "Thread-2: Wed Apr  6 11:36:45 2016",
      "Thread-2: Wed Apr  6 11:36:49 2016",
      "执行以上程后可以按下 ctrl-c to 退出。"
    ]
  },
  "py-线程模块": {
    "prefix": "py-线程模块",
    "body": [
      "Python3 通过两个标准库 _thread 和 threading 提供对线程的支持。",
      "",
      "_thread 提供了低级别的、原始的线程以及一个简单的锁，它相比于 threading 模块的功能还是比较有限的。",
      "",
      "threading 模块除了包含 _thread 模块中的所有方法外，还提供的其他方法：",
      "",
      "threading.currentThread(): 返回当前的线程变量。",
      "threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。",
      "threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。",
      "除了使用方法外，线程模块同样提供了Thread类来处理线程，Thread类提供了以下方法:",
      "",
      "run(): 用以表示线程活动的方法。",
      "start():启动线程活动。",
      "join([time]): 等待至线程中止。这阻塞调用线程直至线程的join() 方法被调用中止-正常退出或者抛出未处理的异常-或者是可选的超时发生。",
      "isAlive(): 返回线程是否活动的。",
      "getName(): 返回线程名。",
      "setName(): 设置线程名。"
    ]
  },
  "py-threading 模块创建线程": {
    "prefix": "py-threading 模块创建线程",
    "body": [
      "使用 threading 模块创建线程",
      "我们可以通过直接从 threading.Thread 继承创建一个新的子类，并实例化后调用 start() 方法启动新线程，即它调用了线程的 run() 方法：",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "import threading",
      "import time",
      "",
      "exitFlag = 0",
      "",
      "class myThread (threading.Thread):",
      "    def __init__(self, threadID, name, counter):",
      "        threading.Thread.__init__(self)",
      "        self.threadID = threadID",
      "        self.name = name",
      "        self.counter = counter",
      "    def run(self):",
      "        print (\"开始线程：\" + self.name)",
      "        print_time(self.name, self.counter, 5)",
      "        print (\"退出线程：\" + self.name)",
      "",
      "def print_time(threadName, delay, counter):",
      "    while counter:",
      "        if exitFlag:",
      "            threadName.exit()",
      "        time.sleep(delay)",
      "        print (\"%s: %s\" % (threadName, time.ctime(time.time())))",
      "        counter -= 1",
      "",
      "# 创建新线程",
      "thread1 = myThread(1, \"Thread-1\", 1)",
      "thread2 = myThread(2, \"Thread-2\", 2)",
      "",
      "# 开启新线程",
      "thread1.start()",
      "thread2.start()",
      "thread1.join()",
      "thread2.join()",
      "print (\"退出主线程\")",
      "以上程序执行结果如下；",
      "",
      "开始线程：Thread-1",
      "开始线程：Thread-2",
      "Thread-1: Wed Apr  6 11:46:46 2016",
      "Thread-1: Wed Apr  6 11:46:47 2016",
      "Thread-2: Wed Apr  6 11:46:47 2016",
      "Thread-1: Wed Apr  6 11:46:48 2016",
      "Thread-1: Wed Apr  6 11:46:49 2016",
      "Thread-2: Wed Apr  6 11:46:49 2016",
      "Thread-1: Wed Apr  6 11:46:50 2016",
      "退出线程：Thread-1",
      "Thread-2: Wed Apr  6 11:46:51 2016",
      "Thread-2: Wed Apr  6 11:46:53 2016",
      "Thread-2: Wed Apr  6 11:46:55 2016",
      "退出线程：Thread-2",
      "退出主线程"
    ]
  },
  "py-线程同步": {
    "prefix": "py-线程同步",
    "body": [
      "#!/usr/bin/python3",
      "",
      "import threading",
      "import time",
      "",
      "class myThread (threading.Thread):",
      "    def __init__(self, threadID, name, counter):",
      "        threading.Thread.__init__(self)",
      "        self.threadID = threadID",
      "        self.name = name",
      "        self.counter = counter",
      "    def run(self):",
      "        print (\"开启线程： \" + self.name)",
      "        # 获取锁，用于线程同步",
      "        threadLock.acquire()",
      "        print_time(self.name, self.counter, 3)",
      "        # 释放锁，开启下一个线程",
      "        threadLock.release()",
      "",
      "def print_time(threadName, delay, counter):",
      "    while counter:",
      "        time.sleep(delay)",
      "        print (\"%s: %s\" % (threadName, time.ctime(time.time())))",
      "        counter -= 1",
      "",
      "threadLock = threading.Lock()",
      "threads = []",
      "",
      "# 创建新线程",
      "thread1 = myThread(1, \"Thread-1\", 1)",
      "thread2 = myThread(2, \"Thread-2\", 2)",
      "",
      "# 开启新线程",
      "thread1.start()",
      "thread2.start()",
      "",
      "# 添加线程到线程列表",
      "threads.append(thread1)",
      "threads.append(thread2)",
      "",
      "# 等待所有线程完成",
      "for t in threads:",
      "    t.join()",
      "print (\"退出主线程\")",
      "执行以上程序，输出结果为：",
      "",
      "开启线程： Thread-1",
      "开启线程： Thread-2",
      "Thread-1: Wed Apr  6 11:52:57 2016",
      "Thread-1: Wed Apr  6 11:52:58 2016",
      "Thread-1: Wed Apr  6 11:52:59 2016",
      "Thread-2: Wed Apr  6 11:53:01 2016",
      "Thread-2: Wed Apr  6 11:53:03 2016",
      "Thread-2: Wed Apr  6 11:53:05 2016",
      "退出主线程"
    ]
  },
  "py-线程优先级队列（ Queue）": {
    "prefix": "py-线程优先级队列（ Queue）",
    "body": [
      "Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列 PriorityQueue。",
      "",
      "这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。",
      "",
      "Queue 模块中的常用方法:",
      "",
      "Queue.qsize() 返回队列的大小",
      "Queue.empty() 如果队列为空，返回True,反之False",
      "Queue.full() 如果队列满了，返回True,反之False",
      "Queue.full 与 maxsize 大小对应",
      "Queue.get([block[, timeout]])获取队列，timeout等待时间",
      "Queue.get_nowait() 相当Queue.get(False)",
      "Queue.put(item) 写入队列，timeout等待时间",
      "Queue.put_nowait(item) 相当Queue.put(item, False)",
      "Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号",
      "Queue.join() 实际上意味着等到队列为空，再执行别的操作",
      "实例",
      "#!/usr/bin/python3",
      "",
      "import queue",
      "import threading",
      "import time",
      "",
      "exitFlag = 0",
      "",
      "class myThread (threading.Thread):",
      "    def __init__(self, threadID, name, q):",
      "        threading.Thread.__init__(self)",
      "        self.threadID = threadID",
      "        self.name = name",
      "        self.q = q",
      "    def run(self):",
      "        print (\"开启线程：\" + self.name)",
      "        process_data(self.name, self.q)",
      "        print (\"退出线程：\" + self.name)",
      "",
      "def process_data(threadName, q):",
      "    while not exitFlag:",
      "        queueLock.acquire()",
      "        if not workQueue.empty():",
      "            data = q.get()",
      "            queueLock.release()",
      "            print (\"%s processing %s\" % (threadName, data))",
      "        else:",
      "            queueLock.release()",
      "        time.sleep(1)",
      "",
      "threadList = [\"Thread-1\", \"Thread-2\", \"Thread-3\"]",
      "nameList = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\"]",
      "queueLock = threading.Lock()",
      "workQueue = queue.Queue(10)",
      "threads = []",
      "threadID = 1",
      "",
      "# 创建新线程",
      "for tName in threadList:",
      "    thread = myThread(threadID, tName, workQueue)",
      "    thread.start()",
      "    threads.append(thread)",
      "    threadID += 1",
      "",
      "# 填充队列",
      "queueLock.acquire()",
      "for word in nameList:",
      "    workQueue.put(word)",
      "queueLock.release()",
      "",
      "# 等待队列清空",
      "while not workQueue.empty():",
      "    pass",
      "",
      "# 通知线程是时候退出",
      "exitFlag = 1",
      "",
      "# 等待所有线程完成",
      "for t in threads:",
      "    t.join()",
      "print (\"退出主线程\")",
      "以上程序执行结果：",
      "",
      "开启线程：Thread-1",
      "开启线程：Thread-2",
      "开启线程：Thread-3",
      "Thread-3 processing One",
      "Thread-1 processing Two",
      "Thread-2 processing Three",
      "Thread-3 processing Four",
      "Thread-1 processing Five",
      "退出线程：Thread-3",
      "退出线程：Thread-2",
      "退出线程：Thread-1",
      "退出主线程"
    ]
  },
  "py-JSON": {
    "prefix": "py-JSON",
    "body": [
      "JSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。",
      "",
      "Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数：",
      "",
      "json.dumps(): 对数据进行编码。",
      "json.loads(): 对数据进行解码。",
      "在json的编解码过程中，python 的原始类型与json类型会相互转换，具体的转化对照如下：",
      "json.dumps 与 json.loads 实例",
      "以下实例演示了 Python 数据结构转换为JSON：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "import json",
      " ",
      "# Python 字典类型转换为 JSON 对象",
      "data = {",
      "    'no' : 1,",
      "    'name' : 'Runoob',",
      "    'url' : 'http://www.runoob.com'",
      "}",
      " ",
      "json_str = json.dumps(data)",
      "print (\"Python 原始数据：\", repr(data))",
      "print (\"JSON 对象：\", json_str)",
      "执行以上代码输出结果为：",
      "",
      "Python 原始数据： {'url': 'http://www.runoob.com', 'no': 1, 'name': 'Runoob'}",
      "JSON 对象： {\"url\": \"http://www.runoob.com\", \"no\": 1, \"name\": \"Runoob\"}",
      "通过输出的结果可以看出，简单类型通过编码后跟其原始的repr()输出结果非常相似。",
      "",
      "接着以上实例，我们可以将一个JSON编码的字符串转换回一个Python数据结构：",
      "",
      "实例(Python 3.0+)",
      "#!/usr/bin/python3",
      " ",
      "import json",
      " ",
      "# Python 字典类型转换为 JSON 对象",
      "data1 = {",
      "    'no' : 1,",
      "    'name' : 'Runoob',",
      "    'url' : 'http://www.runoob.com'",
      "}",
      " ",
      "json_str = json.dumps(data1)",
      "print (\"Python 原始数据：\", repr(data1))",
      "print (\"JSON 对象：\", json_str)",
      " ",
      "# 将 JSON 对象转换为 Python 字典",
      "data2 = json.loads(json_str)",
      "print (\"data2['name']: \", data2['name'])",
      "print (\"data2['url']: \", data2['url'])",
      "执行以上代码输出结果为：",
      "",
      "Python 原始数据： {'name': 'Runoob', 'no': 1, 'url': 'http://www.runoob.com'}",
      "JSON 对象： {\"name\": \"Runoob\", \"no\": 1, \"url\": \"http://www.runoob.com\"}",
      "data2['name']:  Runoob",
      "data2['url']:  http://www.runoob.com",
      "如果你要处理的是文件而不是字符串，你可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。例如：",
      "",
      "实例(Python 3.0+)",
      "# 写入 JSON 数据",
      "with open('data.json', 'w') as f:",
      "    json.dump(data, f)",
      " ",
      "# 读取数据",
      "with open('data.json', 'r') as f:",
      "    data = json.load(f)"
    ]
  },
  "py-日期和时间": {
    "prefix": "py-日期和时间",
    "body": [
      "Python 程序能用很多方式处理日期和时间，转换日期格式是一个常见的功能。",
      "",
      "Python 提供了一个 time 和 calendar 模块可以用于格式化日期和时间。",
      "",
      "时间间隔是以秒为单位的浮点小数。",
      "",
      "每个时间戳都以自从 1970 年 1 月 1 日午夜（历元）经过了多长时间来表示。",
      "",
      "Python 的 time 模块下有很多函数可以转换常见日期格式。如函数 time.time() 用于获取当前时间戳, 如下实例:",
      "",
      "实例",
      "#!/usr/bin/python3",
      "",
      "import time  # 引入time模块",
      "",
      "ticks = time.time()",
      "print (\"当前时间戳为:\", ticks)",
      "以上实例输出结果：",
      "",
      "当前时间戳为: 1459996086.7115328",
      "时间戳单位最适于做日期运算。但是1970年之前的日期就无法以此表示了。太遥远的日期也不行，UNIX和Windows只支持到2038年。",
      "",
      "",
      "什么是时间元组？",
      "很多Python函数用一个元组装起来的9组数字处理时间:",
      "",
      "获取当前时间",
      "从返回浮点数的时间戳方式向时间元组转换，只要将浮点数传递给如localtime之类的函数。",
      "",
      "#!/usr/bin/python3",
      "",
      "import time",
      "",
      "localtime = time.localtime(time.time())",
      "print (\"本地时间为 :\", localtime)",
      "以上实例输出结果：",
      "",
      "本地时间为 : time.struct_time(tm_year=2016, tm_mon=4, tm_mday=7, tm_hour=10, tm_min=28, tm_sec=49, tm_wday=3, tm_yday=98, tm_isdst=0)",
      "获取格式化的时间",
      "你可以根据需求选取各种格式，但是最简单的获取可读的时间模式的函数是asctime():",
      "",
      "#!/usr/bin/python3",
      "",
      "import time",
      "",
      "localtime = time.asctime( time.localtime(time.time()) )",
      "print (\"本地时间为 :\", localtime)",
      "以上实例输出结果：",
      "",
      "本地时间为 : Thu Apr  7 10:29:13 2016",
      "格式化日期",
      "我们可以使用 time 模块的 strftime 方法来格式化日期，：",
      "",
      "time.strftime(format[, t])",
      "#!/usr/bin/python3",
      "",
      "import time",
      "",
      "# 格式化成2016-03-20 11:45:39形式",
      "print (time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()))",
      "",
      "# 格式化成Sat Mar 28 22:24:24 2016形式",
      "print (time.strftime(\"%a %b %d %H:%M:%S %Y\", time.localtime()))",
      "  ",
      "# 将格式字符串转换为时间戳",
      "a = \"Sat Mar 28 22:24:24 2016\"",
      "print (time.mktime(time.strptime(a,\"%a %b %d %H:%M:%S %Y\")))",
      "以上实例输出结果：",
      "",
      "2016-04-07 10:29:46",
      "Thu Apr 07 10:29:46 2016",
      "1459175064.0",
      "python中时间日期格式化符号：",
      "",
      "%y 两位数的年份表示（00-99）",
      "%Y 四位数的年份表示（000-9999）",
      "%m 月份（01-12）",
      "%d 月内中的一天（0-31）",
      "%H 24小时制小时数（0-23）",
      "%I 12小时制小时数（01-12）",
      "%M 分钟数（00=59）",
      "%S 秒（00-59）",
      "%a 本地简化星期名称",
      "%A 本地完整星期名称",
      "%b 本地简化的月份名称",
      "%B 本地完整的月份名称",
      "%c 本地相应的日期表示和时间表示",
      "%j 年内的一天（001-366）",
      "%p 本地A.M.或P.M.的等价符",
      "%U 一年中的星期数（00-53）星期天为星期的开始",
      "%w 星期（0-6），星期天为星期的开始",
      "%W 一年中的星期数（00-53）星期一为星期的开始",
      "%x 本地相应的日期表示",
      "%X 本地相应的时间表示",
      "%Z 当前时区的名称",
      "%% %号本身",
      "获取某月日历",
      "Calendar模块有很广泛的方法用来处理年历和月历，例如打印某月的月历：",
      "",
      "#!/usr/bin/python3",
      "",
      "import calendar",
      "",
      "cal = calendar.month(2016, 1)",
      "print (\"以下输出2016年1月份的日历:\")",
      "print (cal)",
      "以上实例输出结果：",
      "",
      "以下输出2016年1月份的日历:",
      "    January 2016",
      "Mo Tu We Th Fr Sa Su",
      "             1  2  3",
      " 4  5  6  7  8  9 10",
      "11 12 13 14 15 16 17",
      "18 19 20 21 22 23 24",
      "25 26 27 28 29 30 31",
      "Time 模块",
      "Time 模块包含了以下内置函数，既有时间处理的，也有转换时间格式的：",
      "",
      "序号函数及描述实例",
      "1time.altzone",
      "返回格林威治西部的夏令时地区的偏移秒数。如果该地区在格林威治东部会返回负值（如西欧，包括英国）。对夏令时启用地区才能使用。",
      "以下实例展示了 altzone()函数的使用方法：",
      "",
      ">>> import time",
      ">>> print (\"time.altzone %d \" % time.altzone)",
      "time.altzone -28800 ",
      "2time.asctime([tupletime])",
      "接受时间元组并返回一个可读的形式为\"Tue Dec 11 18:07:14 2008\"（2008年12月11日 周二18时07分14秒）的24个字符的字符串。",
      "以下实例展示了 asctime()函数的使用方法：",
      "",
      ">>> import time",
      ">>> t = time.localtime()",
      ">>> print (\"time.asctime(t): %s \" % time.asctime(t))",
      "time.asctime(t): Thu Apr  7 10:36:20 2016 ",
      "3time.clock()",
      "用以浮点数计算的秒数返回当前的CPU时间。用来衡量不同程序的耗时，比time.time()更有用。",
      "实例",
      "",
      "由于该方法依赖操作系统，在 Python 3.3 以后不被推荐，而在 3.8 版本中被移除，需使用下列两个函数替代。",
      "",
      "time.perf_counter()  # 返回系统运行时间",
      "time.process_time()  # 返回进程运行时间",
      "4time.ctime([secs])",
      "作用相当于asctime(localtime(secs))，未给参数相当于asctime()",
      "以下实例展示了 ctime()函数的使用方法：",
      "",
      ">>> import time",
      ">>> print (\"time.ctime() : %s\" % time.ctime())",
      "time.ctime() : Thu Apr  7 10:51:58 2016",
      "5time.gmtime([secs])",
      "以下实例展示了 gmtime()函数的使用方法：",
      "",
      ">>> import time",
      ">>> print (\"gmtime :\", time.gmtime(1455508609.34375))",
      "gmtime : time.struct_time(tm_year=2016, tm_mon=2, tm_mday=15, tm_hour=3, tm_min=56, tm_sec=49, tm_wday=0, tm_yday=46, tm_isdst=0)",
      "6time.localtime([secs]",
      "接收时间戳（1970纪元后经过的浮点秒数）并返回当地时间下的时间元组t（t.tm_isdst可取0或1，取决于当地当时是不是夏令时）。",
      "以下实例展示了 localtime()函数的使用方法：",
      "",
      ">>> import time",
      ">>> print (\"localtime(): \", time.localtime(1455508609.34375))",
      "localtime():  time.struct_time(tm_year=2016, tm_mon=2, tm_mday=15, tm_hour=11, tm_min=56, tm_sec=49, tm_wday=0, tm_yday=46, tm_isdst=0)",
      "7time.mktime(tupletime)",
      "接受时间元组并返回时间戳（1970纪元后经过的浮点秒数）。实例",
      "8time.sleep(secs)",
      "推迟调用线程的运行，secs指秒数。",
      "以下实例展示了 sleep()函数的使用方法：",
      "",
      "#!/usr/bin/python3",
      "import time",
      "",
      "print (\"Start : %s\" % time.ctime())",
      "time.sleep( 5 )",
      "print (\"End : %s\" % time.ctime())",
      "9time.strftime(fmt[,tupletime])",
      "接收以时间元组，并返回以可读字符串表示的当地时间，格式由fmt决定。",
      "以下实例展示了 strftime()函数的使用方法：",
      "",
      ">>> import time",
      ">>> print (time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()))",
      "2016-04-07 11:18:05",
      "10time.strptime(str,fmt='%a %b %d %H:%M:%S %Y')",
      "根据fmt的格式把一个时间字符串解析为时间元组。",
      "以下实例展示了 strptime()函数的使用方法：",
      "",
      ">>> import time",
      ">>> struct_time = time.strptime(\"30 Nov 00\", \"%d %b %y\")",
      ">>> print (\"返回元组: \", struct_time)",
      "返回元组:  time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0, tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)",
      "11time.time( )",
      "返回当前时间的时间戳（1970纪元后经过的浮点秒数）。",
      "以下实例展示了 time()函数的使用方法：",
      "",
      ">>> import time",
      ">>> print(time.time())",
      "1459999336.1963577",
      "12	time.tzset()",
      "根据环境变量TZ重新初始化时间相关设置。	实例",
      "13	time.perf_counter()",
      "返回计时器的精准时间（系统的运行时间），包含整个系统的睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。	实例",
      "14	time.process_time()",
      "返回当前进程执行 CPU 的时间总和，不包含睡眠时间。由于返回值的基准点是未定义的，所以，只有连续调用的结果之间的差才是有效的。	 ",
      "Time模块包含了以下2个非常重要的属性：",
      "",
      "序号属性及描述",
      "1time.timezone",
      "属性time.timezone是当地时区（未启动夏令时）距离格林威治的偏移秒数（>0，美洲;<=0大部分欧洲，亚洲，非洲）。",
      "2time.tzname",
      "属性time.tzname包含一对根据情况的不同而不同的字符串，分别是带夏令时的本地时区名称，和不带的。",
      "",
      "日历（Calendar）模块",
      "此模块的函数都是日历相关的，例如打印某月的字符月历。",
      "",
      "星期一是默认的每周第一天，星期天是默认的最后一天。更改设置需调用calendar.setfirstweekday()函数。模块包含了以下内置函数：",
      "",
      "序号函数及描述",
      "1calendar.calendar(year,w=2,l=1,c=6)",
      "返回一个多行字符串格式的year年年历，3个月一行，间隔距离为c。 每日宽度间隔为w字符。每行长度为21* W+18+2* C。l是每星期行数。",
      "2calendar.firstweekday( )",
      "返回当前每周起始日期的设置。默认情况下，首次载入caendar模块时返回0，即星期一。",
      "3calendar.isleap(year)",
      "是闰年返回 True，否则为 false。",
      "",
      ">>> import calendar",
      ">>> print(calendar.isleap(2000))",
      "True",
      ">>> print(calendar.isleap(1900))",
      "False",
      "4calendar.leapdays(y1,y2)",
      "返回在Y1，Y2两年之间的闰年总数。",
      "5calendar.month(year,month,w=2,l=1)",
      "返回一个多行字符串格式的year年month月日历，两行标题，一周一行。每日宽度间隔为w字符。每行的长度为7* w+6。l是每星期的行数。",
      "6calendar.monthcalendar(year,month)",
      "返回一个整数的单层嵌套列表。每个子列表装载代表一个星期的整数。Year年month月外的日期都设为0;范围内的日子都由该月第几日表示，从1开始。",
      "7calendar.monthrange(year,month)",
      "返回两个整数。第一个是该月的星期几，第二个是该月有几天。星期几是从0（星期一）到 6（星期日）。",
      "",
      ">>> import calendar",
      ">>> calendar.monthrange(2014, 11)",
      "(5, 30)",
      "(5, 30)解释：5 表示 2014 年 11 月份的第一天是周六，30 表示 2014 年 11 月份总共有 30 天。",
      "",
      "8calendar.prcal(year,w=2,l=1,c=6)",
      "相当于 print calendar.calendar(year,w,l,c).",
      "9calendar.prmonth(year,month,w=2,l=1)",
      "相当于 print calendar.calendar（year，w，l，c）。",
      "10calendar.setfirstweekday(weekday)",
      "设置每周的起始日期码。0（星期一）到6（星期日）。",
      "11calendar.timegm(tupletime)",
      "和time.gmtime相反：接受一个时间元组形式，返回该时刻的时间戳（1970纪元后经过的浮点秒数）。",
      "12calendar.weekday(year,month,day)",
      "返回给定日期的日期码。0（星期一）到6（星期日）。月份为 1（一月） 到 12（12月）。",
      "",
      "其他相关模块和函数",
      "在Python中，其他处理日期和时间的模块还有："
    ]
  },
  "py-根据时间生成文件": {
    "prefix": "py-根据时间生成文件",
    "body": [
      "import os",
      "import datetime",
      "import time",
      "",
      "print(type(os.path))",
      "while True:",
      "    path = input(\"请输入文件保存地址\")",
      "    num = int(input(\"请输入文件数量\"))",
      "    for i in range(num):",
      "        t = datetime.datetime.now()",
      "        file = \"ylc\"+t.strftime('%Y%m%d%H%M%S')+'.txt'",
      "        open(file,'w',encoding='utf-8')",
      "        time.sleep(1)",
      "        print(t)",
      "        pass",
      "os.startfile(path)"
    ]
  },
  "py-ls": {
    "prefix": "py-ls",
    "body": [
      "import os",
      "os.system('ls')"
    ]
  },
  "py-sleep": {
    "prefix": "py-sleep",
    "body": [
      "# 例1：循环输出休眠1秒",
      "import time",
      "i = 1",
      "while i != 3:",
      "  print(i) # 输出i",
      "  i += 1",
      "  time.sleep(1) # 休眠1秒"
    ]
  },
  "py-Django-命令": {
    "prefix": "py-Django-命令",
    "body": [
      "在DJango里django-admin.py和manage.py都是Django的命令工具集，用于处理系统管理相关操作，而manage.py是在创建Django工程时自动生成的，manage.py是对django-admin.py的简单包装，二者的作用基本一致。",
      "",
      "区别：",
      "",
      "1、django-admin存放在Python的site-packages\django\bin 里，manage.py存放在项目工程文件夹里。",
      "",
      "2、django-admin可以对不同的项目进行设置，而manege.py只能当前的工程有效。",
      "",
      "下面我们以manage.py为例，列出一些常用的命令：",
      "",
      "语法：",
      "",
      "django-admin <subcommand> [options]",
      "",
      "manage.py <subcommand> [options]",
      "",
      "subcommand是子命令；options是可选的",
      "",
      "常用子命令：",
      "startproject:创建一个项目（*）",
      "startapp:创建一个app（*）",
      "runserver：运行开发服务器（*）",
      "shell：进入django shell（*）",
      "dbshell：进入django dbshell",
      "check：检查django项目完整性",
      "flush：清空数据库",
      "compilemessages：编译语言文件",
      "makemessages：创建语言文件",
      "makemigrations：生成数据库同步脚本（*）",
      "migrate：同步数据库（*）",
      "showmigrations：查看生成的数据库同步脚本（*）",
      "sqlflush：查看生成清空数据库的脚本（*）",
      "sqlmigrate：查看数据库同步的sql语句（*）",
      "dumpdata:导出数据",
      "loaddata:导入数据",
      "diffsettings:查看你的配置和django默认配置的不同之处",
      "manage.py特有的一些子命令：",
      "createsuperuser:创建超级管理员（*）",
      "changepassword:修改密码（*）",
      "clearsessions：清除session",
      "1、help",
      "",
      "作用：获得帮助信息",
      "",
      "语法：",
      "",
      "#显示帮助信息和可用命令",
      "python manege.py help",
      "#显示可用命令列表",
      "python manege.py help --commands",
      "#显示指定命令的详细文档",
      "python manage.py help  #commands为需要指定显示的命令",
      "2、version",
      "",
      "作用：获取到当前DJango的版本",
      "",
      "语法：",
      "",
      "python manage.py version",
      "3、check",
      "",
      "作用：检查工程中是否存在错误（检查完整性）",
      "",
      "语法：",
      "",
      "python manage.py check [appname]   #命令后面跟APP名称",
      "4、startproject",
      "",
      "作用：创建Django工程",
      "",
      "语法：",
      "",
      "django-admin startproject name [项目想要存放的路径]",
      "5、startapp",
      "",
      "作用：创建Django应用程序",
      "",
      "语法：",
      "",
      "django-admin startapp name [应用想要存放的路径]",
      "python manage.py startapp name",
      "6、runserver",
      "",
      "作用：在当前机器启动一个Web服务器，运行Django项目",
      "",
      "语法：",
      "",
      "#默认是8000端口",
      "python manage.py runserver",
      "#指定IP和端口",
      "python manage.py runserver 127.0.0.1:8000",
      "#指定端口",
      "python manage.py runserver 8000",
      "7、shell",
      "",
      "作用：启动一个交互窗口",
      "",
      "语法：",
      "",
      "python manage.py shell",
      "#如果想使用ipython、bpython交互模式的话需要先安装以上交互工具，安装命令：pip install ipython",
      "#启用命令",
      "python manage.py shell --i [ipyhton]",
      "8、migrations",
      "",
      "Django通过migrations命令将Models中的任何修改写入到数库中，比如：新增加的模型或修改已有的字段等。",
      "",
      "makemigrations",
      "",
      "作用：根据models的变化生成对应的Python代码，该代码用于更新数据库",
      "",
      "语法：",
      "",
      "python manage.py makemigrations",
      "python manage.py makemigrations [appname]",
      "migrate",
      "",
      "作用：将model里的修改应用到数据库",
      "",
      "语法：",
      "",
      "python manage.py migrate #默认是所有的APP的修改应用到数据库",
      "python manage.py migrate [appname] #指定APP的修改应用到数据库",
      "python manage.py migrate [appname] [migrations_name] #将操作恢复到指定版本",
      "注意：",
      "",
      "如果执行migrate的命令同时给了应用程序的名字和migtrations名字，系统会把数据库恢复到之前指定的一个版本。",
      "",
      "python manage.py migrate myblog 0001_initial #指定blog应用恢复到0001_initial 这个版本",
      "Django所有的migration信息都保存在django_migrations这个数据库表中，如下图所示：",
      "",
      "clipboard.png",
      "",
      "如果想撤销所有的数据库更改，我们可以使用 zero代替 上面的命令:",
      "",
      "python manage.py migrate blog zero",
      "高级用法：",
      "",
      "如果数据库里，已经手动更新了数据库，我们只是想设置当前的migration状态，就使用下面的命令去实现，这个命令并不会真正的去更新数据库。",
      "",
      "语法：",
      "",
      "python manage.py migrate blog zero",
      "sqlmigrate",
      "",
      "作用：输出某一个migrate对应的SQL语句",
      "",
      "语法：",
      "",
      "python manage.py sqlmigrate blog 0001_initial",
      "showmigrations",
      "",
      "作用：显示migrations记录",
      "",
      "语法：",
      "",
      "python manage.py showmigrations",
      "clipboard2.png",
      "",
      "留意：记录前有[X]的表示已经部署到数据库里去了，没有的则显示 [ ]",
    ]
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  },
  "py-": {
    "prefix": "py-",
    "body": []
  }
}