{
  // Place your snippets for vue here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  "vu-导入": {
    "prefix": "vu-导入",
    "body": [
      "尝试 Vue.js 最简单的方法是使用 Hello World 例子。你可以在浏览器新标签页中打开它，跟着例子学习一些基础用法。或者你也可以创建一个 .html 文件，然后通过如下方式引入 Vue：",
      "",
      "<!-- 开发环境版本，包含了有帮助的命令行警告 -->",
      "<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"></script>",
      "或者：",
      "",
      "<!-- 生产环境版本，优化了尺寸和速度 -->",
      "<script src=\"https://cdn.jsdelivr.net/npm/vue\"></script>"
    ]
  },
  "vu-Vue.js 安装": {
    "prefix": "vu-Vue.js 安装",
    "body": [
      "1、独立版本",
      "我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 <script> 标签引入。",
      "",
      "下载 Vue.js",
      "",
      "2、使用 CDN 方法",
      "以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。",
      "",
      "Staticfile CDN（国内） : https://cdn.staticfile.org/vue/2.2.2/vue.min.js",
      "",
      "unpkg：https://unpkg.com/vue/dist/vue.js, 会保持和 npm 发布的最新的版本一致。",
      "",
      "cdnjs : https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js",
      "",
      "Staticfile CDN（国内）",
      "<div id=\"app\">",
      "  <p>{{ message }}</p>",
      "</div>",
      "",
      "尝试一下 »",
      "unpkg（推荐）",
      "<div id=\"app\">",
      "  <p>{{ message }}</p>",
      "</div>",
      "",
      "尝试一下 »",
      "cdnjs",
      "<div id=\"app\">",
      "  <p>{{ message }}</p>",
      "</div>",
      "",
      "尝试一下 »",
      "3、NPM 方法",
      "由于 npm 安装速度慢，本教程使用了淘宝的镜像及其命令 cnpm，安装使用介绍参照：使用淘宝 NPM 镜像。",
      "",
      "npm 版本需要大于 3.0，如果低于此版本需要升级它：",
      "",
      "# 查看版本",
      "$ npm -v",
      "2.3.0",
      "",
      "#升级 npm",
      "cnpm install npm -g",
      "",
      "",
      "# 升级或安装 cnpm",
      "npm install cnpm -g",
      "在用 Vue.js 构建大型应用时推荐使用 NPM 安装：",
      "",
      "# 最新稳定版",
      "$ cnpm install vue"
    ]
  },
  "vu-命令行工具": {
    "prefix": "vu-命令行工具",
    "body": [
      "Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。",
      "",
      "# 全局安装 vue-cli",
      "$ cnpm install --global vue-cli",
      "# 创建一个基于 webpack 模板的新项目",
      "$ vue init webpack my-project",
      "# 这里需要进行一些配置，默认回车即可",
      "This will install Vue 2.x version of the template.",
      "",
      "For Vue 1.x use: vue init webpack#1.0 my-project",
      "",
      "? Project name my-project",
      "? Project description A Vue.js project",
      "? Author runoob <test@runoob.com>",
      "? Vue build standalone",
      "? Use ESLint to lint your code? Yes",
      "? Pick an ESLint preset Standard",
      "? Setup unit tests with Karma + Mocha? Yes",
      "? Setup e2e tests with Nightwatch? Yes",
      "",
      "   vue-cli · Generated \"my-project\".",
      "",
      "   To get started:",
      "   ",
      "     cd my-project",
      "     npm install",
      "     npm run dev",
      "   ",
      "   Documentation can be found at https://vuejs-templates.github.io/webpack",
      "进入项目，安装并运行：",
      "",
      "$ cd my-project",
      "$ cnpm install",
      "$ cnpm run dev",
      " DONE  Compiled successfully in 4388ms",
      "",
      "> Listening at http://localhost:8080",
      "成功执行以上命令后访问 http://localhost:8080/，输出结果如下所示："
    ]
  },
  "vu-Hello.vue": {
    "prefix": "vu-Hello.vue",
    "body": [
      "<template>",
      "  <div class=\"hello\">",
      "    <h1>{{ msg }}</h1>",
      "  </div>",
      "</template>",
      " ",
      "<script>",
      "export default {",
      "  name: 'hello',",
      "  data () {",
      "    return {",
      "      msg: '欢迎来到菜鸟教程！'",
      "    }",
      "  }",
      "}",
      "</script>"
    ]
  },
  "vu-Vue.js 起步": {
    "prefix": "vu-Vue.js 起步",
    "body": [
      "每个 Vue 应用都需要通过实例化 Vue 来实现。",
      "",
      "语法格式如下：",
      "",
      "var vm = new Vue({",
      "  // 选项",
      "})",
      "接下来让我们通过实例来看下 Vue 构造器中需要哪些内容：",
      "",
      "实例",
      "<div id=\"vue_det\">",
      "    <h1>site : {{site}}</h1>",
      "    <h1>url : {{url}}</h1>",
      "    <h1>{{details()}}</h1>",
      "</div>",
      "<script type=\"text/javascript\">",
      "    var vm = new Vue({",
      "        el: '#vue_det',",
      "        data: {",
      "            site: \"菜鸟教程\",",
      "            url: \"www.runoob.com\",",
      "            alexa: \"10000\"",
      "        },",
      "        methods: {",
      "            details: function() {",
      "                return  this.site + \" - 学的不仅是技术，更是梦想！\";",
      "            }",
      "        }",
      "    })",
      "</script>"
    ]
  },
  "vu-vue起步2": {
    "prefix": "vu-vue起步2",
    "body": [
      "当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化。",
      "",
      "实例",
      "<div id=\"vue_det\">",
      "    <h1>site : {{site}}</h1>",
      "    <h1>url : {{url}}</h1>",
      "    <h1>Alexa : {{alexa}}</h1>",
      "</div>",
      "<script type=\"text/javascript\">",
      "// 我们的数据对象",
      "var data = { site: \"菜鸟教程\", url: \"www.runoob.com\", alexa: 10000}",
      "var vm = new Vue({",
      "    el: '#vue_det',",
      "    data: data",
      "})",
      "// 它们引用相同的对象！",
      "document.write(vm.site === data.site) // true",
      "document.write(\"<br>\")",
      "// 设置属性也会影响到原始数据",
      "vm.site = \"Runoob\"",
      "document.write(data.site + \"<br>\") // Runoob",
      " ",
      "// ……反之亦然",
      "data.alexa = 1234",
      "document.write(vm.alexa) // 1234",
      "</script>"
    ]
  },
  "vu-前缀 $": {
    "prefix": "vu-前缀 $",
    "body": [
      "除了数据属性，Vue 实例还提供了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。例如：",
      "",
      "实例",
      "<div id=\"vue_det\">",
      "    <h1>site : {{site}}</h1>",
      "    <h1>url : {{url}}</h1>",
      "    <h1>Alexa : {{alexa}}</h1>",
      "</div>",
      "<script type=\"text/javascript\">",
      "// 我们的数据对象",
      "var data = { site: \"菜鸟教程\", url: \"www.runoob.com\", alexa: 10000}",
      "var vm = new Vue({",
      "    el: '#vue_det',",
      "    data: data",
      "})",
      " ",
      "document.write(vm.$data === data) // true",
      "document.write(\"<br>\") ",
      "document.write(vm.$el === document.getElementById('vue_det')) // true",
      "</script>"
    ]
  },
  "vu-文本插值": {
    "prefix": "vu-文本插值",
    "body": [
      "数据绑定最常见的形式就是使用 {{...}}（双大括号）的文本插值：",
      "",
      "文本插值",
      "<div id=\"app\">",
      "  <p>{{ message }}</p>",
      "</div>"
    ]
  },
  "vu- v-html": {
    "prefix": "vu-v-html",
    "body": [
      "使用 v-html 指令用于输出 html 代码：",
      "",
      "v-html 指令",
      "<div id=\"app\">",
      "    <div v-html=\"message\"></div>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    message: '<h1>菜鸟教程</h1>'",
      "  }",
      "})",
      "</script>"
    ]
  },
  "vu-v-bind指令": {
    "prefix": "vu-v-bind指令",
    "body": [
      "HTML 属性中的值应使用 v-bind 指令。",
      "",
      "以下实例判断 use 的值，如果为 true 使用 class1 类的样式，否则不使用该类：",
      "",
      "v-bind 指令",
      "<div id=\"app\">",
      "  <label for=\"r1\">修改颜色</label><input type=\"checkbox\" v-model=\"use\" id=\"r1\">",
      "  <br><br>",
      "  <div v-bind:class=\"{'class1': use}\">",
      "    v-bind:class 指令",
      "  </div>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "    el: '#app',",
      "  data:{",
      "      use: false",
      "  }",
      "});",
      "</script>"
    ]
  },
  "vu-表达式": {
    "prefix": "vu-表达式",
    "body": [
      "Vue.js 都提供了完全的 JavaScript 表达式支持。",
      "",
      "JavaScript 表达式",
      "<div id=\"app\">",
      "    {{5+5}}<br>",
      "    {{ ok ? 'YES' : 'NO' }}<br>",
      "    {{ message.split('').reverse().join('') }}",
      "    <div v-bind:id=\"'list-' + id\">菜鸟教程</div>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    ok: true,",
      "    message: 'RUNOOB',",
      "    id : 1",
      "  }",
      "})",
      "</script>"
    ]
  },
  "vu-v-if": {
    "prefix": "vu-v-if",
    "body": [
      "指令是带有 v- 前缀的特殊属性。",
      "",
      "指令用于在表达式的值改变时，将某些行为应用到 DOM 上。如下例子：",
      "",
      "实例",
      "<div id=\"app\">",
      "    <p v-if=\"seen\">现在你看到我了</p>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    seen: true",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "这里， v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素。"
    ]
  },
  "vu-v-bind": {
    "prefix": "vu-v-bind",
    "body": [
      "参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：",
      "",
      "实例",
      "<div id=\"app\">",
      "    <pre><a v-bind:href=\"url\">菜鸟教程</a></pre>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    url: 'http://www.runoob.com'",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "在这里 href 是参数，告知 v-bind 指令将该元素的 href 属性与表达式 url 的值绑定。"
    ]
  },
  "vu-v-on": {
    "prefix": "vu-v-on",
    "body": [
      "另一个例子是 v-on 指令，它用于监听 DOM 事件：",
      "",
      "<a v-on:click=\"doSomething\">",
      "在这里参数是监听的事件名"
    ]
  },
  "vu-修饰符是以半角句号 . 指明的特殊后缀": {
    "prefix": "vu-修饰符是以半角句号 . 指明的特殊后缀",
    "body": [
      "修饰符是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：",
      "",
      "<form v-on:submit.prevent=\"onSubmit\"></form>"
    ]
  },
  "vu-v-model 指令来实现双向数据绑定": {
    "prefix": "vu-v-model 指令来实现双向数据绑定",
    "body": [
      "在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：",
      "",
      "双向数据绑定",
      "<div id=\"app\">",
      "    <p>{{ message }}</p>",
      "    <input v-model=\"message\">",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    message: 'Runoob!'",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "v-model 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。"
    ]
  },
  "vu-v-on 监听事件": {
    "prefix": "vu-v-on 监听事件",
    "body": [
      "按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。",
      "",
      "以下实例在用户点击按钮后对字符串进行反转操作：",
      "",
      "字符串反转",
      "<div id=\"app\">",
      "    <p>{{ message }}</p>",
      "    <button v-on:click=\"reverseMessage\">反转字符串</button>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    message: 'Runoob!'",
      "  },",
      "  methods: {",
      "    reverseMessage: function () {",
      "      this.message = this.message.split('').reverse().join('')",
      "    }",
      "  }",
      "})",
      "</script>"
    ]
  },
  "vu-过滤器": {
    "prefix": "vu-过滤器",
    "body": [
      "Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由\"管道符\"指示, 格式如下：",
      "",
      "<!-- 在两个大括号中 -->",
      "{{ message | capitalize }}",
      "",
      "<!-- 在 v-bind 指令中 -->",
      "<div v-bind:id=\"rawId | formatId\"></div>",
      "过滤器函数接受表达式的值作为第一个参数。",
      "",
      "以下实例对输入的字符串第一个字母转为大写：",
      "",
      "实例",
      "<div id=\"app\">",
      "  {{ message | capitalize }}",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    message: 'runoob'",
      "  },",
      "  filters: {",
      "    capitalize: function (value) {",
      "      if (!value) return ''",
      "      value = value.toString()",
      "      return value.charAt(0).toUpperCase() + value.slice(1)",
      "    }",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "过滤器可以串联：",
      "",
      "{{ message | filterA | filterB }}",
      "过滤器是 JavaScript 函数，因此可以接受参数：",
      "",
      "{{ message | filterA('arg1', arg2) }}",
      "这里，message 是第一个参数，字符串 'arg1' 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。"
    ]
  },
  "vu-v-bind 缩写": {
    "prefix": "vu-v-bind 缩写",
    "body": [
      "v-bind 缩写",
      "Vue.js 为两个最为常用的指令提供了特别的缩写：",
      "",
      "<!-- 完整语法 -->",
      "<a v-bind:href=\"url\"></a>",
      "<!-- 缩写 -->",
      "<a :href=\"url\"></a>"
    ]
  },
  "vu-v-on 缩写": {
    "prefix": "vu-v-on 缩写",
    "body": [
      "<!-- 完整语法 -->",
      "<a v-on:click=\"doSomething\"></a>",
      "<!-- 缩写 -->",
      "<a @click=\"doSomething\"></a>"
    ]
  },
  "vu-条件判断使用 v-if 指令：": {
    "prefix": "vu-条件判断使用 v-if 指令：",
    "body": [
      "在元素 和 template 中使用 v-if 指令：",
      "",
      "<div id=\"app\">",
      "    <p v-if=\"seen\">现在你看到我了</p>",
      "    <template v-if=\"ok\">",
      "      <h1>菜鸟教程</h1>",
      "      <p>学的不仅是技术，更是梦想！</p>",
      "      <p>哈哈哈，打字辛苦啊！！！</p>",
      "    </template>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    seen: true,",
      "    ok: true",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "这里， v-if 指令将根据表达式 seen 的值(true 或 false )来决定是否插入 p 元素。",
      "",
      "在字符串模板中，如 Handlebars ，我们得像这样写一个条件块：",
      "",
      "<!-- Handlebars 模板 -->",
      "{{#if ok}}",
      "  <h1>Yes</h1>",
      "{{/if}}"
    ]
  },
  "vu-v-else": {
    "prefix": "vu-v-else",
    "body": [
      "可以用 v-else 指令给 v-if 添加一个 \"else\" 块：",
      "",
      "v-else 指令",
      "随机生成一个数字，判断是否大于0.5，然后输出对应信息：",
      "",
      "<div id=\"app\">",
      "    <div v-if=\"Math.random() > 0.5\">",
      "      Sorry",
      "    </div>",
      "    <div v-else>",
      "      Not sorry",
      "    </div>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app'",
      "})",
      "</script>"
    ]
  },
  "vu-v-else-if": {
    "prefix": "vu-v-else-if",
    "body": [
      "v-else-if 在 2.1.0 新增，顾名思义，用作 v-if 的 else-if 块。可以链式的多次使用：",
      "",
      "v-else 指令",
      "判断 type 变量的值：",
      "",
      "<div id=\"app\">",
      "    <div v-if=\"type === 'A'\">",
      "      A",
      "    </div>",
      "    <div v-else-if=\"type === 'B'\">",
      "      B",
      "    </div>",
      "    <div v-else-if=\"type === 'C'\">",
      "      C",
      "    </div>",
      "    <div v-else>",
      "      Not A/B/C",
      "    </div>",
      "</div>",
      "    ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    type: 'C'",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后。"
    ]
  },
  "vu-v-show": {
    "prefix": "vu-v-show",
    "body": [
      "我们也可以使用 v-show 指令来根据条件展示元素：",
      "",
      "v-show 指令",
      "<h1 v-show=\"ok\">Hello!</h1>"
    ]
  },
  "vu-v-for 指令": {
    "prefix": "vu-v-for 指令",
    "body": [
      "循环使用 v-for 指令。",
      "",
      "v-for 指令需要以 site in sites 形式的特殊语法， sites 是源数据数组并且 site 是数组元素迭代的别名。",
      "",
      "v-for 可以绑定数据到数组来渲染一个列表：",
      "",
      "v-for 指令",
      "<div id=\"app\">",
      "  <ol>",
      "    <li v-for=\"site in sites\">",
      "      {{ site.name }}",
      "    </li>",
      "  </ol>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    sites: [",
      "      { name: 'Runoob' },",
      "      { name: 'Google' },",
      "      { name: 'Taobao' }",
      "    ]",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "模板中使用 v-for：",
      "",
      "v-for",
      "<ul>",
      "  <template v-for=\"site in sites\">",
      "    <li>{{ site.name }}</li>",
      "    <li>--------------</li>",
      "  </template>",
      "</ul>"
    ]
  },
  "vu-v-for 迭代对象": {
    "prefix": "vu-v-for 迭代对象",
    "body": [
      "v-for 可以通过一个对象的属性来迭代数据：",
      "",
      "v-for",
      "<div id=\"app\">",
      "  <ul>",
      "    <li v-for=\"value in object\">",
      "    {{ value }}",
      "    </li>",
      "  </ul>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    object: {",
      "      name: '菜鸟教程',",
      "      url: 'http://www.runoob.com',",
      "      slogan: '学的不仅是技术，更是梦想！'",
      "    }",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "你也可以提供第二个的参数为键名：",
      "",
      "v-for",
      "<div id=\"app\">",
      "  <ul>",
      "    <li v-for=\"(value, key) in object\">",
      "    {{ key }} : {{ value }}",
      "    </li>",
      "  </ul>",
      "</div>",
      "",
      "尝试一下 »",
      "第三个参数为索引：",
      "",
      "v-for",
      "<div id=\"app\">",
      "  <ul>",
      "    <li v-for=\"(value, key, index) in object\">",
      "     {{ index }}. {{ key }} : {{ value }}",
      "    </li>",
      "  </ul>",
      "</div>",
      "",
      "尝试一下 »",
      "v-for 迭代整数",
      "v-for 也可以循环整数",
      "",
      "v-for",
      "<div id=\"app\">",
      "  <ul>",
      "    <li v-for=\"n in 10\">",
      "     {{ n }}",
      "    </li>",
      "  </ul>",
      "</div>"
    ]
  },
  "vu-计算属性关键词: computed": {
    "prefix": "vu-计算属性关键词: computed",
    "body": [
      "计算属性关键词: computed。",
      "",
      "计算属性在处理一些复杂逻辑时是很有用的。",
      "",
      "可以看下以下反转字符串的例子：",
      "",
      "实例 1",
      "<div id=\"app\">",
      "  {{ message.split('').reverse().join('') }}",
      "</div>",
      "",
      "尝试一下 »",
      "实例 1 中模板变的很复杂起来，也不容易看懂理解。",
      "",
      "接下来我们看看使用了计算属性的实例：",
      "",
      "实例 2",
      "<div id=\"app\">",
      "  <p>原始字符串: {{ message }}</p>",
      "  <p>计算后反转字符串: {{ reversedMessage }}</p>",
      "</div>",
      " ",
      "<script>",
      "var vm = new Vue({",
      "  el: '#app',",
      "  data: {",
      "    message: 'Runoob!'",
      "  },",
      "  computed: {",
      "    // 计算属性的 getter",
      "    reversedMessage: function () {",
      "      // `this` 指向 vm 实例",
      "      return this.message.split('').reverse().join('')",
      "    }",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "实例 2 中声明了一个计算属性 reversedMessage 。",
      "",
      "提供的函数将用作属性 vm.reversedMessage 的 getter 。",
      "",
      "vm.reversedMessage 依赖于 vm.message，在 vm.message 发生改变时，vm.reversedMessage 也会更新。"
    ]
  },
  "vu-computed vs methods": {
    "prefix": "vu-computed vs methods",
    "body": [
      "我们可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。",
      "",
      "实例 3",
      "methods: {",
      "  reversedMessage2: function () {",
      "    return this.message.split('').reverse().join('')",
      "  }",
      "}",
      "",
      "尝试一下 »",
      "可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。"
    ]
  },
  "vu-computed setter": {
    "prefix": "vu-computed setter",
    "body": [
      "computed setter",
      "computed 属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：",
      "",
      "实例 4",
      "var vm = new Vue({",
      "  el: '#app',",
      "  data: {",
      "    name: 'Google',",
      "    url: 'http://www.google.com'",
      "  },",
      "  computed: {",
      "    site: {",
      "      // getter",
      "      get: function () {",
      "        return this.name + ' ' + this.url",
      "      },",
      "      // setter",
      "      set: function (newValue) {",
      "        var names = newValue.split(' ')",
      "        this.name = names[0]",
      "        this.url = names[names.length - 1]",
      "      }",
      "    }",
      "  }",
      "})",
      "// 调用 setter， vm.name 和 vm.url 也会被对应更新",
      "vm.site = '菜鸟教程 http://www.runoob.com';",
      "document.write('name: ' + vm.name);",
      "document.write('<br>');",
      "document.write('url: ' + vm.url);",
      "",
      "尝试一下 »",
      "从实例运行结果看在运行 vm.site = '菜鸟教程 http://www.runoob.com'; 时，setter 会被调用， vm.name 和 vm.url 也会被对应更新。"
    ]
  },
  "vu-监听属性 watch": {
    "prefix": "vu-监听属性 watch",
    "body": [
      "本章节，我们将为大家介绍 Vue.js 监听属性 watch，我们可以通过 watch 来响应数据的变化。",
      "",
      "以下实例通过使用 watch 实现计数器：",
      "",
      "实例",
      "<div id = \"app\">",
      "    <p style = \"font-size:25px;\">计数器: {{ counter }}</p>",
      "    <button @click = \"counter++\" style = \"font-size:25px;\">点我</button>",
      "</div>",
      "<script type = \"text/javascript\">",
      "var vm = new Vue({",
      "    el: '#app',",
      "    data: {",
      "        counter: 1",
      "    }",
      "});",
      "vm.$watch('counter', function(nval, oval) {",
      "    alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');",
      "});",
      "</script>",
      "",
      "尝试一下 »",
      "以下实例进行千米与米之间的换算：",
      "",
      "实例",
      "<div id = \"computed_props\">",
      "    千米 : <input type = \"text\" v-model = \"kilometers\">",
      "    米 : <input type = \"text\" v-model = \"meters\">",
      "</div>",
      "<p id=\"info\"></p>",
      "<script type = \"text/javascript\">",
      "    var vm = new Vue({",
      "    el: '#computed_props',",
      "    data: {",
      "        kilometers : 0,",
      "        meters:0",
      "    },",
      "    methods: {",
      "    },",
      "    computed :{",
      "    },",
      "    watch : {",
      "        kilometers:function(val) {",
      "            this.kilometers = val;",
      "            this.meters = this.kilometers * 1000",
      "        },",
      "        meters : function (val) {",
      "            this.kilometers = val/ 1000;",
      "            this.meters = val;",
      "        }",
      "    }",
      "    });",
      "    // $watch 是一个实例方法",
      "    vm.$watch('kilometers', function (newValue, oldValue) {",
      "    // 这个回调将在 vm.kilometers 改变后调用",
      "    document.getElementById (\"info\").innerHTML = \"修改前值为: \" + oldValue + \"，修改后值为: \" + newValue;",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "点击 \"尝试一下\" 按钮查看在线实例",
      "",
      "以上代码中我们创建了两个输入框，data 属性中， kilometers 和 meters 初始值都为 0。watch 对象创建了两个方法 kilometers 和 meters。",
      "",
      "当我们再输入框输入数据时，watch 会实时监听数据变化并改变自身的值。可以看下如下视频演示："
    ]
  },
  "vu-v-bind:class": {
    "prefix": "vu-v-bind:class",
    "body": [
      "我们可以为 v-bind:class 设置一个对象，从而动态的切换 class:",
      "",
      "实例 1",
      "实例中将 isActive 设置为 true 显示了一个绿色的 div 块，如果设置为 false 则不显示：",
      "",
      "<div v-bind:class=\"{ active: isActive }\"></div>",
      "",
      "尝试一下 »",
      "以上实例 div class 为：",
      "",
      "<div class=\"active\"></div>",
      "我们也可以在对象中传入更多属性用来动态切换多个 class 。",
      "",
      "实例 2",
      "text-danger 类背景颜色覆盖了 active 类的背景色：",
      "",
      "<div class=\"static\"",
      "     v-bind:class=\"{ active: isActive, 'text-danger': hasError }\">",
      "</div>",
      "",
      "尝试一下 »",
      "以上实例 div class 为：",
      "",
      "<div class=\"static active text-danger\"></div>",
      "我们也可以直接绑定数据里的一个对象：",
      "",
      "实例 3",
      "text-danger 类背景颜色覆盖了 active 类的背景色：",
      "",
      "<div id=\"app\">",
      "  <div v-bind:class=\"classObject\"></div>",
      "</div>",
      "",
      "尝试一下 »",
      "实例 3 与 实例 2 的渲染结果是一样的。",
      "",
      "此外，我们也可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式：",
      "",
      "实例 4",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    isActive: true,",
      "    error: {",
      "      value: true,",
      "      type: 'fatal'",
      "    }",
      "  },",
      "  computed: {",
      "    classObject: function () {",
      "      return {",
      "  base: true,",
      "        active: this.isActive && !this.error.value,",
      "        'text-danger': this.error.value && this.error.type === 'fatal',",
      "      }",
      "    }",
      "  }",
      "})",
      "",
      "尝试一下 »",
      "数组语法",
      "我们可以把一个数组传给 v-bind:class ，实例如下：",
      "",
      "实例 5",
      "<div v-bind:class=\"[activeClass, errorClass]\"></div>",
      "",
      "尝试一下 »",
      "以上实例 div class 为：",
      "",
      "<div class=\"active text-danger\"></div>",
      "我们还可以使用三元表达式来切换列表中的 class ：",
      "",
      "实例 6",
      "errorClass 是始终存在的，isActive 为 true 时添加 activeClass 类：",
      "",
      "<div v-bind:class=\"[errorClass ,isActive ? activeClass : '']\"></div>"
    ]
  },
  "vu-v-bind:style 直接设置样式": {
    "prefix": "vu-v-bind:style 直接设置样式",
    "body": [
      "我们可以在 v-bind:style 直接设置样式：",
      "",
      "实例 7",
      "<div id=\"app\">",
      "    <div v-bind:style=\"{ color: activeColor, fontSize: fontSize + 'px' }\">菜鸟教程</div>",
      "</div>",
      "",
      "尝试一下 »",
      "以上实例 div style 为：",
      "",
      "<div style=\"color: green; font-size: 30px;\">菜鸟教程</div>",
      "也可以直接绑定到一个样式对象，让模板更清晰：",
      "",
      "实例 8",
      "<div id=\"app\">",
      "  <div v-bind:style=\"styleObject\">菜鸟教程</div>",
      "</div>",
      "",
      "尝试一下 »",
      "v-bind:style 可以使用数组将多个样式对象应用到一个元素上：",
      "",
      "实例 9",
      "<div id=\"app\">",
      "  <div v-bind:style=\"[baseStyles, overridingStyles]\">菜鸟教程</div>",
      "</div>"
    ]
  },
  "vu-v-on 指令": {
    "prefix": "vu-v-on 指令",
    "body": [
      "事件监听可以使用 v-on 指令：",
      "",
      "v-on",
      "<div id=\"app\">",
      "  <button v-on:click=\"counter += 1\">增加 1</button>",
      "  <p>这个按钮被点击了 {{ counter }} 次。</p>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    counter: 0",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "通常情况下，我们需要使用一个方法来调用 JavaScript 方法。",
      "",
      "v-on 可以接收一个定义的方法来调用。",
      "",
      "v-on",
      "<div id=\"app\">",
      "   <!-- `greet` 是在下面定义的方法名 -->",
      "  <button v-on:click=\"greet\">Greet</button>",
      "</div>",
      " ",
      "<script>",
      "var app = new Vue({",
      "  el: '#app',",
      "  data: {",
      "    name: 'Vue.js'",
      "  },",
      "  // 在 `methods` 对象中定义方法",
      "  methods: {",
      "    greet: function (event) {",
      "      // `this` 在方法里指当前 Vue 实例",
      "      alert('Hello ' + this.name + '!')",
      "      // `event` 是原生 DOM 事件",
      "      if (event) {",
      "          alert(event.target.tagName)",
      "      }",
      "    }",
      "  }",
      "})",
      "// 也可以用 JavaScript 直接调用方法",
      "app.greet() // -> 'Hello Vue.js!'",
      "</script>",
      "",
      "尝试一下 »",
      "除了直接绑定到一个方法，也可以用内联 JavaScript 语句：",
      "",
      "v-on",
      "<div id=\"app\">",
      "  <button v-on:click=\"say('hi')\">Say hi</button>",
      "  <button v-on:click=\"say('what')\">Say what</button>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  methods: {",
      "    say: function (message) {",
      "      alert(message)",
      "    }",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "事件修饰符",
      "Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。",
      "",
      "Vue.js通过由点(.)表示的指令后缀来调用修饰符。",
      "",
      ".stop",
      ".prevent",
      ".capture",
      ".self",
      ".once",
      "<!-- 阻止单击事件冒泡 -->",
      "<a v-on:click.stop=\"doThis\"></a>",
      "<!-- 提交事件不再重载页面 -->",
      "<form v-on:submit.prevent=\"onSubmit\"></form>",
      "<!-- 修饰符可以串联  -->",
      "<a v-on:click.stop.prevent=\"doThat\"></a>",
      "<!-- 只有修饰符 -->",
      "<form v-on:submit.prevent></form>",
      "<!-- 添加事件侦听器时使用事件捕获模式 -->",
      "<div v-on:click.capture=\"doThis\">...</div>",
      "<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->",
      "<div v-on:click.self=\"doThat\">...</div>",
      "",
      "<!-- click 事件只能点击一次，2.1.4版本新增 -->",
      "<a v-on:click.once=\"doThis\"></a>",
      "按键修饰符",
      "Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：",
      "",
      "<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->",
      "<input v-on:keyup.13=\"submit\">",
      "记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：",
      "",
      "<!-- 同上 -->",
      "<input v-on:keyup.enter=\"submit\">",
      "<!-- 缩写语法 -->",
      "<input @keyup.enter=\"submit\">",
      "全部的按键别名：",
      "",
      ".enter",
      ".tab",
      ".delete (捕获 \"删除\" 和 \"退格\" 键)",
      ".esc",
      ".space",
      ".up",
      ".down",
      ".left",
      ".right",
      ".ctrl",
      ".alt",
      ".shift",
      ".meta",
      "实例",
      "",
      "<p><!-- Alt + C -->",
      "<input @keyup.alt.67=\"clear\">",
      "<!-- Ctrl + Click -->",
      "<div @click.ctrl=\"doSomething\">Do something</div>"
    ]
  },
  "vu- input 和 textarea 元素中使用 v-model 实现双向数据绑定": {
    "prefix": " input 和 textarea 元素中使用 v-model 实现双向数据绑定",
    "body": [
      "v-model 会根据控件类型自动选取正确的方法来更新元素。",
      "",
      "输入框",
      "实例中演示了 input 和 textarea 元素中使用 v-model 实现双向数据绑定：",
      "",
      "<div id=\"app\">",
      "  <p>input 元素：</p>",
      "  <input v-model=\"message\" placeholder=\"编辑我……\">",
      "  <p>消息是: {{ message }}</p>",
      "    ",
      "  <p>textarea 元素：</p>",
      "  <p style=\"white-space: pre\">{{ message2 }}</p>",
      "  <textarea v-model=\"message2\" placeholder=\"多行文本输入……\"></textarea>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    message: 'Runoob',",
      "    message2: '菜鸟教程\r\nhttp://www.runoob.com'",
      "  }",
      "})",
      "</script>"
    ]
  },
  "vu-v-model复选框": {
    "prefix": "vu-v-model复选框",
    "body": [
      "复选框",
      "复选框如果是一个为逻辑值，如果是多个则绑定到同一个数组：",
      "",
      "复选框",
      "以下实例中演示了复选框的双向数据绑定：",
      "",
      "<div id=\"app\">",
      "  <p>单个复选框：</p>",
      "  <input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\">",
      "  <label for=\"checkbox\">{{ checked }}</label>",
      "    ",
      "  <p>多个复选框：</p>",
      "  <input type=\"checkbox\" id=\"runoob\" value=\"Runoob\" v-model=\"checkedNames\">",
      "  <label for=\"runoob\">Runoob</label>",
      "  <input type=\"checkbox\" id=\"google\" value=\"Google\" v-model=\"checkedNames\">",
      "  <label for=\"google\">Google</label>",
      "  <input type=\"checkbox\" id=\"taobao\" value=\"Taobao\" v-model=\"checkedNames\">",
      "  <label for=\"taobao\">taobao</label>",
      "  <br>",
      "  <span>选择的值为: {{ checkedNames }}</span>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    checked : false,",
      "    checkedNames: []",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "实例中勾选复选框效果如下所示："
    ]
  },
  "vu-v-model单选按钮": {
    "prefix": "vu-v-model单选按钮",
    "body": [
      "以下实例中演示了单选按钮的双向数据绑定：",
      "",
      "单选按钮",
      "<div id=\"app\">",
      "  <input type=\"radio\" id=\"runoob\" value=\"Runoob\" v-model=\"picked\">",
      "  <label for=\"runoob\">Runoob</label>",
      "  <br>",
      "  <input type=\"radio\" id=\"google\" value=\"Google\" v-model=\"picked\">",
      "  <label for=\"google\">Google</label>",
      "  <br>",
      "  <span>选中值为: {{ picked }}</span>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    picked : 'Runoob'",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "选中后，效果如下图所示："
    ]
  },
  "vu-v-modelselect 列表": {
    "prefix": "vu-v-modelselect 列表",
    "body": [
      "以下实例中演示了下拉列表的双向数据绑定：",
      "",
      "select",
      "<div id=\"app\">",
      "  <select v-model=\"selected\" name=\"fruit\">",
      "    <option value=\"\">选择一个网站</option>",
      "    <option value=\"www.runoob.com\">Runoob</option>",
      "    <option value=\"www.google.com\">Google</option>",
      "  </select>",
      " ",
      "  <div id=\"output\">",
      "      选择的网站是: {{selected}}",
      "  </div>",
      "</div>",
      " ",
      "<script>",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    selected: '' ",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "选取 Runoob，输出效果如下所示："
    ]
  },
  "vu-v-model修饰符": {
    "prefix": "vu-v-model修饰符",
    "body": [
      ".lazy",
      "在默认情况下， v-model 在 input 事件中同步输入框的值与数据，但你可以添加一个修饰符 lazy ，从而转变为在 change 事件中同步：",
      "",
      "<!-- 在 \"change\" 而不是 \"input\" 事件中更新 -->",
      "<input v-model.lazy=\"msg\" >",
      ".number",
      "如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值），可以添加一个修饰符 number 给 v-model 来处理输入值：",
      "",
      "<input v-model.number=\"age\" type=\"number\">",
      "这通常很有用，因为在 type=\"number\" 时 HTML 中输入的值也总是会返回字符串类型。",
      "",
      ".trim",
      "如果要自动过滤用户输入的首尾空格，可以添加 trim 修饰符到 v-model 上过滤输入：",
      "",
      "<input v-model.trim=\"msg\">"
    ]
  },
  "vu-Vue.js 组件": {
    "prefix": "vu-Vue.js 组件",
    "body": [
      "组件（Component）是 Vue.js 最强大的功能之一。",
      "",
      "组件可以扩展 HTML 元素，封装可重用的代码。",
      "",
      "组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：",
      "",
      "",
      "",
      "注册一个全局组件语法格式如下：",
      "",
      "Vue.component(tagName, options)",
      "tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件：",
      "",
      "<tagName></tagName>"
    ]
  },
  "vu-全局组件": {
    "prefix": "vu-全局组件",
    "body": [
      "所有实例都能用全局组件。",
      "",
      "全局组件实例",
      "注册一个简单的全局组件 runoob，并使用它：",
      "",
      "<div id=\"app\">",
      "    <runoob></runoob>",
      "</div>",
      " ",
      "<script>",
      "// 注册",
      "Vue.component('runoob', {",
      "  template: '<h1>自定义组件!</h1>'",
      "})",
      "// 创建根实例",
      "new Vue({",
      "  el: '#app'",
      "})",
      "</script>"
    ]
  },
  "vu-局部组件": {
    "prefix": "vu-局部组件",
    "body": [
      "我们也可以在实例选项中注册局部组件，这样组件只能在这个实例中使用：",
      "",
      "局部组件实例",
      "注册一个简单的局部组件 runoob，并使用它：",
      "",
      "<div id=\"app\">",
      "    <runoob></runoob>",
      "</div>",
      " ",
      "<script>",
      "var Child = {",
      "  template: '<h1>自定义组件!</h1>'",
      "}",
      " ",
      "// 创建根实例",
      "new Vue({",
      "  el: '#app',",
      "  components: {",
      "    // <runoob> 将只在父模板可用",
      "    'runoob': Child",
      "  }",
      "})",
      "</script>"
    ]
  },
  "vu-Prop": {
    "prefix": "vu-Prop",
    "body": [
      "prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。",
      "",
      "父组件的数据需要通过 props 把数据传给子组件，子组件需要显式地用 props 选项声明 \"prop\"：",
      "",
      "Prop 实例",
      "<div id=\"app\">",
      "    <child message=\"hello!\"></child>",
      "</div>",
      " ",
      "<script>",
      "// 注册",
      "Vue.component('child', {",
      "  // 声明 props",
      "  props: ['message'],",
      "  // 同样也可以在 vm 实例中像 \"this.message\" 这样使用",
      "  template: '<span>{{ message }}</span>'",
      "})",
      "// 创建根实例",
      "new Vue({",
      "  el: '#app'",
      "})",
      "</script>"
    ]
  },
  "vu-动态 Prop": {
    "prefix": "vu-动态 Prop",
    "body": [
      "类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 动态绑定 props 的值到父组件的数据中。每当父组件的数据变化时，该变化也会传导给子组件：",
      "",
      "Prop 实例",
      "<div id=\"app\">",
      "    <div>",
      "      <input v-model=\"parentMsg\">",
      "      <br>",
      "      <child v-bind:message=\"parentMsg\"></child>",
      "    </div>",
      "</div>",
      " ",
      "<script>",
      "// 注册",
      "Vue.component('child', {",
      "  // 声明 props",
      "  props: ['message'],",
      "  // 同样也可以在 vm 实例中像 \"this.message\" 这样使用",
      "  template: '<span>{{ message }}</span>'",
      "})",
      "// 创建根实例",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    parentMsg: '父组件内容'",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "以下实例中使用 v-bind 指令将 todo 传到每一个重复的组件中：",
      "",
      "Prop 实例",
      "<div id=\"app\">",
      "    <ol>",
      "    <todo-item v-for=\"item in sites\" v-bind:todo=\"item\"></todo-item>",
      "      </ol>",
      "</div>",
      " ",
      "<script>",
      "Vue.component('todo-item', {",
      "  props: ['todo'],",
      "  template: '<li>{{ todo.text }}</li>'",
      "})",
      "new Vue({",
      "  el: '#app',",
      "  data: {",
      "    sites: [",
      "      { text: 'Runoob' },",
      "      { text: 'Google' },",
      "      { text: 'Taobao' }",
      "    ]",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "注意: prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。"
    ]
  },
  "vu-Prop 验证": {
    "prefix": "vu-Prop 验证",
    "body": [
      "组件可以为 props 指定验证要求。",
      "",
      "为了定制 prop 的验证方式，你可以为 props 中的值提供一个带有验证需求的对象，而不是一个字符串数组。例如：",
      "",
      "Vue.component('my-component', {",
      "  props: {",
      "    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)",
      "    propA: Number,",
      "    // 多个可能的类型",
      "    propB: [String, Number],",
      "    // 必填的字符串",
      "    propC: {",
      "      type: String,",
      "      required: true",
      "    },",
      "    // 带有默认值的数字",
      "    propD: {",
      "      type: Number,",
      "      default: 100",
      "    },",
      "    // 带有默认值的对象",
      "    propE: {",
      "      type: Object,",
      "      // 对象或数组默认值必须从一个工厂函数获取",
      "      default: function () {",
      "        return { message: 'hello' }",
      "      }",
      "    },",
      "    // 自定义验证函数",
      "    propF: {",
      "      validator: function (value) {",
      "        // 这个值必须匹配下列字符串中的一个",
      "        return ['success', 'warning', 'danger'].indexOf(value) !== -1",
      "      }",
      "    }",
      "  }",
      "})",
      "当 prop 验证失败的时候，(开发环境构建版本的) Vue 将会产生一个控制台的警告。",
      "",
      "type 可以是下面原生构造器：",
      "",
      "String",
      "Number",
      "Boolean",
      "Array",
      "Object",
      "Date",
      "Function",
      "Symbol",
      "type 也可以是一个自定义构造器，使用 instanceof 检测。"
    ]
  },
  "vu-Vue.js 自定义指令": {
    "prefix": "vu-Vue.js 自定义指令",
    "body": [
      "除了默认设置的核心指令( v-model 和 v-show ), Vue 也允许注册自定义指令。",
      "",
      "下面我们注册一个全局指令 v-focus, 该指令的功能是在页面加载时，元素获得焦点：",
      "",
      "实例",
      "<div id=\"app\">",
      "    <p>页面载入时，input 元素自动获取焦点：</p>",
      "    <input v-focus>",
      "</div>",
      " ",
      "<script>",
      "// 注册一个全局自定义指令 v-focus",
      "Vue.directive('focus', {",
      "  // 当绑定元素插入到 DOM 中。",
      "  inserted: function (el) {",
      "    // 聚焦元素",
      "    el.focus()",
      "  }",
      "})",
      "// 创建根实例",
      "new Vue({",
      "  el: '#app'",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "我们也可以在实例使用 directives 选项来注册局部指令，这样指令只能在这个实例中使用：",
      "",
      "实例",
      "<div id=\"app\">",
      "  <p>页面载入时，input 元素自动获取焦点：</p>",
      "  <input v-focus>",
      "</div>",
      " ",
      "<script>",
      "// 创建根实例",
      "new Vue({",
      "  el: '#app',",
      "  directives: {",
      "    // 注册一个局部的自定义指令 v-focus",
      "    focus: {",
      "      // 指令的定义",
      "      inserted: function (el) {",
      "        // 聚焦元素",
      "        el.focus()",
      "      }",
      "    }",
      "  }",
      "})",
      "</script>"
    ]
  },
  "vu-钩子函数": {
    "prefix": "vu-钩子函数",
    "body": []
  },
  "vu-Vue.js 路由": {
    "prefix": "vu-Vue.js 路由",
    "body": [
      "本章节我们将为大家介绍 Vue.js 路由。",
      "",
      "Vue.js 路由允许我们通过不同的 URL 访问不同的内容。",
      "",
      "通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。",
      "",
      "Vue.js 路由需要载入 vue-router 库",
      "",
      "中文文档地址：vue-router文档。",
      "",
      "安装",
      "1、直接下载 / CDN",
      "https://unpkg.com/vue-router/dist/vue-router.js",
      "NPM",
      "推荐使用淘宝镜像：",
      "",
      "cnpm install vue-router",
      "简单实例",
      "Vue.js + vue-router 可以很简单的实现单页应用。",
      "",
      "<router-link> 是一个组件，该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容。",
      "",
      "以下实例中我们将 vue-router 加进来，然后配置组件和路由映射，再告诉 vue-router 在哪里渲染它们。代码如下所示：",
      "",
      "HTML 代码",
      "<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>",
      "<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>",
      " ",
      "<div id=\"app\">",
      "  <h1>Hello App!</h1>",
      "  <p>",
      "    <!-- 使用 router-link 组件来导航. -->",
      "    <!-- 通过传入 `to` 属性指定链接. -->",
      "    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->",
      "    <router-link to=\"/foo\">Go to Foo</router-link>",
      "    <router-link to=\"/bar\">Go to Bar</router-link>",
      "  </p>",
      "  <!-- 路由出口 -->",
      "  <!-- 路由匹配到的组件将渲染在这里 -->",
      "  <router-view></router-view>",
      "</div>",
      "JavaScript 代码",
      "// 0. 如果使用模块化机制编程，导入 Vue 和 VueRouter，要调用 Vue.use(VueRouter)",
      " ",
      "// 1. 定义（路由）组件。",
      "// 可以从其他文件 import 进来",
      "const Foo = { template: '<div>foo</div>' }",
      "const Bar = { template: '<div>bar</div>' }",
      " ",
      "// 2. 定义路由",
      "// 每个路由应该映射一个组件。 其中\"component\" 可以是",
      "// 通过 Vue.extend() 创建的组件构造器，",
      "// 或者，只是一个组件配置对象。",
      "// 我们晚点再讨论嵌套路由。",
      "const routes = [",
      "  { path: '/foo', component: Foo },",
      "  { path: '/bar', component: Bar }",
      "]",
      " ",
      "// 3. 创建 router 实例，然后传 `routes` 配置",
      "// 你还可以传别的配置参数, 不过先这么简单着吧。",
      "const router = new VueRouter({",
      "  routes // （缩写）相当于 routes: routes",
      "})",
      " ",
      "// 4. 创建和挂载根实例。",
      "// 记得要通过 router 配置参数注入路由，",
      "// 从而让整个应用都有路由功能",
      "const app = new Vue({",
      "  router",
      "}).$mount('#app')",
      " ",
      "// 现在，应用已经启动了！",
      "",
      "尝试一下 »",
      "点击过的导航链接都会加上样式 class =\"router-link-exact-active router-link-active\"。"
    ]
  },
  "vu-Vue.js路由": {
    "prefix": "vu-Vue.js路由",
    "body": [
      "本章节我们将为大家介绍 Vue.js 路由。",
      "",
      "Vue.js 路由允许我们通过不同的 URL 访问不同的内容。",
      "",
      "通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。",
      "",
      "Vue.js 路由需要载入 vue-router 库",
      "",
      "中文文档地址：vue-router文档。",
      "",
      "安装",
      "1、直接下载 / CDN",
      "https://unpkg.com/vue-router/dist/vue-router.js",
      "NPM",
      "推荐使用淘宝镜像：",
      "",
      "cnpm install vue-router",
      "简单实例",
      "Vue.js + vue-router 可以很简单的实现单页应用。",
      "",
      "<router-link> 是一个组件，该组件用于设置一个导航链接，切换不同 HTML 内容。 to 属性为目标地址， 即要显示的内容。",
      "",
      "以下实例中我们将 vue-router 加进来，然后配置组件和路由映射，再告诉 vue-router 在哪里渲染它们。代码如下所示：",
      "",
      "HTML 代码",
      "<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>",
      "<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>",
      " ",
      "<div id=\"app\">",
      "  <h1>Hello App!</h1>",
      "  <p>",
      "    <!-- 使用 router-link 组件来导航. -->",
      "    <!-- 通过传入 `to` 属性指定链接. -->",
      "    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->",
      "    <router-link to=\"/foo\">Go to Foo</router-link>",
      "    <router-link to=\"/bar\">Go to Bar</router-link>",
      "  </p>",
      "  <!-- 路由出口 -->",
      "  <!-- 路由匹配到的组件将渲染在这里 -->",
      "  <router-view></router-view>",
      "</div>",
      "JavaScript 代码",
      "// 0. 如果使用模块化机制编程，导入 Vue 和 VueRouter，要调用 Vue.use(VueRouter)",
      " ",
      "// 1. 定义（路由）组件。",
      "// 可以从其他文件 import 进来",
      "const Foo = { template: '<div>foo</div>' }",
      "const Bar = { template: '<div>bar</div>' }",
      " ",
      "// 2. 定义路由",
      "// 每个路由应该映射一个组件。 其中\"component\" 可以是",
      "// 通过 Vue.extend() 创建的组件构造器，",
      "// 或者，只是一个组件配置对象。",
      "// 我们晚点再讨论嵌套路由。",
      "const routes = [",
      "  { path: '/foo', component: Foo },",
      "  { path: '/bar', component: Bar }",
      "]",
      " ",
      "// 3. 创建 router 实例，然后传 `routes` 配置",
      "// 你还可以传别的配置参数, 不过先这么简单着吧。",
      "const router = new VueRouter({",
      "  routes // （缩写）相当于 routes: routes",
      "})",
      " ",
      "// 4. 创建和挂载根实例。",
      "// 记得要通过 router 配置参数注入路由，",
      "// 从而让整个应用都有路由功能",
      "const app = new Vue({",
      "  router",
      "}).$mount('#app')",
      " ",
      "// 现在，应用已经启动了！",
      "",
      "尝试一下 »",
      "点击过的导航链接都会加上样式 class =\"router-link-exact-active router-link-active\"。",
      "",
      "<router-link> 相关属性",
      "接下来我们可以了解下更多关于 <router-link> 的属性。",
      "",
      "to",
      "表示目标路由的链接。 当被点击后，内部会立刻把 to 的值传到 router.push()，所以这个值可以是一个字符串或者是描述目标位置的对象。",
      "",
      "<!-- 字符串 -->",
      "<router-link to=\"home\">Home</router-link>",
      "<!-- 渲染结果 -->",
      "<a href=\"home\">Home</a>",
      "",
      "<!-- 使用 v-bind 的 JS 表达式 -->",
      "<router-link v-bind:to=\"'home'\">Home</router-link>",
      "",
      "<!-- 不写 v-bind 也可以，就像绑定别的属性一样 -->",
      "<router-link :to=\"'home'\">Home</router-link>",
      "",
      "<!-- 同上 -->",
      "<router-link :to=\"{ path: 'home' }\">Home</router-link>",
      "",
      "<!-- 命名的路由 -->",
      "<router-link :to=\"{ name: 'user', params: { userId: 123 }}\">User</router-link>",
      "",
      "<!-- 带查询参数，下面的结果为 /register?plan=private -->",
      "<router-link :to=\"{ path: 'register', query: { plan: 'private' }}\">Register</router-link>",
      "replace",
      "设置 replace 属性的话，当点击时，会调用 router.replace() 而不是 router.push()，导航后不会留下 history 记录。",
      "",
      "<router-link :to=\"{ path: '/abc'}\" replace></router-link>",
      "append",
      "设置 append 属性后，则在当前 (相对) 路径前添加基路径。例如，我们从 /a 导航到一个相对路径 b，如果没有配置 append，则路径为 /b，如果配了，则为 /a/b",
      "",
      "<router-link :to=\"{ path: 'relative/path'}\" append></router-link>",
      "tag",
      "有时候想要 <router-link> 渲染成某种标签，例如 <li>。 于是我们使用 tag prop 类指定何种标签，同样它还是会监听点击，触发导航。",
      "",
      "<router-link to=\"/foo\" tag=\"li\">foo</router-link>",
      "<!-- 渲染结果 -->",
      "<li>foo</li>",
      "active-class",
      "设置 链接激活时使用的 CSS 类名。可以通过以下代码来替代。",
      "",
      "<style>",
      "   ._active{",
      "      background-color : red;",
      "   }",
      "</style>",
      "<p>",
      "   <router-link v-bind:to = \"{ path: '/route1'}\" active-class = \"_active\">Router Link 1</router-link>",
      "   <router-link v-bind:to = \"{ path: '/route2'}\" tag = \"span\">Router Link 2</router-link>",
      "</p>",
      "注意这里 class 使用 active_class=\"_active\"。",
      "",
      "exact-active-class",
      "配置当链接被精确匹配的时候应该激活的 class。可以通过以下代码来替代。",
      "",
      "<p>",
      "   <router-link v-bind:to = \"{ path: '/route1'}\" exact-active-class = \"_active\">Router Link 1</router-link>",
      "   <router-link v-bind:to = \"{ path: '/route2'}\" tag = \"span\">Router Link 2</router-link>",
      "</p>",
      "event",
      "声明可以用来触发导航的事件。可以是一个字符串或是一个包含字符串的数组。",
      "",
      "<router-link v-bind:to = \"{ path: '/route1'}\" event = \"mouseover\">Router Link 1</router-link>",
      "以上代码设置了 event 为 mouseover ，及在鼠标移动到 Router Link 1 上时导航的 HTML 内容会发生改变。",
      "",
      "NPM 路由实例",
      "接下来我们演示了一个使用 npm 简单的路由实例，开始前，请先下载该实例源代码：",
      "",
      "路由实例",
      "你也可以在 Github 上下载：https://github.com/chrisvfritz/vue-2.0-simple-routing-example",
      "",
      "下载完后，解压该目录，重命名目录为 vue-demo，vu 并进入该目录，执行以下命令：",
      "",
      "# 安装依赖，使用淘宝资源命令 cnpm",
      "cnpm install",
      "",
      "# 启动应用，地址为 localhost:8080",
      "cnpm run dev",
      "如果你需要发布到正式环境可以执行以下命令：",
      "",
      "cnpm run build",
      "执行成功后，访问 http://localhost:8080 即可看到如下界面："
    ]
  },
  "vu-Vue.js Ajax(axios)": {
    "prefix": "vu-Vue.js Ajax(axios)",
    "body": [
      "Vue.js 2.0 版本推荐使用 axios 来完成 ajax 请求。",
      "",
      "Axios 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 node.js 中。",
      "",
      "Github开源地址： https://github.com/axios/axios",
      "",
      "安装方法",
      "使用 cdn:",
      "",
      "<script src=\"https://unpkg.com/axios/dist/axios.min.js\"></script>",
      "或",
      "",
      "<script src=\"https://cdn.staticfile.org/axios/0.18.0/axios.min.js\"></script>",
      "使用 npm:",
      "",
      "$ npm install axios",
      "使用 bower:",
      "",
      "$ bower install axios",
      "使用 yarn:",
      "",
      "$ yarn add axios",
      "浏览器支持情况",
      "",
      "",
      "GET 方法",
      "我们可以简单的读取 JSON 数据：",
      "",
      "GET 实例",
      "new Vue({",
      "  el: '#app',",
      "  data () {",
      "    return {",
      "      info: null",
      "    }",
      "  },",
      "  mounted () {",
      "    axios",
      "      .get('https://www.runoob.com/try/ajax/json_demo.json')",
      "      .then(response => (this.info = response))",
      "      .catch(function (error) { // 请求失败处理",
      "        console.log(error);",
      "      });",
      "  }",
      "})",
      "",
      "尝试一下 »",
      "使用 response.data 读取 JSON 数据：",
      "",
      "GET 实例",
      "<div id=\"app\">",
      "  <h1>网站列表</h1>",
      "  <div",
      "    v-for=\"site in info\"",
      "  >",
      "    {{ site.name }}",
      "  </div>",
      "</div>",
      "<script type = \"text/javascript\">",
      "new Vue({",
      "  el: '#app',",
      "  data () {",
      "    return {",
      "      info: null",
      "    }",
      "  },",
      "  mounted () {",
      "    axios",
      "      .get('https://www.runoob.com/try/ajax/json_demo.json')",
      "      .then(response => (this.info = response.data.sites))",
      "      .catch(function (error) { // 请求失败处理",
      "        console.log(error);",
      "      });",
      "  }",
      "})",
      "</script>",
      "",
      "尝试一下 »",
      "GET 方法传递参数格式如下：",
      "",
      "传递参数说明",
      "// 直接在 URL 上添加参数 ID=12345",
      "axios.get('/user?ID=12345')",
      "  .then(function (response) {",
      "    console.log(response);",
      "  })",
      "  .catch(function (error) {",
      "    console.log(error);",
      "  });",
      " ",
      "// 也可以通过 params 设置参数：",
      "axios.get('/user', {",
      "    params: {",
      "      ID: 12345",
      "    }",
      "  })",
      "  .then(function (response) {",
      "    console.log(response);",
      "  })",
      "  .catch(function (error) {",
      "    console.log(error);",
      "  });",
      "POST 方法",
      "POST 实例",
      "new Vue({",
      "  el: '#app',",
      "  data () {",
      "    return {",
      "      info: null",
      "    }",
      "  },",
      "  mounted () {",
      "    axios",
      "      .post('https://www.runoob.com/try/ajax/demo_axios_post.php')",
      "      .then(response => (this.info = response))",
      "      .catch(function (error) { // 请求失败处理",
      "        console.log(error);",
      "      });",
      "  }",
      "})",
      "",
      "尝试一下 »",
      "POST 方法传递参数格式如下：",
      "",
      "传递参数说明",
      "axios.post('/user', {",
      "    firstName: 'Fred',        // 参数 firstName",
      "    lastName: 'Flintstone'    // 参数 lastName",
      "  })",
      "  .then(function (response) {",
      "    console.log(response);",
      "  })",
      "  .catch(function (error) {",
      "    console.log(error);",
      "  });",
      "执行多个并发请求",
      "实例",
      "function getUserAccount() {",
      "  return axios.get('/user/12345');",
      "}",
      " ",
      "function getUserPermissions() {",
      "  return axios.get('/user/12345/permissions');",
      "}",
      "axios.all([getUserAccount(), getUserPermissions()])",
      "  .then(axios.spread(function (acct, perms) {",
      "    // 两个请求现在都执行完成",
      "  }));",
      "axios API",
      "可以通过向 axios 传递相关配置来创建请求。",
      "",
      "实例",
      "axios(config)",
      "// 发送 POST 请求",
      "axios({",
      "  method: 'post',",
      "  url: '/user/12345',",
      "  data: {",
      "    firstName: 'Fred',",
      "    lastName: 'Flintstone'",
      "  }",
      "});",
      "//  GET 请求远程图片",
      "axios({",
      "  method:'get',",
      "  url:'http://bit.ly/2mTM3nY',",
      "  responseType:'stream'",
      "})",
      "  .then(function(response) {",
      "  response.data.pipe(fs.createWriteStream('ada_lovelace.jpg'))",
      "});",
      "axios(url[, config])",
      "// 发送 GET 请求（默认的方法）",
      "axios('/user/12345');",
      "请求方法的别名",
      "为方便使用，官方为所有支持的请求方法提供了别名，可以直接使用别名来发起请求：",
      "",
      "axios.request(config)",
      "axios.get(url[, config])",
      "axios.delete(url[, config])",
      "axios.head(url[, config])",
      "axios.post(url[, data[, config]])",
      "axios.put(url[, data[, config]])",
      "axios.patch(url[, data[, config]])",
      "注意：在使用别名方法时， url、method、data 这些属性都不必在配置中指定。",
      "",
      "并发",
      "处理并发请求的助手函数：",
      "",
      "axios.all(iterable)",
      "axios.spread(callback)",
      "创建实例",
      "可以使用自定义配置新建一个 axios 实例：",
      "",
      "axios.create([config])",
      "const instance = axios.create({",
      "  baseURL: 'https://some-domain.com/api/',",
      "  timeout: 1000,",
      "  headers: {'X-Custom-Header': 'foobar'}",
      "});",
      "实例方法",
      "以下是可用的实例方法。指定的配置将与实例的配置合并：",
      "",
      "axios#request(config)",
      "axios#get(url[, config])",
      "axios#delete(url[, config])",
      "axios#head(url[, config])",
      "axios#post(url[, data[, config]])",
      "axios#put(url[, data[, config]])",
      "axios#patch(url[, data[, config]])",
      "请求配置项",
      "下面是创建请求时可用的配置选项，注意只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。",
      "",
      "{",
      "  // `url` 是用于请求的服务器 URL",
      "  url: \"/user\",",
      "",
      "  // `method` 是创建请求时使用的方法",
      "  method: \"get\", // 默认是 get",
      "",
      "  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。",
      "  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL",
      "  baseURL: \"https://some-domain.com/api/\",",
      "",
      "  // `transformRequest` 允许在向服务器发送前，修改请求数据",
      "  // 只能用在 \"PUT\", \"POST\" 和 \"PATCH\" 这几个请求方法",
      "  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream",
      "  transformRequest: [function (data) {",
      "    // 对 data 进行任意转换处理",
      "",
      "    return data;",
      "  }],",
      "",
      "  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据",
      "  transformResponse: [function (data) {",
      "    // 对 data 进行任意转换处理",
      "",
      "    return data;",
      "  }],",
      "",
      "  // `headers` 是即将被发送的自定义请求头",
      "  headers: {\"X-Requested-With\": \"XMLHttpRequest\"},",
      "",
      "  // `params` 是即将与请求一起发送的 URL 参数",
      "  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象",
      "  params: {",
      "    ID: 12345",
      "  },",
      "",
      "  // `paramsSerializer` 是一个负责 `params` 序列化的函数",
      "  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)",
      "  paramsSerializer: function(params) {",
      "    return Qs.stringify(params, {arrayFormat: \"brackets\"})",
      "  },",
      "",
      "  // `data` 是作为请求主体被发送的数据",
      "  // 只适用于这些请求方法 \"PUT\", \"POST\", 和 \"PATCH\"",
      "  // 在没有设置 `transformRequest` 时，必须是以下类型之一：",
      "  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams",
      "  // - 浏览器专属：FormData, File, Blob",
      "  // - Node 专属： Stream",
      "  data: {",
      "    firstName: \"Fred\"",
      "  },",
      "",
      "  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)",
      "  // 如果请求花费了超过 `timeout` 的时间，请求将被中断",
      "  timeout: 1000,",
      "",
      "  // `withCredentials` 表示跨域请求时是否需要使用凭证",
      "  withCredentials: false, // 默认的",
      "",
      "  // `adapter` 允许自定义处理请求，以使测试更轻松",
      "  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).",
      "  adapter: function (config) {",
      "    /* ... */",
      "  },",
      "",
      "  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据",
      "  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头",
      "  auth: {",
      "    username: \"janedoe\",",
      "    password: \"s00pers3cret\"",
      "  },",
      "",
      "  // `responseType` 表示服务器响应的数据类型，可以是 \"arraybuffer\", \"blob\", \"document\", \"json\", \"text\", \"stream\"",
      "  responseType: \"json\", // 默认的",
      "",
      "  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称",
      "  xsrfCookieName: \"XSRF-TOKEN\", // default",
      "",
      "  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称",
      "  xsrfHeaderName: \"X-XSRF-TOKEN\", // 默认的",
      "",
      "  // `onUploadProgress` 允许为上传处理进度事件",
      "  onUploadProgress: function (progressEvent) {",
      "    // 对原生进度事件的处理",
      "  },",
      "",
      "  // `onDownloadProgress` 允许为下载处理进度事件",
      "  onDownloadProgress: function (progressEvent) {",
      "    // 对原生进度事件的处理",
      "  },",
      "",
      "  // `maxContentLength` 定义允许的响应内容的最大尺寸",
      "  maxContentLength: 2000,",
      "",
      "  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte",
      "  validateStatus: function (status) {",
      "    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的",
      "  },",
      "",
      "  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目",
      "  // 如果设置为0，将不会 follow 任何重定向",
      "  maxRedirects: 5, // 默认的",
      "",
      "  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：",
      "  // `keepAlive` 默认没有启用",
      "  httpAgent: new http.Agent({ keepAlive: true }),",
      "  httpsAgent: new https.Agent({ keepAlive: true }),",
      "",
      "  // \"proxy\" 定义代理服务器的主机名称和端口",
      "  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据",
      "  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。",
      "  proxy: {",
      "    host: \"127.0.0.1\",",
      "    port: 9000,",
      "    auth: : {",
      "      username: \"mikeymike\",",
      "      password: \"rapunz3l\"",
      "    }",
      "  },",
      "",
      "  // `cancelToken` 指定用于取消请求的 cancel token",
      "  // （查看后面的 Cancellation 这节了解更多）",
      "  cancelToken: new CancelToken(function (cancel) {",
      "  })",
      "}",
      "响应结构",
      "axios请求的响应包含以下信息：",
      "",
      "{",
      "  // `data` 由服务器提供的响应",
      "  data: {},",
      "",
      "  // `status`  HTTP 状态码",
      "  status: 200,",
      "",
      "  // `statusText` 来自服务器响应的 HTTP 状态信息",
      "  statusText: \"OK\",",
      "",
      "  // `headers` 服务器响应的头",
      "  headers: {},",
      "",
      "  // `config` 是为请求提供的配置信息",
      "  config: {}",
      "}",
      "使用 then 时，会接收下面这样的响应：",
      "",
      "axios.get(\"/user/12345\")",
      "  .then(function(response) {",
      "    console.log(response.data);",
      "    console.log(response.status);",
      "    console.log(response.statusText);",
      "    console.log(response.headers);",
      "    console.log(response.config);",
      "  });",
      "在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用。",
      "",
      "配置的默认值",
      "你可以指定将被用在各个请求的配置默认值。",
      "",
      "全局的 axios 默认值：",
      "",
      "axios.defaults.baseURL = 'https://api.example.com';",
      "axios.defaults.headers.common['Authorization'] = AUTH_TOKEN;",
      "axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded';",
      "自定义实例默认值：",
      "",
      "// 创建实例时设置配置的默认值",
      "var instance = axios.create({",
      "  baseURL: 'https://api.example.com'",
      "});",
      "",
      "// 在实例已创建后修改默认值",
      "instance.defaults.headers.common['Authorization'] = AUTH_TOKEN;",
      "配置的优先顺序",
      "配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：",
      "",
      "// 使用由库提供的配置的默认值来创建实例",
      "// 此时超时配置的默认值是 `0`",
      "var instance = axios.create();",
      "",
      "// 覆写库的超时默认值",
      "// 现在，在超时前，所有请求都会等待 2.5 秒",
      "instance.defaults.timeout = 2500;",
      "",
      "// 为已知需要花费很长时间的请求覆写超时设置",
      "instance.get('/longRequest', {",
      "  timeout: 5000",
      "});",
      "拦截器",
      "在请求或响应被 then 或 catch 处理前拦截它们。",
      "",
      "// 添加请求拦截器",
      "axios.interceptors.request.use(function (config) {",
      "    // 在发送请求之前做些什么",
      "    return config;",
      "  }, function (error) {",
      "    // 对请求错误做些什么",
      "    return Promise.reject(error);",
      "  });",
      "",
      "// 添加响应拦截器",
      "axios.interceptors.response.use(function (response) {",
      "    // 对响应数据做点什么",
      "    return response;",
      "  }, function (error) {",
      "    // 对响应错误做点什么",
      "    return Promise.reject(error);",
      "  });",
      "如果你想在稍后移除拦截器，可以这样：",
      "",
      "var myInterceptor = axios.interceptors.request.use(function () {/*...*/});",
      "axios.interceptors.request.eject(myInterceptor);",
      "可以为自定义 axios 实例添加拦截器。",
      "",
      "var instance = axios.create();",
      "instance.interceptors.request.use(function () {/*...*/});",
      "错误处理：",
      "",
      "axios.get('/user/12345')",
      "  .catch(function (error) {",
      "    if (error.response) {",
      "      // 请求已发出，但服务器响应的状态码不在 2xx 范围内",
      "      console.log(error.response.data);",
      "      console.log(error.response.status);",
      "      console.log(error.response.headers);",
      "    } else {",
      "      // Something happened in setting up the request that triggered an Error",
      "      console.log('Error', error.message);",
      "    }",
      "    console.log(error.config);",
      "  });",
      "可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。",
      "",
      "axios.get('/user/12345', {",
      "  validateStatus: function (status) {",
      "    return status < 500; // 状态码在大于或等于500时才会 reject",
      "  }",
      "})",
      "取消",
      "使用 cancel token 取消请求。",
      "",
      "Axios 的 cancel token API 基于cancelable promises proposal",
      "",
      "可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：",
      "",
      "var CancelToken = axios.CancelToken;",
      "var source = CancelToken.source();",
      "",
      "axios.get('/user/12345', {",
      "  cancelToken: source.token",
      "}).catch(function(thrown) {",
      "  if (axios.isCancel(thrown)) {",
      "    console.log('Request canceled', thrown.message);",
      "  } else {",
      "    // 处理错误",
      "  }",
      "});",
      "",
      "// 取消请求（message 参数是可选的）",
      "source.cancel('Operation canceled by the user.');",
      "还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：",
      "",
      "var CancelToken = axios.CancelToken;",
      "var cancel;",
      "",
      "axios.get('/user/12345', {",
      "  cancelToken: new CancelToken(function executor(c) {",
      "    // executor 函数接收一个 cancel 函数作为参数",
      "    cancel = c;",
      "  })",
      "});",
      "",
      "// 取消请求",
      "cancel();",
      "注意：可以使用同一个 cancel token 取消多个请求。",
      "",
      "请求时使用 application/x-www-form-urlencoded",
      "axios 会默认序列化 JavaScript 对象为 JSON。 如果想使用 application/x-www-form-urlencoded 格式，你可以使用下面的配置。",
      "",
      "浏览器",
      "",
      "在浏览器环境，你可以使用 URLSearchParams API：",
      "",
      "const params = new URLSearchParams();",
      "params.append('param1', 'value1');",
      "params.append('param2', 'value2');",
      "axios.post('/foo', params);",
      "URLSearchParams 不是所有的浏览器均支持。",
      "",
      "除此之外，你可以使用 qs 库来编码数据:",
      "",
      "const qs = require('qs');",
      "axios.post('/foo', qs.stringify({ 'bar': 123 }));",
      "",
      "// Or in another way (ES6),",
      "",
      "import qs from 'qs';",
      "const data = { 'bar': 123 };",
      "const options = {",
      "  method: 'POST',",
      "  headers: { 'content-type': 'application/x-www-form-urlencoded' },",
      "  data: qs.stringify(data),",
      "  url,",
      "};",
      "axios(options);",
      "Node.js 环境",
      "在 node.js里, 可以使用 querystring 模块:",
      "",
      "const querystring = require('querystring');",
      "axios.post('http://something.com/', querystring.stringify({ foo: 'bar' }));",
      "当然，同浏览器一样，你还可以使用 qs 库。",
      "",
      "Promises",
      "axios 依赖原生的 ES6 Promise 实现而被支持。",
      "",
      "如果你的环境不支持 ES6 Promise，你可以使用 polyfill。",
      "",
      "TypeScript支持",
      "axios 包含 TypeScript 的定义。",
      "",
      "import axios from \"axios\";",
      "axios.get(\"/user?ID=12345\");"
    ]
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  },
  "vu-": {
    "prefix": "vu-",
    "body": []
  }
}
