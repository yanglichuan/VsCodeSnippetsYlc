{
  // Place your snippets for kotlin here. Each snippet is defined under a snippet name and has a prefix, body and
  // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
  // same ids are connected.
  // Example:
  "kt-包的定义与导入": {
    "prefix": "kt-包的定义与导入",
    "body": [
      "package my.demo",
      "",
      "import kotlin.text.*"
    ]
  },
  "kt-程序入口点": {
    "prefix": "kt-程序入口点",
    "body": [
      "fun main() {",
      "    println(\"Hello world!\")",
      "}"
    ]
  },
  "kt-函数": {
    "prefix": "kt-函数",
    "body": [
      "fun printSum(a: Int, b: Int): Unit {",
      "    println(\"sum of $a and $b is ${a + b}\")",
      "}",
      "fun sum(a: Int, b: Int) = a + b",
      "fun sum(a: Int, b: Int): Int {",
      "    return a + b",
      "}"
    ]
  },
  "kt-变量": {
    "prefix": "kt-变量",
    "body": [
      "var x = 5 // 自动推断出 `Int` 类型",
      "x += 1",
      "val a: Int = 1  // 立即赋值",
      "val b = 2   // 自动推断出 `Int` 类型",
      "val c: Int  // 如果没有初始值类型不能省略",
      "c = 3       // 明确赋值"
    ]
  },
  "kt-字符串模板": {
    "prefix": "kt-字符串模板",
    "body": [
      "var a = 1",
      "// 模板中的简单名称：",
      "val s1 = \"a is $a\" ",
      "",
      "a = 2",
      "// 模板中的任意表达式：",
      "val s2 = \"${s1.replace(\"is\", \"was\")}, but now is $a\""
    ]
  },
  "kt-条件表达式": {
    "prefix": "kt-条件表达式",
    "body": [
      "fun maxOf(a: Int, b: Int) = if (a > b) a else b",
      "fun maxOf(a: Int, b: Int): Int {",
      "    if (a > b) {",
      "        return a",
      "    } else {",
      "        return b",
      "    }",
      "}"
    ]
  },
  "kt-空值与 null 检测": {
    "prefix": "kt-空值与 null 检测",
    "body": [
      "// ……",
      "if (x == null) {",
      "    println(\"Wrong number format in arg1: '$arg1'\")",
      "    return",
      "}",
      "if (y == null) {",
      "    println(\"Wrong number format in arg2: '$arg2'\")",
      "    return",
      "}",
      "",
      "// 在空检测后，x 与 y 会自动转换为非空值",
      "println(x * y)"
    ]
  },
  "kt-类型检测与自动类型转换": {
    "prefix": "kt-类型检测与自动类型转换",
    "body": [
      "fun getStringLength(obj: Any): Int? {",
      "    // `obj` 在 `&&` 右边自动转换成 `String` 类型",
      "    if (obj is String && obj.length > 0) {",
      "      return obj.length",
      "    }",
      "",
      "    return null",
      "}",
      "fun getStringLength(obj: Any): Int? {",
      "    if (obj !is String) return null",
      "",
      "    // `obj` 在这一分支自动转换为 `String`",
      "    return obj.length",
      "}",
      "fun getStringLength(obj: Any): Int? {",
      "    if (obj is String) {",
      "        // `obj` 在该条件分支内自动转换成 `String`",
      "        return obj.length",
      "    }",
      "",
      "    // 在离开类型检测分支后，`obj` 仍然是 `Any` 类型",
      "    return null",
      "}"
    ]
  },
  "kt-for 循环": {
    "prefix": "kt-for 循环",
    "body": [
      "val items = listOf(\"apple\", \"banana\", \"kiwifruit\")",
      "for (index in items.indices) {",
      "    println(\"item at $index is ${items[index]}\")",
      "}",
      "val items = listOf(\"apple\", \"banana\", \"kiwifruit\")",
      "for (item in items) {",
      "    println(item)",
      "}"
    ]
  },
  "kt-while 循环": {
    "prefix": "kt-while 循环",
    "body": [
      "val items = listOf(\"apple\", \"banana\", \"kiwifruit\")",
      "var index = 0",
      "while (index < items.size) {",
      "    println(\"item at $index is ${items[index]}\")",
      "    index++",
      "}"
    ]
  },
  "kt-when 表达式": {
    "prefix": "kt-when 表达式",
    "body": [
      "fun describe(obj: Any): String =",
      "    when (obj) {",
      "        1          -> \"One\"",
      "        \"Hello\"    -> \"Greeting\"",
      "        is Long    -> \"Long\"",
      "        !is String -> \"Not a string\"",
      "        else       -> \"Unknown\"",
      "    }"
    ]
  },
  "kt-使用区间（range）": {
    "prefix": "kt-使用区间（range）",
    "body": [
      "val x = 10",
      "val y = 9",
      "if (x in 1..y+1) {",
      "    println(\"fits in range\")",
      "}",
      "val list = listOf(\"a\", \"b\", \"c\")",
      "",
      "if (-1 !in 0..list.lastIndex) {",
      "    println(\"-1 is out of range\")",
      "}",
      "if (list.size !in list.indices) {",
      "    println(\"list size is out of valid list indices range, too\")",
      "}",
      "for (x in 1..5) {",
      "    print(x)",
      "}",
      "for (x in 1..10 step 2) {",
      "    print(x)",
      "}",
      "println()",
      "for (x in 9 downTo 0 step 3) {",
      "    print(x)",
      "}"
    ]
  },
  "kt-集合": {
    "prefix": "kt-集合",
    "body": [
      "val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")",
      "fruits",
      "  .filter { it.startsWith(\"a\") }",
      "  .sortedBy { it }",
      "  .map { it.toUpperCase() }",
      "  .forEach { println(it) }",
      "when {",
      "    \"orange\" in items -> println(\"juicy\")",
      "    \"apple\" in items -> println(\"apple is fine too\")",
      "}",
      "for (item in items) {",
      "    println(item)",
      "}"
    ]
  },
  "kt-dataclass": {
    "prefix": "kt-dataclass",
    "body": [
      "data class Customer(val name: String, val email: String)"
    ]
  },
  "kt-函数的默认参数": {
    "prefix": "kt-函数的默认参数",
    "body": [
      "fun foo(a: Int = 0, b: String = \"\") { …… }"
    ]
  },
  "kt-过滤 list": {
    "prefix": "kt-过滤 list",
    "body": [
      "val positives = list.filter { it > 0 }",
      "val positives = list.filter { x -> x > 0 }"
    ]
  },
  "kt-检测元素是否存在于集合中": {
    "prefix": "kt-检测元素是否存在于集合中",
    "body": [
      "if (\"john@example.com\" in emailsList) { …… }",
      "",
      "if (\"jane@example.com\" !in emailsList) { …… }"
    ]
  },
  "kt-类型判断": {
    "prefix": "kt-类型判断",
    "body": [
      "when (x) {",
      "    is Foo //-> ……",
      "    is Bar //-> ……",
      "    else   //-> ……",
      "}"
    ]
  },
  "kt-遍历 map/pair型list": {
    "prefix": "kt-遍历 map/pair型list",
    "body": [
      "for ((k, v) in map) {",
      "    println(\"$k -> $v\")",
      "}",
      "k、v 可以改成任意名字"
    ]
  },
  "kt-使用区间": {
    "prefix": "kt-使用区间",
    "body": [
      "for (i in 1..100) { …… }  // 闭区间：包含 100",
      "for (i in 1 until 100) { …… } // 半开区间：不包含 100",
      "for (x in 2..10 step 2) { …… }",
      "for (x in 10 downTo 1) { …… }",
      "if (x in 1..10) { …… }"
    ]
  },
  "kt-只读 list": {
    "prefix": "kt-只读 list",
    "body": [
      "val list = listOf(\"a\", \"b\", \"c\")"
    ]
  },
  "kt-只读 map": {
    "prefix": "kt-只读 map",
    "body": [
      "val map = mapOf(\"a\" to 1, \"b\" to 2, \"c\" to 3)"
    ]
  },
  "kt-访问 map": {
    "prefix": "kt-访问 map",
    "body": [
      "println(map[\"key\"])",
      "map[\"key\"] = value"
    ]
  },
  "kt-延迟属性": {
    "prefix": "kt-延迟属性",
    "body": [
      "val p: String by lazy {",
      "    // 计算该字符串",
      "}"
    ]
  },
  "kt-扩展函数": {
    "prefix": "kt-扩展函数",
    "body": [
      "fun String.spaceToCamelCase() { …… }",
      "",
      "\"Convert this to camelcase\".spaceToCamelCase()"
    ]
  },
  "kt-创建单例": {
    "prefix": "kt-创建单例",
    "body": [
      "object Resource {",
      "    val name = \"Name\"",
      "}"
    ]
  },
  "kt-If not null 缩写": {
    "prefix": "kt-If not null 缩写",
    "body": [
      "val files = File(\"Test\").listFiles()",
      "",
      "println(files?.size)"
    ]
  },
  "kt-if null 执行一个语句": {
    "prefix": "kt-if null 执行一个语句",
    "body": [
      "val values = ……",
      "val email = values[\"email\"] ?: throw IllegalStateException(\"Email is missing!\")"
    ]
  },
  "kt-在可能会空的集合中取第一元素": {
    "prefix": "kt-在可能会空的集合中取第一元素",
    "body": [
      "val emails = …… // 可能会是空集合",
      "val mainEmail = emails.firstOrNull() ?: \"\""
    ]
  },
  "kt-返回 when 表达式": {
    "prefix": "kt-返回 when 表达式",
    "body": [
      "fun transform(color: String): Int {",
      "    return when (color) {",
      "        \"Red\" -> 0",
      "        \"Green\" -> 1",
      "        \"Blue\" -> 2",
      "        else -> throw IllegalArgumentException(\"Invalid color param value\")",
      "    }",
      "}"
    ]
  },
  "kt-“try/catch”表达式": {
    "prefix": "kt-“try/catch”表达式",
    "body": [
      "fun test() {",
      "    val result = try {",
      "        count()",
      "    } catch (e: ArithmeticException) {",
      "        throw IllegalStateException(e)",
      "    }",
      "",
      "    // 使用 result",
      "}"
    ]
  },
  "kt-“if”表达式": {
    "prefix": "kt-“if”表达式",
    "body": [
      "fun foo(param: Int) {",
      "    val result = if (param == 1) {",
      "        \"one\"",
      "    } else if (param == 2) {",
      "        \"two\"",
      "    } else {",
      "        \"three\"",
      "    }",
      "}"
    ]
  },
  "kt-单表达式函数": {
    "prefix": "kt-单表达式函数",
    "body": [
      "fun transform(color: String): Int = when (color) {",
      "    \"Red\" -> 0",
      "    \"Green\" -> 1",
      "    \"Blue\" -> 2",
      "    else -> throw IllegalArgumentException(\"Invalid color param value\")",
      "}",
      "fun theAnswer() = 42"
    ]
  },
  "kt-对一个对象实例调用多个方法 （with）": {
    "prefix": "kt-对一个对象实例调用多个方法 （with）",
    "body": [
      "class Turtle {",
      "    fun penDown()",
      "    fun penUp()",
      "    fun turn(degrees: Double)",
      "    fun forward(pixels: Double)",
      "}",
      "",
      "val myTurtle = Turtle()",
      "with(myTurtle) { // 画一个 100 像素的正方形",
      "    penDown()",
      "    for (i in 1..4) {",
      "        forward(100.0)",
      "        turn(90.0)",
      "    }",
      "    penUp()",
      "}"
    ]
  },
  "kt-配置对象的属性（apply）": {
    "prefix": "kt-配置对象的属性（apply）",
    "body": [
      "val myRectangle = Rectangle().apply {",
      "    length = 4",
      "    breadth = 5",
      "    color = 0xFAFAFA",
      "}"
    ]
  },
  "kt-使用可空布尔": {
    "prefix": "kt-使用可空布尔",
    "body": [
      "val b: Boolean? = ……",
      "if (b == true) {",
      "    ……",
      "} else {",
      "    // `b` 是 false 或者 null",
      "}"
    ]
  },
  "kt-交换两个变量": {
    "prefix": "kt-交换两个变量",
    "body": [
      "var a = 1",
      "var b = 2",
      "a = b.also { b = a }"
    ]
  },
  "kt-数字": {
    "prefix": "kt-数字",
    "body": [
      "val one = 1 // Int",
      "val threeBillion = 3000000000 // Long",
      "val oneLong = 1L // Long",
      "val oneByte: Byte = 1",
      "val pi = 3.14 // Double",
      "val e = 2.7182818284 // Double",
      "val eFloat = 2.7182818284f // Float，实际值为 2.7182817"
    ]
  },
  "kt- 不支持八进制": {
    "prefix": "kt- 不支持八进制",
    "body": [
      "数值常量字面值有以下几种:",
      "",
      "十进制: 123",
      "Long 类型用大写 L 标记: 123L",
      "十六进制: 0x0F",
      "二进制: 0b00001011",
      "注意: 不支持八进制",
      "",
      "Kotlin 同样支持浮点数的常规表示方法:",
      "",
      "默认 double：123.5、123.5e10",
      "Float 用 f 或者 F 标记: 123.5f"
    ]
  },
  "kt-数字字面值中的下划线（自 1.1 起）": {
    "prefix": "kt-数字字面值中的下划线（自 1.1 起）",
    "body": [
      "val oneMillion = 1_000_000",
      "val creditCardNumber = 1234_5678_9012_3456L",
      "val socialSecurityNumber = 999_99_9999L",
      "val hexBytes = 0xFF_EC_DE_5E",
      "val bytes = 0b11010010_01101001_10010100_10010010"
    ]
  },
  "kt-注意数字装箱不一定保留同一性:": {
    "prefix": "kt-数字装箱不一定保留同一性",
    "body": [
      "val a: Int = 100",
      "val boxedA: Int? = a",
      "val anotherBoxedA: Int? = a",
      "",
      "val b: Int = 10000",
      "val boxedB: Int? = b",
      "val anotherBoxedB: Int? = b",
      "",
      "println(boxedA === anotherBoxedA) // true",
      "println(boxedB === anotherBoxedB) // false",
      "另一方面，它保留了相等性:",
      "val a: Int = 10000",
      "println(a == a) // 输出“true”",
      "val boxedA: Int? = a",
      "val anotherBoxedA: Int? = a",
      "println(boxedA == anotherBoxedA) // 输出“true”"
    ]
  },
  "kt-转换": {
    "prefix": "kt-转换",
    "body": [
      "toByte(): Byte",
      "toShort(): Short",
      "toInt(): Int",
      "toLong(): Long",
      "toFloat(): Float",
      "toDouble(): Double",
      "toChar(): Char"
    ]
  },
  "kt-位运算": {
    "prefix": "kt-位运算",
    "body": [
      "shl(bits) – 有符号左移",
      "shr(bits) – 有符号右移",
      "ushr(bits) – 无符号右移",
      "and(bits) – 位与",
      "or(bits) – 位或",
      "xor(bits) – 位异或",
      "inv() – 位非",
      "val x = (1 shl 2) and 0x000FF000"
    ]
  },
  "kt-字符": {
    "prefix": "kt-字符",
    "body": [
      "fun decimalDigitValue(c: Char): Int {",
      "    if (c !in '0'..'9')",
      "        throw IllegalArgumentException(\"Out of range\")",
      "    return c.toInt() - '0'.toInt() // 显式转换为数字",
      "}"
    ]
  },
  "kt-原生类型数组array": {
    "prefix": "kt-原生类型数组array",
    "body": [
      "val x: IntArray = intArrayOf(1, 2, 3)",
      "x[0] = x[1] + x[2]",
      "// 大小为 5、值为 [0, 0, 0, 0, 0] 的整型数组",
      "val arr = IntArray(5)",
      "",
      "// 例如：用常量初始化数组中的值",
      "// 大小为 5、值为 [42, 42, 42, 42, 42] 的整型数组",
      "val arr = IntArray(5) { 42 }",
      "",
      "// 例如：使用 lambda 表达式初始化数组中的值",
      "// 大小为 5、值为 [0, 1, 2, 3, 4] 的整型数组（值初始化为其索引值）",
      "var arr = IntArray(5) { it * 1 }"
    ]
  },
  "kt-无符号整型": {
    "prefix": "kt-无符号整型",
    "body": [
      "kotlin.UByte: 无符号 8 比特整数，范围是 0 到 255",
      "kotlin.UShort: 无符号 16 比特整数，范围是 0 到 65535",
      "kotlin.UInt: 无符号 32 比特整数，范围是 0 到 2^32 - 1",
      "kotlin.ULong: 无符号 64 比特整数，范围是 0 到 2^64 - 1"
    ]
  },
  "kt-字符串": {
    "prefix": "kt-字符串",
    "body": [
      "原始字符串 使用三个引号（\"\"\"）分界符括起来，内部没有转义并且可以包含换行以及任何其他字符:"
    ]
  },
  "kt-导入": {
    "prefix": "kt-导入",
    "body": [
      "除了默认导入之外，每个文件可以包含它自己的导入指令。 导入语法在语法中讲述。",
      "",
      "可以导入一个单独的名字，如.",
      "",
      "import org.example.Message // 现在 Message 可以不用限定符访问",
      "也可以导入一个作用域下的所有内容（包、类、对象等）:",
      "",
      "import org.example.* // “org.example”中的一切都可访问",
      "如果出现名字冲突，可以使用 as 关键字在本地重命名冲突项来消歧义：",
      "",
      "import org.example.Message // Message 可访问",
      "import org.test.Message as testMessage // testMessage 代表“org.test.Message”",
      "关键字 import 并不仅限于导入类；也可用它来导入其他声明："
    ]
  },
  "kt-If 表达式": {
    "prefix": "kt-If 表达式",
    "body": [
      "val max = if (a > b) {",
      "    print(\"Choose a\")",
      "    a",
      "} else {",
      "    print(\"Choose b\")",
      "    b",
      "}",
      "// 传统用法",
      "var max = a ",
      "if (a < b) max = b",
      "",
      "// With else ",
      "var max: Int",
      "if (a > b) {",
      "    max = a",
      "} else {",
      "    max = b",
      "}",
      " ",
      "// 作为表达式",
      "val max = if (a > b) a else b"
    ]
  },
  "kt-When 表达式": {
    "prefix": "kt-When 表达式",
    "body": [
      "when (x) {",
      "    1 -> print(\"x == 1\")",
      "    2 -> print(\"x == 2\")",
      "    else -> { // 注意这个块",
      "        print(\"x is neither 1 nor 2\")",
      "    }",
      "}",
      "when (x) {",
      "    0, 1 -> print(\"x == 0 or x == 1\")",
      "    else -> print(\"otherwise\")",
      "}",
      "when (x) {",
      "    parseInt(s) -> print(\"s encodes x\")",
      "    else -> print(\"s does not encode x\")",
      "}",
      "when (x) {",
      "    in 1..10 -> print(\"x is in the range\")",
      "    in validNumbers -> print(\"x is valid\")",
      "    !in 10..20 -> print(\"x is outside the range\")",
      "    else -> print(\"none of the above\")",
      "}",
      "fun hasPrefix(x: Any) = when(x) {",
      "    is String -> x.startsWith(\"prefix\")",
      "    else -> false",
      "}",
      "when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：",
      "when {",
      "    x.isOdd() -> print(\"x is odd\")",
      "    y.isEven() -> print(\"y is even\")",
      "    else -> print(\"x+y is even.\")",
      "}",
      "自 Kotlin 1.3 起，可以使用以下语法将 when 的主语（subject，译注：指 when 所判断的表达式）捕获到变量中：",
      "fun Request.getBody() =",
      "        when (val response = executeRequest()) {",
      "            is Success -> response.body",
      "            is HttpError -> throw HttpException(response.status)",
      "        }"
    ]
  },
  "kt-For 循环": {
    "prefix": "kt-For 循环",
    "body": [
      " 改进翻译",
      "控制流：if、when、for、while",
      "If 表达式",
      "在 Kotlin 中，if是一个表达式，即它会返回一个值。 因此就不需要三元运算符（条件 ? 然后 : 否则），因为普通的 if 就能胜任这个角色。",
      "",
      "// 传统用法",
      "var max = a ",
      "if (a < b) max = b",
      "",
      "// With else ",
      "var max: Int",
      "if (a > b) {",
      "    max = a",
      "} else {",
      "    max = b",
      "}",
      " ",
      "// 作为表达式",
      "val max = if (a > b) a else b",
      "// 传统用法",
      "var max = a ",
      "if (a < b) max = b",
      "​",
      "// With else ",
      "var max: Int",
      "if (a > b) {",
      "    max = a",
      "} else {",
      "    max = b",
      "}",
      " ",
      "// 作为表达式",
      "val max = if (a > b) a else b",
      "if 的分支可以是代码块，最后的表达式作为该块的值：",
      "",
      "val max = if (a > b) {",
      "    print(\"Choose a\")",
      "    a",
      "} else {",
      "    print(\"Choose b\")",
      "    b",
      "}",
      "val max = if (a > b) {",
      "    print(\"Choose a\")",
      "    a",
      "} else {",
      "    print(\"Choose b\")",
      "    b",
      "}",
      "如果你使用 if 作为表达式而不是语句（例如：返回它的值或者把它赋给变量），该表达式需要有 else 分支。",
      "",
      "参见 if 语法。",
      "",
      "When 表达式",
      "when 取代了类 C 语言的 switch 操作符。其最简单的形式如下：",
      "",
      "when (x) {",
      "    1 -> print(\"x == 1\")",
      "    2 -> print(\"x == 2\")",
      "    else -> { // 注意这个块",
      "        print(\"x is neither 1 nor 2\")",
      "    }",
      "}",
      "when (x) {",
      "    1 -> print(\"x == 1\")",
      "    2 -> print(\"x == 2\")",
      "    else -> { // 注意这个块",
      "        print(\"x is neither 1 nor 2\")",
      "    }",
      "}",
      "when 将它的参数与所有的分支条件顺序比较，直到某个分支满足条件。 when 既可以被当做表达式使用也可以被当做语句使用。如果它被当做表达式， 符合条件的分支的值就是整个表达式的值，如果当做语句使用， 则忽略个别分支的值。（像 if 一样，每一个分支可以是一个代码块，它的值是块中最后的表达式的值。）",
      "",
      "如果其他分支都不满足条件将会求值 else 分支。 如果 when 作为一个表达式使用，则必须有 else 分支， 除非编译器能够检测出所有的可能情况都已经覆盖了［例如，对于 枚举（enum）类条目与密封（sealed）类子类型］。",
      "",
      "如果很多分支需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号分隔：",
      "",
      "when (x) {",
      "    0, 1 -> print(\"x == 0 or x == 1\")",
      "    else -> print(\"otherwise\")",
      "}",
      "when (x) {",
      "    0, 1 -> print(\"x == 0 or x == 1\")",
      "    else -> print(\"otherwise\")",
      "}",
      "我们可以用任意表达式（而不只是常量）作为分支条件",
      "",
      "when (x) {",
      "    parseInt(s) -> print(\"s encodes x\")",
      "    else -> print(\"s does not encode x\")",
      "}",
      "when (x) {",
      "    parseInt(s) -> print(\"s encodes x\")",
      "    else -> print(\"s does not encode x\")",
      "}",
      "我们也可以检测一个值在（in）或者不在（!in）一个区间或者集合中：",
      "",
      "when (x) {",
      "    in 1..10 -> print(\"x is in the range\")",
      "    in validNumbers -> print(\"x is valid\")",
      "    !in 10..20 -> print(\"x is outside the range\")",
      "    else -> print(\"none of the above\")",
      "}",
      "when (x) {",
      "    in 1..10 -> print(\"x is in the range\")",
      "    in validNumbers -> print(\"x is valid\")",
      "    !in 10..20 -> print(\"x is outside the range\")",
      "    else -> print(\"none of the above\")",
      "}",
      "另一种可能性是检测一个值是（is）或者不是（!is）一个特定类型的值。注意： 由于智能转换，你可以访问该类型的方法与属性而无需任何额外的检测。",
      "",
      "fun hasPrefix(x: Any) = when(x) {",
      "    is String -> x.startsWith(\"prefix\")",
      "    else -> false",
      "}",
      "fun hasPrefix(x: Any) = when(x) {",
      "    is String -> x.startsWith(\"prefix\")",
      "    else -> false",
      "}",
      "when 也可以用来取代 if-else if链。 如果不提供参数，所有的分支条件都是简单的布尔表达式，而当一个分支的条件为真时则执行该分支：",
      "",
      "when {",
      "    x.isOdd() -> print(\"x is odd\")",
      "    y.isEven() -> print(\"y is even\")",
      "    else -> print(\"x+y is even.\")",
      "}",
      "when {",
      "    x.isOdd() -> print(\"x is odd\")",
      "    y.isEven() -> print(\"y is even\")",
      "    else -> print(\"x+y is even.\")",
      "}",
      "自 Kotlin 1.3 起，可以使用以下语法将 when 的主语（subject，译注：指 when 所判断的表达式）捕获到变量中：",
      "",
      "fun Request.getBody() =",
      "        when (val response = executeRequest()) {",
      "            is Success -> response.body",
      "            is HttpError -> throw HttpException(response.status)",
      "        }",
      "fun Request.getBody() =",
      "        when (val response = executeRequest()) {",
      "            is Success -> response.body",
      "            is HttpError -> throw HttpException(response.status)",
      "        }",
      "在 when 主语中引入的变量的作用域仅限于 when 主体。",
      "",
      "参见 when 语法。",
      "",
      "For 循环",
      "for 循环可以对任何提供迭代器（iterator）的对象进行遍历，这相当于像 C# 这样的语言中的 foreach 循环。语法如下：",
      "",
      "for (item in collection) print(item)",
      "for (item in collection) print(item)",
      "循环体可以是一个代码块。",
      "",
      "}",
      "for (item: Int in ints) {",
      "    // ……",
      "}",
      "如上所述，for 可以循环遍历任何提供了迭代器的对象。即：",
      "",
      "有一个成员函数或者扩展函数 iterator()，它的返回类型",
      "有一个成员函数或者扩展函数 next()，并且",
      "有一个成员函数或者扩展函数 hasNext() 返回 Boolean。",
      "这三个函数都需要标记为 operator。",
      "",
      "如需在数字区间上迭代，请使用区间表达式:",
      "",
      "for (i in 1..3) {",
      "    println(i)",
      "}",
      "for (i in 6 downTo 0 step 2) {",
      "    println(i)",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "对区间或者数组的 for 循环会被编译为并不创建迭代器的基于索引的循环。",
      "",
      "如果你想要通过索引遍历一个数组或者一个 list，你可以这么做：",
      "",
      "for (i in array.indices) {",
      "    println(array[i])",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "或者你可以用库函数 withIndex：",
      "",
      "for ((index, value) in array.withIndex()) {",
      "    println(\"the element at $index is $value\")",
      "}"
    ]
  },
  "kt-while 与 do..while 照常使用": {
    "prefix": "kt-while 与 do..while 照常使用",
    "body": [
      "while 与 do..while 照常使用",
      "",
      "while (x > 0) {",
      "    x--",
      "}",
      "​",
      "do {",
      "  val y = retrieveData()",
      "} while (y != null) // y 在此处可见"
    ]
  },
  "kt-Break 与 Continue 标签": {
    "prefix": "kt-Break 与 Continue 标签",
    "body": [
      "在 Kotlin 中任何表达式都可以用标签（label）来标记。 标签的格式为标识符后跟 @ 符号，例如：abc@、fooBar@都是有效的标签（参见语法）。 要为一个表达式加标签，我们只要在其前加标签即可。",
      "",
      "loop@ for (i in 1..100) {",
      "    // ……",
      "}",
      "现在，我们可以用标签限制 break 或者continue：",
      "",
      "loop@ for (i in 1..100) {",
      "    for (j in 1..100) {",
      "        if (……) break@loop",
      "    }",
      "}",
      "Kotlin 有函数字面量、局部函数和对象表达式。因此 Kotlin 的函数可以被嵌套。 标签限制的 return 允许我们从外层函数返回。 最重要的一个用途就是从 lambda 表达式中返回。回想一下我们这么写的时候：",
      "",
      "fun foo() {",
      "    listOf(1, 2, 3, 4, 5).forEach {",
      "        if (it == 3) return // 非局部直接返回到 foo() 的调用者",
      "        print(it)",
      "    }",
      "    println(\"this point is unreachable\")",
      "}",
      "fun foo() {",
      "    listOf(1, 2, 3, 4, 5).forEach {",
      "        if (it == 3) return // 非局部直接返回到 foo() 的调用者",
      "        print(it)",
      "    }",
      "    println(\"this point is unreachable\")",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这个 return 表达式从最直接包围它的函数即 foo 中返回。 （注意，这种非局部的返回只支持传给内联函数的 lambda 表达式。） 如果我们需要从 lambda 表达式中返回，我们必须给它加标签并用以限制 return。",
      "",
      "fun foo() {",
      "    listOf(1, 2, 3, 4, 5).forEach lit@{",
      "        if (it == 3) return@lit // 局部返回到该 lambda 表达式的调用者，即 forEach 循环",
      "        print(it)",
      "    }",
      "    print(\" done with explicit label\")",
      "}"
    ]
  },
  "kt-类": {
    "prefix": "kt-类",
    "body": [
      "Kotlin 中使用关键字 class 声明类",
      "",
      "class Invoice { /*……*/ }",
      "类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。",
      "",
      "class Empty",
      "构造函数",
      "在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。",
      "",
      "class Person constructor(firstName: String) { /*……*/ }",
      "如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。",
      "",
      "class Person(firstName: String) { /*……*/ }",
      "主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。",
      "在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：",
      "",
      "class InitOrderDemo(name: String) {",
      "    val firstProperty = \"First property: $name\".also(::println)",
      "    ",
      "    init {",
      "        println(\"First initializer block that prints ${name}\")",
      "    }",
      "    ",
      "    val secondProperty = \"Second property: ${name.length}\".also(::println)",
      "    ",
      "    init {",
      "        println(\"Second initializer block that prints ${name.length}\")",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "请注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：",
      "",
      "class Customer(name: String) {",
      "",
      "class Customer(name: String) {",
      "    val customerKey = name.toUpperCase()",
      "}",
      "事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：",
      "",
      "class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }",
      "class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }",
      "与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。",
      "",
      "如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：",
      "",
      "class Customer public @Inject constructor(name: String) { /*……*/ }",
      "val fruits = listOf(\"banana\", \"avocado\", \"apple\", \"kiwifruit\")",
      "类也可以声明前缀有 constructor的次构造函数：",
      "",
      "class Person {",
      "    var children: MutableList<Person> = mutableListOf<>()",
      "    constructor(parent: Person) {",
      "        parent.children.add(this)",
      "    }",
      "}",
      "如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：",
      "",
      "class Person(val name: String) {",
      "    var children: MutableList<Person> = mutableListOf<>()",
      "    constructor(name: String, parent: Person) : this(name) {",
      "        parent.children.add(this)",
      "    }",
      "}",
      "请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：",
      "",
      "class Constructors {",
      "    init {",
      "        println(\"Init block\")",
      "    }",
      "​",
      "    constructor(i: Int) {",
      "        println(\"Constructor\")",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：",
      "",
      "class DontCreateMe private constructor () { /*……*/ }",
      "注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。",
      "",
      "class Customer(val customerName: String = \"\")",
      "class Customer(val customerName: String = \"\")"
    ]
  },
  "kt-继承": {
    "prefix": "kt-继承",
    "body": [
      " 改进翻译",
      "类与继承",
      "类",
      "Kotlin 中使用关键字 class 声明类",
      "",
      "class Invoice { /*……*/ }",
      "类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。",
      "",
      "class Empty",
      "构造函数",
      "在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。",
      "",
      "class Person constructor(firstName: String) { /*……*/ }",
      "如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。",
      "",
      "class Person(firstName: String) { /*……*/ }",
      "主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。",
      "",
      "在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：",
      "",
      "class InitOrderDemo(name: String) {",
      "    val firstProperty = \"First property: $name\".also(::println)",
      "    ",
      "    init {",
      "        println(\"First initializer block that prints ${name}\")",
      "    }",
      "    ",
      "    val secondProperty = \"Second property: ${name.length}\".also(::println)",
      "    ",
      "    init {",
      "        println(\"Second initializer block that prints ${name.length}\")",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "请注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：",
      "",
      "class Customer(name: String) {",
      "",
      "class Customer(name: String) {",
      "    val customerKey = name.toUpperCase()",
      "}",
      "事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：",
      "",
      "class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }",
      "class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }",
      "与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。",
      "",
      "如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：",
      "",
      "class Customer public @Inject constructor(name: String) { /*……*/ }",
      "更多详情，参见可见性修饰符",
      "",
      "次构造函数",
      "类也可以声明前缀有 constructor的次构造函数：",
      "",
      "class Person {",
      "    var children: MutableList<Person> = mutableListOf<>()",
      "    constructor(parent: Person) {",
      "        parent.children.add(this)",
      "    }",
      "}",
      "如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：",
      "",
      "class Person(val name: String) {",
      "    var children: MutableList<Person> = mutableListOf<>()",
      "    constructor(name: String, parent: Person) : this(name) {",
      "        parent.children.add(this)",
      "    }",
      "}",
      "请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：",
      "",
      "class Constructors {",
      "    init {",
      "        println(\"Init block\")",
      "    }",
      "​",
      "    constructor(i: Int) {",
      "        println(\"Constructor\")",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：",
      "",
      "class DontCreateMe private constructor () { /*……*/ }",
      "注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。",
      "",
      "class Customer(val customerName: String = \"\")",
      "class Customer(val customerName: String = \"\")",
      "创建类的实例",
      "要创建一个类的实例，我们就像普通函数一样调用构造函数：",
      "",
      "val invoice = Invoice()",
      "​",
      "val customer = Customer(\"Joe Smith\")",
      "注意 Kotlin 并没有 new 关键字。",
      "",
      "创建嵌套类、内部类与匿名内部类的类实例在嵌套类中有述。",
      "",
      "类成员",
      "类可以包含：",
      "",
      "构造函数与初始化块",
      "函数",
      "属性",
      "嵌套类与内部类",
      "对象声明",
      "继承",
      "在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类：",
      "",
      "class Example // 从 Any 隐式继承",
      "Any 有三个方法：equals()、 hashCode() 与 toString()。因此，为所有 Kotlin 类都定义了这些方法。",
      "",
      "默认情况下，Kotlin 类是最终（final）的：它们不能被继承。 要使一个类可继承，请用 open 关键字标记它。",
      "",
      "open class Base // 该类开放继承",
      "如需声明一个显式的超类型，请在类头中把超类型放到冒号之后：",
      "",
      "open class Base(p: Int)",
      "​",
      "class Derived(p: Int) : Base(p)",
      "如果派生类有一个主构造函数，其基类可以（并且必须） 用派生类主构造函数的参数就地初始化。",
      "",
      "如果派生类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：",
      "",
      "class MyView : View {",
      "    constructor(ctx: Context) : super(ctx)",
      "​",
      "    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)",
      "}"
    ]
  },
  "kt-覆盖方法": {
    "prefix": "kt-覆盖方法",
    "body": [
      "我们之前提到过，Kotlin 力求清晰显式。因此，Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：",
      "",
      "open class Shape {",
      "    open fun draw() { /*……*/ }",
      "    fun fill() { /*……*/ }",
      "}",
      "​",
      "class Circle() : Shape() {",
      "    override fun draw() { /*……*/ }",
      "}",
      "Circle.draw() 函数上必须加上 override 修饰符。如果没写，编译器将会报错。 如果函数没有标注 open 如 Shape.fill()，那么子类中不允许定义相同签名的函数， 不论加不加 override。将 open 修饰符添加到 final 类（即没有 open 的类）的成员上不起作用。",
      "",
      "标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：",
      "",
      "open class Rectangle() : Shape() {",
      "    final override fun draw() { /*……*/ }",
      "}",
      "open class Rectangle() : Shape() {",
      "    final override fun draw() { /*……*/ }",
      "}"
    ]
  },
  "kt-覆盖属性": {
    "prefix": "kt-覆盖属性",
    "body": [
      " 改进翻译",
      "类与继承",
      "类",
      "Kotlin 中使用关键字 class 声明类",
      "",
      "class Invoice { /*……*/ }",
      "类声明由类名、类头（指定其类型参数、主构造函数等）以及由花括号包围的类体构成。类头与类体都是可选的； 如果一个类没有类体，可以省略花括号。",
      "",
      "class Empty",
      "构造函数",
      "在 Kotlin 中的一个类可以有一个主构造函数以及一个或多个次构造函数。主构造函数是类头的一部分：它跟在类名（与可选的类型参数）后。",
      "",
      "class Person constructor(firstName: String) { /*……*/ }",
      "如果主构造函数没有任何注解或者可见性修饰符，可以省略这个 constructor 关键字。",
      "",
      "class Person(firstName: String) { /*……*/ }",
      "主构造函数不能包含任何的代码。初始化的代码可以放到以 init 关键字作为前缀的初始化块（initializer blocks）中。",
      "",
      "在实例初始化期间，初始化块按照它们出现在类体中的顺序执行，与属性初始化器交织在一起：",
      "",
      "class InitOrderDemo(name: String) {",
      "    val firstProperty = \"First property: $name\".also(::println)",
      "    ",
      "    init {",
      "        println(\"First initializer block that prints ${name}\")",
      "    }",
      "    ",
      "    val secondProperty = \"Second property: ${name.length}\".also(::println)",
      "    ",
      "    init {",
      "        println(\"Second initializer block that prints ${name.length}\")",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "请注意，主构造的参数可以在初始化块中使用。它们也可以在类体内声明的属性初始化器中使用：",
      "",
      "class Customer(name: String) {",
      "",
      "class Customer(name: String) {",
      "    val customerKey = name.toUpperCase()",
      "}",
      "事实上，声明属性以及从主构造函数初始化属性，Kotlin 有简洁的语法：",
      "",
      "class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }",
      "class Person(val firstName: String, val lastName: String, var age: Int) { /*……*/ }",
      "与普通属性一样，主构造函数中声明的属性可以是可变的（var）或只读的（val）。",
      "",
      "如果构造函数有注解或可见性修饰符，这个 constructor 关键字是必需的，并且这些修饰符在它前面：",
      "",
      "class Customer public @Inject constructor(name: String) { /*……*/ }",
      "更多详情，参见可见性修饰符",
      "",
      "次构造函数",
      "类也可以声明前缀有 constructor的次构造函数：",
      "",
      "class Person {",
      "    var children: MutableList<Person> = mutableListOf<>()",
      "    constructor(parent: Person) {",
      "        parent.children.add(this)",
      "    }",
      "}",
      "如果类有一个主构造函数，每个次构造函数需要委托给主构造函数， 可以直接委托或者通过别的次构造函数间接委托。委托到同一个类的另一个构造函数用 this 关键字即可：",
      "",
      "class Person(val name: String) {",
      "    var children: MutableList<Person> = mutableListOf<>()",
      "    constructor(name: String, parent: Person) : this(name) {",
      "        parent.children.add(this)",
      "    }",
      "}",
      "请注意，初始化块中的代码实际上会成为主构造函数的一部分。委托给主构造函数会作为次构造函数的第一条语句，因此所有初始化块与属性初始化器中的代码都会在次构造函数体之前执行。即使该类没有主构造函数，这种委托仍会隐式发生，并且仍会执行初始化块：",
      "",
      "class Constructors {",
      "    init {",
      "        println(\"Init block\")",
      "    }",
      "​",
      "    constructor(i: Int) {",
      "        println(\"Constructor\")",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果一个非抽象类没有声明任何（主或次）构造函数，它会有一个生成的不带参数的主构造函数。构造函数的可见性是 public。如果你不希望你的类有一个公有构造函数，你需要声明一个带有非默认可见性的空的主构造函数：",
      "",
      "class DontCreateMe private constructor () { /*……*/ }",
      "注意：在 JVM 上，如果主构造函数的所有的参数都有默认值，编译器会生成 一个额外的无参构造函数，它将使用默认值。这使得 Kotlin 更易于使用像 Jackson 或者 JPA 这样的通过无参构造函数创建类的实例的库。",
      "",
      "class Customer(val customerName: String = \"\")",
      "class Customer(val customerName: String = \"\")",
      "创建类的实例",
      "要创建一个类的实例，我们就像普通函数一样调用构造函数：",
      "",
      "val invoice = Invoice()",
      "​",
      "val customer = Customer(\"Joe Smith\")",
      "注意 Kotlin 并没有 new 关键字。",
      "",
      "创建嵌套类、内部类与匿名内部类的类实例在嵌套类中有述。",
      "",
      "类成员",
      "类可以包含：",
      "",
      "构造函数与初始化块",
      "函数",
      "属性",
      "嵌套类与内部类",
      "对象声明",
      "继承",
      "在 Kotlin 中所有类都有一个共同的超类 Any，这对于没有超类型声明的类是默认超类：",
      "",
      "class Example // 从 Any 隐式继承",
      "Any 有三个方法：equals()、 hashCode() 与 toString()。因此，为所有 Kotlin 类都定义了这些方法。",
      "",
      "默认情况下，Kotlin 类是最终（final）的：它们不能被继承。 要使一个类可继承，请用 open 关键字标记它。",
      "",
      "open class Base // 该类开放继承",
      "如需声明一个显式的超类型，请在类头中把超类型放到冒号之后：",
      "",
      "open class Base(p: Int)",
      "​",
      "class Derived(p: Int) : Base(p)",
      "如果派生类有一个主构造函数，其基类可以（并且必须） 用派生类主构造函数的参数就地初始化。",
      "",
      "如果派生类没有主构造函数，那么每个次构造函数必须使用 super 关键字初始化其基类型，或委托给另一个构造函数做到这一点。 注意，在这种情况下，不同的次构造函数可以调用基类型的不同的构造函数：",
      "",
      "class MyView : View {",
      "    constructor(ctx: Context) : super(ctx)",
      "​",
      "    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)",
      "}",
      "覆盖方法",
      "我们之前提到过，Kotlin 力求清晰显式。因此，Kotlin 对于可覆盖的成员（我们称之为开放）以及覆盖后的成员需要显式修饰符：",
      "",
      "open class Shape {",
      "    open fun draw() { /*……*/ }",
      "    fun fill() { /*……*/ }",
      "}",
      "​",
      "class Circle() : Shape() {",
      "    override fun draw() { /*……*/ }",
      "}",
      "Circle.draw() 函数上必须加上 override 修饰符。如果没写，编译器将会报错。 如果函数没有标注 open 如 Shape.fill()，那么子类中不允许定义相同签名的函数， 不论加不加 override。将 open 修饰符添加到 final 类（即没有 open 的类）的成员上不起作用。",
      "",
      "标记为 override 的成员本身是开放的，也就是说，它可以在子类中覆盖。如果你想禁止再次覆盖，使用 final 关键字：",
      "",
      "open class Rectangle() : Shape() {",
      "    final override fun draw() { /*……*/ }",
      "}",
      "open class Rectangle() : Shape() {",
      "    final override fun draw() { /*……*/ }",
      "}",
      "覆盖属性",
      "属性覆盖与方法覆盖类似；在超类中声明然后在派生类中重新声明的属性必须以 override 开头，并且它们必须具有兼容的类型。 每个声明的属性可以由具有初始化器的属性或者具有 get 方法的属性覆盖。",
      "",
      "    override val vertexCount = 4",
      "",
      "open class Shape {",
      "    open val vertexCount: Int = 0",
      "}",
      "​",
      "class Rectangle : Shape() {",
      "    override val vertexCount = 4",
      "}",
      "你也可以用一个 var 属性覆盖一个 val 属性，但反之则不行。 这是允许的，因为一个 val 属性本质上声明了一个 get 方法， 而将其覆盖为 var 只是在子类中额外声明一个 set 方法。",
      "",
      "请注意，你可以在主构造函数中使用 override 关键字作为属性声明的一部分。",
      "",
      "vertexCount",
      "interface Shape {",
      "    val vertexCount: Int",
      "}",
      "​",
      "class Rectangle(override val vertexCount: Int = 4) : Shape // 总是有 4 个顶点",
      "​",
      "class Polygon : Shape {",
      "    override var vertexCount: Int = 0  // 以后可以设置为任何数",
      "}"
    ]
  },
  "kt-调用超类实现": {
    "prefix": "kt-调用超类实现",
    "body": [
      "派生类中的代码可以使用 super 关键字调用其超类的函数与属性访问器的实现：",
      "",
      "open class Rectangle {",
      "    open fun draw() { println(\"Drawing a rectangle\") }",
      "    val borderColor: String get() = \"black\"",
      "}",
      "​",
      "class FilledRectangle : Rectangle() {",
      "    override fun draw() {",
      "        super.draw()",
      "        println(\"Filling the rectangle\")",
      "    }",
      "​",
      "    val fillColor: String get() = super.borderColor",
      "}",
      "在一个内部类中访问外部类的超类，可以通过由外部类名限定的 super 关键字来实现：super@Outer：",
      "",
      "class FilledRectangle: Rectangle() {",
      "    fun draw() { /* …… */ }",
      "    val borderColor: String get() = \"black\"",
      "    ",
      "    inner class Filler {",
      "        fun fill() { /* …… */ }",
      "        fun drawAndFill() {",
      "            super@FilledRectangle.draw() // 调用 Rectangle 的 draw() 实现",
      "            fill()",
      "            println(\"Drawn a filled rectangle with color ${super@FilledRectangle.borderColor}\") // 使用 Rectangle 所实现的 borderColor 的 get()",
      "        }",
      "    }",
      "}"
    ]
  },
  "kt-覆盖规则": {
    "prefix": "kt-覆盖规则",
    "body": [
      "在 Kotlin 中，实现继承由下述规则规定：如果一个类从它的直接超类继承相同成员的多个实现， 它必须覆盖这个成员并提供其自己的实现（也许用继承来的其中之一）。 为了表示采用从哪个超类型继承的实现，我们使用由尖括号中超类型名限定的 super，如 super<Base>：",
      "",
      "open class Rectangle {",
      "    open fun draw() { /* …… */ }",
      "}",
      "​",
      "interface Polygon {",
      "    fun draw() { /* …… */ } // 接口成员默认就是“open”的",
      "}",
      "​",
      "class Square() : Rectangle(), Polygon {",
      "    // 编译器要求覆盖 draw()：",
      "    override fun draw() {",
      "        super<Rectangle>.draw() // 调用 Rectangle.draw()",
      "        super<Polygon>.draw() // 调用 Polygon.draw()",
      "    }",
      "}",
      "可以同时继承 Rectangle 与 Polygon， 但是二者都有各自的 draw() 实现，所以我们必须在 Square 中覆盖 draw()， 并提供其自身的实现以消除歧义"
    ]
  },
  "kt-抽象类": {
    "prefix": "kt-抽象类",
    "body": [
      "类以及其中的某些成员可以声明为 abstract。 抽象成员在本类中可以不用实现。 需要注意的是，我们并不需要用 open 标注一个抽象类或者函数——因为这不言而喻。",
      "",
      "我们可以用一个抽象成员覆盖一个非抽象的开放成员",
      "",
      "open class Polygon {",
      "    open fun draw() {}",
      "}",
      "",
      "abstract class Rectangle : Polygon() {",
      "    abstract override fun draw()",
      "}",
      "open class Polygon {",
      "    open fun draw() {}",
      "}",
      "​",
      "abstract class Rectangle : Polygon() {",
      "    abstract override fun draw()",
      "}"
    ]
  },
  "kt-声明属性": {
    "prefix": "kt-声明属性",
    "body": [
      "class Address {",
      "    var name: String = \"Holmes, Sherlock\"",
      "    var street: String = \"Baker\"",
      "    var city: String = \"London\"",
      "    var state: String? = null",
      "    var zip: String = \"123456\"",
      "}"
    ]
  },
  "kt-Getters 与 Setters": {
    "prefix": "kt-Getters 与 Setters",
    "body": [
      "val isEmpty: Boolean",
      "    get() = this.size == 0",
      "var stringRepresentation: String",
      "    get() = this.toString()",
      "    set(value) {",
      "        setDataFromString(value) // 解析字符串并赋值给其他属性",
      "    }",
      "自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它：",
      "",
      "val isEmpty get() = this.size == 0  // 具有类型 Boolean",
      "如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:",
      "",
      "setter",
      "var setterVisibility: String = \"abc\"",
      "    private set // 此 setter 是私有的并且有默认实现",
      "​",
      "var setterWithAnnotation: Any? = null",
      "    @Inject set // 用 Inject 注解此 setter"
    ]
  },
  "kt-field": {
    "prefix": "kt-field",
    "body": [
      "var counter = 0 // 注意：这个初始器直接为幕后字段赋值",
      "    set(value) {",
      "        if (value >= 0) field = value",
      "    }",
      "field 标识符只能用在属性的访问器内。"
    ]
  },
  "kt-延迟初始化属性与变量": {
    "prefix": "kt-延迟初始化属性与变量",
    "body": [
      "public class MyTest {",
      "    lateinit var subject: TestSubject",
      "",
      "    @SetUp fun setup() {",
      "        subject = TestSubject()",
      "    }",
      "",
      "    @Test fun test() {",
      "        subject.method()  // 直接解引用",
      "    }",
      "}",
      " 改进翻译",
      "属性与字段",
      "声明属性",
      "Kotlin 类中的属性既可以用关键字 var 声明为可变的，也可以用关键字 val 声明为只读的。",
      "",
      "class Address {",
      "    var name: String = \"Holmes, Sherlock\"",
      "    var street: String = \"Baker\"",
      "    var city: String = \"London\"",
      "    var state: String? = null",
      "    var zip: String = \"123456\"",
      "}",
      "class Address {",
      "    var name: String = \"Holmes, Sherlock\"",
      "    var street: String = \"Baker\"",
      "    var city: String = \"London\"",
      "    var state: String? = null",
      "    var zip: String = \"123456\"",
      "}",
      "要使用一个属性，只要用名称引用它即可：",
      "",
      "    result.street = address.street",
      "",
      "fun copyAddress(address: Address): Address {",
      "    val result = Address() // Kotlin 中没有“new”关键字",
      "    result.name = address.name // 将调用访问器",
      "    result.street = address.street",
      "    // ……",
      "    return result",
      "}",
      "Getters 与 Setters",
      "声明一个属性的完整语法是",
      "",
      "var <propertyName>[: <PropertyType>] [= <property_initializer>]",
      "    [<getter>]",
      "    [<setter>]",
      "其初始器（initializer）、getter 和 setter 都是可选的。属性类型如果可以从初始器 （或者从其 getter 返回值，如下文所示）中推断出来，也可以省略。",
      "",
      "例如:",
      "",
      "var initialized = 1 // 类型 Int、默认 getter 和 setter",
      "var allByDefault: Int? // 错误：需要显式初始化器，隐含默认 getter 和 setter",
      "var initialized = 1 // 类型 Int、默认 getter 和 setter",
      "一个只读属性的语法和一个可变的属性的语法有两方面的不同：1、只读属性的用 val开始代替var 2、只读属性不允许 setter",
      "",
      "inferredType",
      "val simple: Int? // 类型 Int、默认 getter、必须在构造函数中初始化",
      "val inferredType = 1 // 类型 Int 、默认 getter",
      "我们可以为属性定义自定义的访问器。如果我们定义了一个自定义的 getter，那么每次访问该属性时都会调用它 （这让我们可以实现计算出的属性）。以下是一个自定义 getter 的示例：",
      "",
      "val isEmpty: Boolean",
      "    get() = this.size == 0",
      "val isEmpty: Boolean",
      "    get() = this.size == 0",
      "如果我们定义了一个自定义的 setter，那么每次给属性赋值时都会调用它。一个自定义的 setter 如下所示：",
      "",
      "var stringRepresentation: String",
      "    get() = this.toString()",
      "    set(value) {",
      "        setDataFromString(value) // 解析字符串并赋值给其他属性",
      "    }",
      "var stringRepresentation: String",
      "    get() = this.toString()",
      "    set(value) {",
      "        setDataFromString(value) // 解析字符串并赋值给其他属性",
      "    }",
      "按照惯例，setter 参数的名称是 value，但是如果你喜欢你可以选择一个不同的名称。",
      "",
      "自 Kotlin 1.1 起，如果可以从 getter 推断出属性类型，则可以省略它：",
      "",
      "val isEmpty get() = this.size == 0  // 具有类型 Boolean",
      "如果你需要改变一个访问器的可见性或者对其注解，但是不需要改变默认的实现， 你可以定义访问器而不定义其实现:",
      "",
      "setter",
      "var setterVisibility: String = \"abc\"",
      "    private set // 此 setter 是私有的并且有默认实现",
      "​",
      "var setterWithAnnotation: Any? = null",
      "    @Inject set // 用 Inject 注解此 setter",
      "幕后字段",
      "在 Kotlin 类中不能直接声明字段。然而，当一个属性需要一个幕后字段时，Kotlin 会自动提供。这个幕后字段可以使用field标识符在访问器中引用：",
      "",
      "var counter = 0 // 注意：这个初始器直接为幕后字段赋值",
      "    set(value) {",
      "        if (value >= 0) field = value",
      "    }",
      "field 标识符只能用在属性的访问器内。",
      "",
      "如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段，将会为该属性生成一个幕后字段。",
      "",
      "例如，下面的情况下， 就没有幕后字段：",
      "",
      "  get() = this.size == 0",
      "val isEmpty: Boolean",
      "    get() = this.size == 0",
      "幕后属性",
      "如果你的需求不符合这套“隐式的幕后字段”方案，那么总可以使用 幕后属性（backing property）：",
      "",
      "        if (_table == null) {",
      "",
      "private var _table: Map<String, Int>? = null",
      "public val table: Map<String, Int>",
      "    get() {",
      "        if (_table == null) {",
      "            _table = HashMap() // 类型参数已推断出",
      "        }",
      "        return _table ?: throw AssertionError(\"Set to null by another thread\")",
      "    }",
      "对于 JVM 平台：通过默认 getter 和 setter 访问私有属性会被优化， 所以本例不会引入函数调用开销。",
      "",
      "编译期常量",
      "如果只读属性的值在编译期是已知的，那么可以使用 const 修饰符将其标记为编译期常量。 这种属性需要满足以下要求：",
      "",
      "位于顶层或者是 object 声明 或 companion object 的一个成员",
      "以 String 或原生类型值初始化",
      "没有自定义 getter",
      "这些属性可以用在注解中：",
      "",
      "SUBSYSTEM_DEPRECATED",
      "const val SUBSYSTEM_DEPRECATED: String = \"This subsystem is deprecated\"",
      "​",
      "@Deprecated(SUBSYSTEM_DEPRECATED) fun foo() { …… }",
      "延迟初始化属性与变量",
      "一般地，属性声明为非空类型必须在构造函数中初始化。 然而，这经常不方便。例如：属性可以通过依赖注入来初始化， 或者在单元测试的 setup 方法中初始化。 这种情况下，你不能在构造函数内提供一个非空初始器。 但你仍然想在类体中引用该属性时避免空检测。",
      "",
      "为处理这种情况，你可以用 lateinit 修饰符标记该属性：",
      "",
      "public class MyTest {",
      "    lateinit var subject: TestSubject",
      "",
      "    @SetUp fun setup() {",
      "        subject = TestSubject()",
      "    }",
      "",
      "    @Test fun test() {",
      "        subject.method()  // 直接解引用",
      "    }",
      "}",
      "public class MyTest {",
      "    lateinit var subject: TestSubject",
      "​",
      "    @SetUp fun setup() {",
      "        subject = TestSubject()",
      "    }",
      "​",
      "    @Test fun test() {",
      "        subject.method()  // 直接解引用",
      "    }",
      "}",
      "该修饰符只能用于在类体中的属性（不是在主构造函数中声明的 var 属性，并且仅当该属性没有自定义 getter 或 setter 时），而自 Kotlin 1.2 起，也用于顶层属性与局部变量。该属性或变量必须为非空类型，并且不能是原生类型。",
      "",
      "在初始化前访问一个 lateinit 属性会抛出一个特定异常，该异常明确标识该属性被访问及它没有初始化的事实。",
      "",
      "检测一个 lateinit var 是否已初始化（自 1.2 起）",
      "要检测一个 lateinit var 是否已经初始化过，请在该属性的引用上使用 .isInitialized：",
      "",
      "if (foo::bar.isInitialized) {",
      "    println(foo.bar)",
      "}"
    ]
  },
  "kt-接口": {
    "prefix": "kt-接口",
    "body": [
      "Kotlin 的接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。",
      "",
      "使用关键字 interface 来定义接口",
      "",
      "interface MyInterface {",
      "    fun bar()",
      "    fun foo() {",
      "      // 可选的方法体",
      "    }",
      "}",
      "实现接口",
      "一个类或者对象可以实现一个或多个接口。",
      "",
      "class Child : MyInterface {",
      "    override fun bar() {",
      "        // 方法体",
      "    }",
      "}",
      "接口中的属性",
      "你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。",
      "",
      "interface MyInterface {",
      "    val prop: Int // 抽象的",
      "​",
      "    val propertyWithImplementation: String",
      "        get() = \"foo\"",
      "​",
      "    fun foo() {",
      "        print(prop)",
      "    }",
      "}",
      "​",
      "class Child : MyInterface {",
      "    override val prop: Int = 29",
      "}",
      "接口继承",
      "一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：",
      "",
      "interface Named {",
      "    val name: String",
      "}",
      "​",
      "interface Person : Named {",
      "    val firstName: String",
      "    val lastName: String",
      "    ",
      "    override val name: String get() = \"$firstName $lastName\"",
      "}",
      "​",
      "data class Employee(",
      "    // 不必实现“name”",
      "    override val firstName: String,",
      "    override val lastName: String,",
      "    val position: Position",
      ") : Person",
      "完整 Kotlin 参考（PDF）",
      "完整 Kotlin 参考（字大PDF）",
      "完整 Kotlin 参考（ePUB）",
      "完整 Kotlin 参考（Mobi）",
      " 改进翻译",
      "接口",
      "Kotlin 的接口可以既包含抽象方法的声明也包含实现。与抽象类不同的是，接口无法保存状态。它可以有属性但必须声明为抽象或提供访问器实现。",
      "",
      "使用关键字 interface 来定义接口",
      "",
      "interface MyInterface {",
      "    fun bar()",
      "    fun foo() {",
      "      // 可选的方法体",
      "    }",
      "}",
      "实现接口",
      "一个类或者对象可以实现一个或多个接口。",
      "",
      "class Child : MyInterface {",
      "    override fun bar() {",
      "        // 方法体",
      "    }",
      "}",
      "接口中的属性",
      "你可以在接口中定义属性。在接口中声明的属性要么是抽象的，要么提供访问器的实现。在接口中声明的属性不能有幕后字段（backing field），因此接口中声明的访问器不能引用它们。",
      "",
      "interface MyInterface {",
      "    val prop: Int // 抽象的",
      "​",
      "    val propertyWithImplementation: String",
      "        get() = \"foo\"",
      "​",
      "    fun foo() {",
      "        print(prop)",
      "    }",
      "}",
      "​",
      "class Child : MyInterface {",
      "    override val prop: Int = 29",
      "}",
      "接口继承",
      "一个接口可以从其他接口派生，从而既提供基类型成员的实现也声明新的函数与属性。很自然地，实现这样接口的类只需定义所缺少的实现：",
      "",
      "interface Named {",
      "    val name: String",
      "}",
      "​",
      "interface Person : Named {",
      "    val firstName: String",
      "    val lastName: String",
      "    ",
      "    override val name: String get() = \"$firstName $lastName\"",
      "}",
      "​",
      "data class Employee(",
      "    // 不必实现“name”",
      "    override val firstName: String,",
      "    override val lastName: String,",
      "    val position: Position",
      ") : Person",
      "解决覆盖冲突",
      "实现多个接口时，可能会遇到同一方法继承多个实现的问题。例如",
      "",
      "fun",
      "interface A {",
      "    fun foo() { print(\"A\") }",
      "    fun bar()",
      "}",
      "​",
      "interface B {",
      "    fun foo() { print(\"B\") }",
      "    fun bar() { print(\"bar\") }",
      "}",
      "​",
      "class C : A {",
      "    override fun bar() { print(\"bar\") }",
      "}",
      "​",
      "class D : A, B {",
      "    override fun foo() {",
      "        super<A>.foo()",
      "        super<B>.foo()",
      "    }",
      "​",
      "    override fun bar() {",
      "        super<B>.bar()",
      "    }",
      "}"
    ]
  },
  "kt-修饰符": {
    "prefix": "kt-修饰符",
    "body": [
      "如果你不指定任何可见性修饰符，默认为 public，这意味着你的声明将随处可见；",
      "如果你声明为 private，它只会在声明它的文件内可见；",
      "如果你声明为 internal，它会在相同模块内随处可见；",
      "protected 不适用于顶层声明。",
      "注意：要使用另一包中可见的顶层声明，仍需将其导入进来。",
      "",
      "例如:",
      "",
      "// 文件名：example.kt",
      "package foo",
      "",
      "private fun foo() { …… } // 在 example.kt 内可见",
      "",
      "public var bar: Int = 5 // 该属性随处可见",
      "    private set         // setter 只在 example.kt 内可见",
      "    ",
      "internal val baz = 6    // 相同模块内可见",
      "// 文件名：example.kt",
      "package foo",
      "​",
      "private fun foo() { …… } // 在 example.kt 内可见",
      "​",
      "public var bar: Int = 5 // 该属性随处可见",
      "    private set         // setter 只在 example.kt 内可见",
      "    ",
      "internal val baz = 6    // 相同模块内可见",
      "类和接口",
      "类和接口",
      "对于类内部声明的成员：",
      "",
      "private 意味着只在这个类内部（包含其所有成员）可见；",
      "protected—— 和 private一样 + 在子类中可见。",
      "internal —— 能见到类声明的 本模块内 的任何客户端都可见其 internal 成员；",
      "public —— 能见到类声明的任何客户端都可见其 public 成员。",
      "请注意在 Kotlin 中，外部类不能访问内部类的 private 成员。",
      "",
      "如果你覆盖一个 protected 成员并且没有显式指定其可见性，该成员还会是 protected 可见性。",
      "",
      "例子:",
      "",
      "Unrelated",
      "open class Outer {",
      "    private val a = 1",
      "    protected open val b = 2",
      "    internal val c = 3",
      "    val d = 4  // 默认 public",
      "    ",
      "    protected class Nested {",
      "        public val e: Int = 5",
      "    }",
      "}",
      "​",
      "class Subclass : Outer() {",
      "    // a 不可见",
      "    // b、c、d 可见",
      "    // Nested 和 e 可见",
      "​",
      "    override val b = 5   // “b”为 protected",
      "}",
      "​",
      "class Unrelated(o: Outer) {",
      "    // o.a、o.b 不可见",
      "    // o.c 和 o.d 可见（相同模块）",
      "    // Outer.Nested 不可见，Nested::e 也不可见",
      "}",
      "要指定一个类的的主构造函数的可见性，使用以下语法（注意你需要添加一个显式 constructor 关键字）：",
      "",
      "class C private constructor(a: Int) { …… }",
      "class C private constructor(a: Int) { …… }",
      "这里的构造函数是私有的。默认情况下，所有构造函数都是 public，这实际上等于类可见的地方它就可见（即 一个 internal 类的构造函数只能在相同模块内可见)."
    ]
  },
  "kt-扩展": {
    "prefix": "kt-扩展",
    "body": [
      "声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList<Int> 添加一个swap 函数：",
      "",
      "[",
      "fun MutableList<Int>.swap(index1: Int, index2: Int) {",
      "    val tmp = this[index1] // “this”对应该列表",
      "    this[index1] = this[index2]",
      "    this[index2] = tmp",
      "}",
      "这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，我们对任意 MutableList<Int> 调用该函数了：",
      "",
      "list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值",
      "val list = mutableListOf(1, 2, 3)",
      "list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值",
      "当然，这个函数对任何 MutableList<T> 起作用，我们可以泛化它：",
      "",
      "fun <T> MutableList<T>.swap(index1: Int, index2: Int) {",
      "    val tmp = this[index1] // “this”对应该列表",
      "    this[index1] = this[index2]",
      "    this[index2] = tmp",
      "}"
    ]
  },
  "kt-扩展是静态解析的": {
    "prefix": "kt-扩展是静态解析的",
    "body": [
      "",
      "内联类",
      "委托",
      "委托属性",
      "完整 Kotlin 参考（PDF）",
      "完整 Kotlin 参考（字大PDF）",
      "完整 Kotlin 参考（ePUB）",
      "完整 Kotlin 参考（Mobi）",
      " 改进翻译",
      "扩展",
      "Kotlin 能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。 这通过叫做 扩展 的特殊声明完成。 例如，你可以为一个你不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为 扩展函数 。此外，也有 扩展属性 ， 允许你为一个已经存在的类添加新的属性。",
      "",
      "扩展函数",
      "声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList<Int> 添加一个swap 函数：",
      "",
      "[",
      "fun MutableList<Int>.swap(index1: Int, index2: Int) {",
      "    val tmp = this[index1] // “this”对应该列表",
      "    this[index1] = this[index2]",
      "    this[index2] = tmp",
      "}",
      "这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，我们对任意 MutableList<Int> 调用该函数了：",
      "",
      "list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值",
      "val list = mutableListOf(1, 2, 3)",
      "list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值",
      "当然，这个函数对任何 MutableList<T> 起作用，我们可以泛化它：",
      "",
      "fun <T> MutableList<T>.swap(index1: Int, index2: Int) {",
      "    val tmp = this[index1] // “this”对应该列表",
      "    this[index1] = this[index2]",
      "    this[index2] = tmp",
      "}",
      "为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。 参见泛型函数。",
      "",
      "扩展是静态解析的",
      "扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。",
      "",
      "我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：",
      "",
      "open class Shape",
      "​",
      "class Rectangle: Shape()",
      "​",
      "fun Shape.getName() = \"Shape\"",
      "​",
      "fun Rectangle.getName() = \"Rectangle\"",
      "​",
      "fun printClassName(s: Shape) {",
      "    println(s.getName())",
      "}    ",
      "​",
      "printClassName(Rectangle())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这个例子会输出 \"Shape\"，因为调用的扩展函数只取决于参数 s 的声明类型，该类型是 Shape 类。",
      "如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。 例如：",
      "",
      "nctionType() { println(\"Extension function\") }",
      "",
      "Example().printFunctionType()",
      "class Example {",
      "    fun printFunctionType() { println(\"Class method\") }",
      "}",
      "​",
      "fun Example.printFunctionType() { println(\"Extension function\") }",
      "​",
      "Example().printFunctionType()",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这段代码输出“Class method”。",
      "当然，扩展函数重载同样名字但不同签名成员函数也完全可以：",
      "",
      "class Example {",
      "    fun printFunctionType() { println(\"Class method\") }",
      "}",
      "",
      "fun Example.printFunctionType(i: Int) { println(\"Extension function\") }",
      "",
      "Example().printFunctionType(1)",
      "class Example {",
      "    fun printFunctionType() { println(\"Class method\") }",
      "}",
      "​",
      "fun Example.printFunctionType(i: Int) { println(\"Extension function\") }",
      "​",
      "Example().printFunctionType(1)",
      "可空接收者",
      "注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 this == null，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。",
      "",
      "fun Any?.toString(): String {",
      "    if (this == null) return \"null\"",
      "    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()",
      "    // 解析为 Any 类的成员函数",
      "    return toString()",
      "}"
    ]
  },
  "kt-扩展属性": {
    "prefix": "kt-扩展属性",
    "body": [
      "与函数类似，Kotlin 支持扩展属性：",
      "",
      "val <T> List<T>.lastIndex: Int",
      "    get() = size - 1",
      "注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。",
      "",
      "例如:",
      "",
      "val House.number = 1 // 错误：扩展属性不能有初始化器",
      "val House.number = 1 // 错误：扩展属性不能有初始化器"
    ]
  },
  "kt-伴生对象的扩展": {
    "prefix": "kt-伴生对象的扩展",
    "body": [
      " 改进翻译",
      "扩展",
      "Kotlin 能够扩展一个类的新功能而无需继承该类或者使用像装饰者这样的设计模式。 这通过叫做 扩展 的特殊声明完成。 例如，你可以为一个你不能修改的、来自第三方库中的类编写一个新的函数。 这个新增的函数就像那个原始类本来就有的函数一样，可以用普通的方法调用。 这种机制称为 扩展函数 。此外，也有 扩展属性 ， 允许你为一个已经存在的类添加新的属性。",
      "",
      "扩展函数",
      "声明一个扩展函数，我们需要用一个 接收者类型 也就是被扩展的类型来作为他的前缀。 下面代码为 MutableList<Int> 添加一个swap 函数：",
      "",
      "[",
      "fun MutableList<Int>.swap(index1: Int, index2: Int) {",
      "    val tmp = this[index1] // “this”对应该列表",
      "    this[index1] = this[index2]",
      "    this[index2] = tmp",
      "}",
      "这个 this 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象） 现在，我们对任意 MutableList<Int> 调用该函数了：",
      "",
      "list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值",
      "val list = mutableListOf(1, 2, 3)",
      "list.swap(0, 2) // “swap()”内部的“this”会保存“list”的值",
      "当然，这个函数对任何 MutableList<T> 起作用，我们可以泛化它：",
      "",
      "fun <T> MutableList<T>.swap(index1: Int, index2: Int) {",
      "    val tmp = this[index1] // “this”对应该列表",
      "    this[index1] = this[index2]",
      "    this[index2] = tmp",
      "}",
      "为了在接收者类型表达式中使用泛型，我们要在函数名前声明泛型参数。 参见泛型函数。",
      "",
      "扩展是静态解析的",
      "扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数。",
      "",
      "我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的。例如：",
      "",
      "open class Shape",
      "​",
      "class Rectangle: Shape()",
      "​",
      "fun Shape.getName() = \"Shape\"",
      "​",
      "fun Rectangle.getName() = \"Rectangle\"",
      "​",
      "fun printClassName(s: Shape) {",
      "    println(s.getName())",
      "}    ",
      "​",
      "printClassName(Rectangle())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这个例子会输出 \"Shape\"，因为调用的扩展函数只取决于参数 s 的声明类型，该类型是 Shape 类。",
      "",
      "如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况总是取成员函数。 例如：",
      "",
      "nctionType() { println(\"Extension function\") }",
      "",
      "Example().printFunctionType()",
      "class Example {",
      "    fun printFunctionType() { println(\"Class method\") }",
      "}",
      "​",
      "fun Example.printFunctionType() { println(\"Extension function\") }",
      "​",
      "Example().printFunctionType()",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这段代码输出“Class method”。",
      "",
      "当然，扩展函数重载同样名字但不同签名成员函数也完全可以：",
      "",
      "class Example {",
      "    fun printFunctionType() { println(\"Class method\") }",
      "}",
      "",
      "fun Example.printFunctionType(i: Int) { println(\"Extension function\") }",
      "",
      "Example().printFunctionType(1)",
      "class Example {",
      "    fun printFunctionType() { println(\"Class method\") }",
      "}",
      "​",
      "fun Example.printFunctionType(i: Int) { println(\"Extension function\") }",
      "​",
      "Example().printFunctionType(1)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可空接收者",
      "注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 this == null，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部。",
      "",
      "fun Any?.toString(): String {",
      "    if (this == null) return \"null\"",
      "    // 空检测之后，“this”会自动转换为非空类型，所以下面的 toString()",
      "    // 解析为 Any 类的成员函数",
      "    return toString()",
      "}",
      "扩展属性",
      "与函数类似，Kotlin 支持扩展属性：",
      "",
      "val <T> List<T>.lastIndex: Int",
      "    get() = size - 1",
      "注意：由于扩展没有实际的将成员插入类中，因此对扩展属性来说幕后字段是无效的。这就是为什么扩展属性不能有初始化器。他们的行为只能由显式提供的 getters/setters 定义。",
      "",
      "例如:",
      "",
      "val House.number = 1 // 错误：扩展属性不能有初始化器",
      "val House.number = 1 // 错误：扩展属性不能有初始化器",
      "伴生对象的扩展",
      "如果一个类定义有一个伴生对象 ，你也可以为伴生对象定义扩展函数与属性。就像伴生对象的常规成员一样， 可以只使用类名作为限定符来调用伴生对象的扩展成员：",
      "",
      "printCompanion",
      "class MyClass {",
      "    companion object { }  // 将被称为 \"Companion\"",
      "}",
      "​",
      "fun MyClass.Companion.printCompanion() { println(\"companion\") }",
      "​",
      "fun main() {",
      "    MyClass.printCompanion()"
    ]
  },
  "kt-伴生对象的扩展2": {
    "prefix": "kt-伴生对象的扩展2",
    "body": [
      "class MyClass {",
      "    companion object { }  // 将被称为 \"Companion\"",
      "}",
      "",
      "fun MyClass.Companion.printCompanion() { println(\"companion\") }",
      "",
      "fun main() {",
      "    MyClass.printCompanion()",
      "}"
    ]
  },
  "kt-扩展的作用域": {
    "prefix": "kt-扩展的作用域",
    "body": [
      "大多数时候我们在顶层定义扩展——直接在包里：",
      "",
      "<",
      "package org.example.declarations",
      " ",
      "fun List<String>.getLongestString() { /*……*/}",
      "要使用所定义包之外的一个扩展，我们需要在调用方导入它：",
      "",
      "getLongestString",
      "package org.example.usage",
      "​",
      "import org.example.declarations.getLongestString",
      "​",
      "fun main() {",
      "    val list = listOf(\"red\", \"green\", \"blue\")",
      "    list.getLongestString()",
      "}"
    ]
  },
  "kt-扩展声明为成员": {
    "prefix": "kt-扩展声明为成员",
    "body": [
      "在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 隐式接收者 —— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 分发接收者，扩展方法调用所在的接收者类型的实例称为 扩展接收者 。",
      "",
      "class Host(val hostname: String) {",
      "    fun printHostname() { print(hostname) }",
      "}",
      "​",
      "class Connection(val host: Host, val port: Int) {",
      "     fun printPort() { print(port) }",
      "​",
      "     fun Host.printConnectionString() {",
      "         printHostname()   // 调用 Host.printHostname()",
      "         print(\":\")",
      "         printPort()   // 调用 Connection.printPort()",
      "     }",
      "​",
      "     fun connect() {",
      "         /*……*/",
      "         host.printConnectionString()   // 调用扩展函数",
      "     }",
      "}",
      "​",
      "fun main() {",
      "    Connection(Host(\"kotl.in\"), 443).connect()",
      "    //Host(\"kotl.in\").printConnectionString(443)  // 错误，该扩展函数在 Connection 外不可用",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "对于分发接收者与扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 限定的 this 语法。",
      "",
      "//",
      "class Connection {",
      "    fun Host.getConnectionString() {",
      "        toString()         // 调用 Host.toString()",
      "        this@Connection.toString()  // 调用 Connection.toString()",
      "    }",
      "}",
      "声明为成员的扩展可以声明为 open 并在子类中覆盖。这意味着这些函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型是静态的。",
      "",
      "open class Base { }",
      "​",
      "class Derived : Base() { }",
      "​",
      "open class BaseCaller {",
      "    open fun Base.printFunctionInfo() {",
      "        println(\"Base extension function in BaseCaller\")",
      "    }",
      "​",
      "    open fun Derived.printFunctionInfo() {",
      "        println(\"Derived extension function in BaseCaller\")",
      "    }",
      "​",
      "    fun call(b: Base) {",
      "        b.printFunctionInfo()   // 调用扩展函数",
      "    }",
      "}",
      "​",
      "class DerivedCaller: BaseCaller() {",
      "    override fun Base.printFunctionInfo() {",
      "        println(\"Base extension function in DerivedCaller\")",
      "    }",
      "​",
      "    override fun Derived.printFunctionInfo() {",
      "        println(\"Derived extension function in DerivedCaller\")",
      "    }",
      "}",
      "​",
      "fun main() {",
      "    BaseCaller().call(Base())   // “Base extension function in BaseCaller”",
      "    DerivedCaller().call(Base())  // “Base extension function in DerivedCaller”——分发接收者虚拟解析",
      "    DerivedCaller().call(Derived())  // “Base extension function in DerivedCaller”——扩展接收者静态解析",
      "}"
    ]
  },
  "kt-数据类": {
    "prefix": "kt-数据类",
    "body": [
      "data class User(val name: String = \"\", val age: Int = 0)",
      "完整 Kotlin 参考（PDF）",
      "完整 Kotlin 参考（字大PDF）",
      "完整 Kotlin 参考（ePUB）",
      "完整 Kotlin 参考（Mobi）",
      " 改进翻译",
      "数据类",
      "我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data：",
      "",
      "data class User(val name: String, val age: Int)",
      "编译器自动从主构造函数中声明的所有属性导出以下成员：",
      "",
      "equals()/hashCode() 对；",
      "toString() 格式是 \"User(name=John, age=42)\"；",
      "componentN() 函数 按声明顺序对应于所有属性；",
      "copy() 函数（见下文）。",
      "为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：",
      "",
      "主构造函数需要至少有一个参数；",
      "主构造函数的所有参数需要标记为 val 或 var；",
      "数据类不能是抽象、开放、密封或者内部的；",
      "（在1.1之前）数据类只能实现接口。",
      "此外，成员生成遵循关于成员继承的这些规则：",
      "",
      "如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数；",
      "如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错；",
      "从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且在 Kotlin 1.3 中已禁用。",
      "不允许为 componentN() 以及 copy() 函数提供显式实现。",
      "自 1.1 起，数据类可以扩展其他类（示例请参见密封类）。",
      "",
      "在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 （参见构造函数）。",
      "",
      "data class User(val name: String = \"\", val age: Int = 0)",
      "data class User(val name: String = \"\", val age: Int = 0)",
      "在类体中声明的属性",
      "请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排除一个属性，请将其声明在类体中：",
      "",
      "data class Person(val name: String) {",
      "    var age: Int = 0",
      "}",
      "在 toString()、 equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个 Person 对象可以有不同的年龄，但它们会视为相等。",
      "",
      "val person1 = Person(\"John\")",
      "val person2 = Person(\"John\")",
      "person1.age = 10",
      "person2.age = 20",
      "复制",
      "在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：",
      "",
      "fun copy(name: String = this.name, age: Int = this.age) = User(name, age)",
      "fun copy(name: String = this.name, age: Int = this.age) = User(name, age)",
      "这让我们可以写：",
      "",
      " ",
      "val jack = User(name = \"Jack\", age = 1)",
      "val olderJack = jack.copy(age = 2)",
      " 改进翻译",
      "数据类",
      "我们经常创建一些只保存数据的类。 在这些类中，一些标准函数往往是从数据机械推导而来的。在 Kotlin 中，这叫做 数据类 并标记为 data：",
      "",
      "data class User(val name: String, val age: Int)",
      "编译器自动从主构造函数中声明的所有属性导出以下成员：",
      "",
      "equals()/hashCode() 对；",
      "toString() 格式是 \"User(name=John, age=42)\"；",
      "componentN() 函数 按声明顺序对应于所有属性；",
      "copy() 函数（见下文）。",
      "为了确保生成的代码的一致性以及有意义的行为，数据类必须满足以下要求：",
      "",
      "主构造函数需要至少有一个参数；",
      "主构造函数的所有参数需要标记为 val 或 var；",
      "数据类不能是抽象、开放、密封或者内部的；",
      "（在1.1之前）数据类只能实现接口。",
      "此外，成员生成遵循关于成员继承的这些规则：",
      "",
      "如果在数据类体中有显式实现 equals()、 hashCode() 或者 toString()，或者这些函数在父类中有 final 实现，那么不会生成这些函数，而会使用现有函数；",
      "如果超类型具有 open 的 componentN() 函数并且返回兼容的类型， 那么会为数据类生成相应的函数，并覆盖超类的实现。如果超类型的这些函数由于签名不兼容或者是 final 而导致无法覆盖，那么会报错；",
      "从一个已具 copy(……) 函数且签名匹配的类型派生一个数据类在 Kotlin 1.2 中已弃用，并且在 Kotlin 1.3 中已禁用。",
      "不允许为 componentN() 以及 copy() 函数提供显式实现。",
      "自 1.1 起，数据类可以扩展其他类（示例请参见密封类）。",
      "",
      "在 JVM 中，如果生成的类需要含有一个无参的构造函数，则所有的属性必须指定默认值。 （参见构造函数）。",
      "",
      "data class User(val name: String = \"\", val age: Int = 0)",
      "data class User(val name: String = \"\", val age: Int = 0)",
      "在类体中声明的属性",
      "请注意，对于那些自动生成的函数，编译器只使用在主构造函数内部定义的属性。如需在生成的实现中排除一个属性，请将其声明在类体中：",
      "",
      "data class Person(val name: String) {",
      "    var age: Int = 0",
      "}",
      "在 toString()、 equals()、 hashCode() 以及 copy() 的实现中只会用到 name 属性，并且只有一个 component 函数 component1()。虽然两个 Person 对象可以有不同的年龄，但它们会视为相等。",
      "",
      "val person1 = Person(\"John\")",
      "val person2 = Person(\"John\")",
      "person1.age = 10",
      "person2.age = 20",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "复制",
      "在很多情况下，我们需要复制一个对象改变它的一些属性，但其余部分保持不变。 copy() 函数就是为此而生成。对于上文的 User 类，其实现会类似下面这样：",
      "",
      "fun copy(name: String = this.name, age: Int = this.age) = User(name, age)",
      "fun copy(name: String = this.name, age: Int = this.age) = User(name, age)",
      "这让我们可以写：",
      "",
      " ",
      "val jack = User(name = \"Jack\", age = 1)",
      "val olderJack = jack.copy(age = 2)",
      "数据类与解构声明",
      "为数据类生成的 Component 函数 使它们可在解构声明中使用：",
      "",
      "val jane = User(\"Jane\", 35)",
      "val (name, age) = jane",
      "println(\"$name, $age years of age\") "
    ]
  },
  "kt-密封类sealed": {
    "prefix": "kt-密封类sealed",
    "body": [
      "sealed class Expr",
      "data class Const(val number: Double) : Expr()",
      "data class Sum(val e1: Expr, val e2: Expr) : Expr()",
      "object NotANumber : Expr()",
      "密封类不允许有非-private 构造函数（其构造函数默认为 private）。",
      "",
      "请注意，扩展密封类子类的类（间接继承者）可以放在任何位置，而无需在同一个文件中。",
      "",
      "使用密封类的关键好处在于使用 when 表达式 的时候，如果能够验证语句覆盖了所有情况，就不需要为该语句再添加一个 else 子句了。当然，这只有当你用 when 作为表达式（使用结果）而不是作为语句时才有用。",
      "",
      "fun eval(expr: Expr): Double = when(expr) {",
      "    is Const -> expr.number",
      "    is Sum -> eval(expr.e1) + eval(expr.e2)",
      "    NotANumber -> Double.NaN",
      "    // 不再需要 `else` 子句，因为我们已经覆盖了所有的情况",
      "}"
    ]
  },
  "kt-泛型": {
    "prefix": "kt-泛型",
    "body": [
      "与 Java 类似，Kotlin 中的类也可以有类型参数：",
      "",
      "class Box<T>(t: T) {",
      "",
      "class Box<T>(t: T) {",
      "    var value = t",
      "}",
      "一般来说，要创建这样类的实例，我们需要提供类型参数：",
      "",
      "Box",
      "val box: Box<Int> = Box<Int>(1)",
      "但是如果类型参数可以推断出来，例如从构造函数的参数或者从其他途径，允许省略类型参数：",
      "",
      "val box = Box(1) // 1 具有类型 Int，所以编译器知道我们说的是 Box<Int>。"
    ]
  },
  "kt-泛型函数": {
    "prefix": "kt-泛型函数",
    "body": [
      "泛型函数",
      "不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称之前：",
      "",
      "fun <T> singletonList(item: T): List<T> {",
      "    // ……",
      "}",
      "​",
      "fun <T> T.basicToString(): String {  // 扩展函数",
      "    // ……",
      "}",
      "要调用泛型函数，在调用处函数名之后指定类型参数即可：",
      "",
      "Int",
      "val l = singletonList<Int>(1)",
      "可以省略能够从上下文中推断出来的类型参数，所以以下示例同样适用：",
      "",
      "val l = singletonList(1)"
    ]
  },
  "kt-嵌套类（静态内部类）": {
    "prefix": "kt-嵌套类（静态内部类）",
    "body": [
      "class Outer {",
      "    private val bar: Int = 1",
      "    class Nested {",
      "        fun foo() = 2",
      "    }",
      "}",
      "",
      "val demo = Outer.Nested().foo() // == 2"
    ]
  },
  "kt-内部类": {
    "prefix": "kt-内部类",
    "body": [
      "class Outer {",
      "    private val bar: Int = 1",
      "    inner class Inner {",
      "        fun foo() = bar",
      "    }",
      "}",
      "",
      "val demo = Outer().Inner().foo() // == 1"
    ]
  },
  "kt-匿名内部类": {
    "prefix": "kt-匿名内部类",
    "body": [
      "使用对象表达式创建匿名内部类实例：",
      "",
      "object",
      "window.addMouseListener(object : MouseAdapter() {",
      "​",
      "    override fun mouseClicked(e: MouseEvent) { …… }",
      "​",
      "    override fun mouseEntered(e: MouseEvent) { …… }",
      "})",
      "注：对于 JVM 平台, 如果对象是函数式 Java 接口（即具有单个抽象方法的 Java 接口）的实例， 你可以使用带接口类型前缀的lambda表达式创建它：",
      "",
      "val listener = ActionListener { println(\"clicked\") }",
      "val listener = ActionListener { println(\"clicked\") }"
    ]
  },
  "kt-enum": {
    "prefix": "kt-enum",
    "body": [
      "enum class Direction {",
      "    NORTH, SOUTH, WEST, EAST",
      "}",
      "enum class Color(val rgb: Int) {",
      "        RED(0xFF0000),",
      "        GREEN(0x00FF00),",
      "        BLUE(0x0000FF)",
      "}",
      "enum class ProtocolState {",
      "    WAITING {",
      "        override fun signal() = TALKING",
      "    },",
      "",
      "    TALKING {",
      "        override fun signal() = WAITING",
      "    };",
      "",
      "    abstract fun signal(): ProtocolState",
      "}",
      "enum class IntArithmetics : BinaryOperator<Int>, IntBinaryOperator {",
      "    PLUS {",
      "        override fun apply(t: Int, u: Int): Int = t + u",
      "    },",
      "    TIMES {",
      "        override fun apply(t: Int, u: Int): Int = t * u",
      "    };",
      "",
      "    override fun applyAsInt(t: Int, u: Int) = apply(t, u)",
      "}",
      "EnumClass.valueOf(value: String): EnumClass",
      "EnumClass.values(): Array<EnumClass>"
    ]
  },
  "kt-object": {
    "prefix": "kt-object",
    "body": [
      "要创建一个继承自某个（或某些）类型的匿名类的对象，我们会这么写：",
      "",
      "",
      "window.addMouseListener(object : MouseAdapter() {",
      "    override fun mouseClicked(e: MouseEvent) { /*……*/ }",
      "​",
      "    override fun mouseEntered(e: MouseEvent) { /*……*/ }",
      "})",
      "open class A(x: Int) {",
      "    public open val y: Int = x",
      "}",
      "",
      "interface B { /*……*/ }",
      "",
      "val ab: A = object : A(1), B {",
      "    override val y = 15",
      "}",
      "任何时候，如果我们只需要“一个对象而已”，并不需要特殊超类型，那么我们可以简单地写：",
      "",
      "",
      "fun foo() {",
      "    val adHoc = object {",
      "        var x: Int = 0",
      "        var y: Int = 0",
      "    }",
      "    print(adHoc.x + adHoc.y)",
      "}",
      "请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 Any。在匿名对象中添加的成员将无法访问。",
      "",
      "",
      "class C {",
      "    // 私有函数，所以其返回类型是匿名对象类型",
      "    private fun foo() = object {",
      "        val x: String = \"x\"",
      "    }",
      "​",
      "    // 公有函数，所以其返回类型是 Any",
      "    fun publicFoo() = object {",
      "        val x: String = \"x\"",
      "    }",
      "​",
      "    fun bar() {",
      "        val x1 = foo().x        // 没问题",
      "        val x2 = publicFoo().x  // 错误：未能解析的引用“x”",
      "    }",
      "}",
      "对象表达式中的代码可以访问来自包含它的作用域的变量。",
      "",
      "",
      "fun countClicks(window: JComponent) {",
      "    var clickCount = 0",
      "    var enterCount = 0",
      "​",
      "    window.addMouseListener(object : MouseAdapter() {",
      "        override fun mouseClicked(e: MouseEvent) {",
      "            clickCount++",
      "        }",
      "​",
      "        override fun mouseEntered(e: MouseEvent) {",
      "            enterCount++",
      "        }",
      "    })",
      "    // ……",
      "}",
      "object DefaultListener : MouseAdapter() {",
      "    override fun mouseClicked(e: MouseEvent) { …… }",
      "",
      "    override fun mouseEntered(e: MouseEvent) { …… }",
      "}"
    ]
  },
  "kt-伴生对象": {
    "prefix": "kt-伴生对象",
    "body": [
      "class MyClass {",
      "    companion object Factory {",
      "        fun create(): MyClass = MyClass()",
      "    }",
      "}",
      "该伴生对象的成员可通过只使用类名作为限定符来调用：",
      "",
      "",
      "val instance = MyClass.create()",
      "可以省略伴生对象的名称，在这种情况下将使用名称 Companion：",
      "",
      "",
      "class MyClass {",
      "    companion object { }",
      "}",
      "​",
      "val x = MyClass.Companion",
      "其自身所用的类的名称（不是另一个名称的限定符）可用作对该类的伴生对象 （无论是否具名）的引用：",
      "",
      "",
      "class MyClass1 {",
      "    companion object Named { }",
      "}",
      "​",
      "val x = MyClass1",
      "​",
      "class MyClass2 {",
      "    companion object { }",
      "}",
      "​",
      "val y = MyClass2"
    ]
  },
  "kt-类型别名typealias": {
    "prefix": "kt-类型别名typealias",
    "body": [
      "类型别名为现有类型提供替代名称。 如果类型名称太长，你可以另外引入较短的名称，并使用新的名称替代原类型名。",
      "",
      "它有助于缩短较长的泛型类型。 例如，通常缩减集合类型是很有吸引力的：",
      "",
      "",
      "typealias NodeSet = Set<Network.Node>",
      "​",
      "typealias FileTable<K> = MutableMap<K, MutableList<File>>",
      "你可以为函数类型提供另外的别名：",
      "",
      "",
      "typealias MyHandler = (Int, String, Any) -> Unit",
      "​",
      "typealias Predicate<T> = (T) -> Boolean",
      "你可以为内部类和嵌套类创建新名称：",
      "",
      "",
      "class A {",
      "    inner class Inner",
      "}",
      "class B {",
      "    inner class Inner",
      "}",
      "​",
      "typealias AInner = A.Inner",
      "typealias BInner = B.Inner",
      "类型别名不会引入新类型。 它们等效于相应的底层类型。 当你在代码中添加 typealias Predicate<T> 并使用 Predicate<Int> 时，Kotlin 编译器总是把它扩展为 (Int) -> Boolean。 因此，当你需要泛型函数类型时，你可以传递该类型的变量，反之亦然：",
      "",
      "",
      "typealias Predicate<T> = (T) -> Boolean",
      "​",
      "fun foo(p: Predicate<Int>) = p(42)",
      "​",
      "fun main() {",
      "    val f: (Int) -> Boolean = { it > 0 }",
      "    println(foo(f)) // 输出 \"true\"",
      "​",
      "    val p: Predicate<Int> = { it > 0 }",
      "    println(listOf(1, -2).filter(p)) // 输出 \"[1]\"",
      "}"
    ]
  },
  "kt-内联类": {
    "prefix": "kt-内联类",
    "body": [
      "有时候，业务逻辑需要围绕某种类型创建包装器。然而，由于额外的堆内存分配问题，它会引入运行时的性能开销。此外，如果被包装的类型是原生类型，性能的损失是很糟糕的，因为原生类型通常在运行时就进行了大量优化，然而他们的包装器却没有得到任何特殊的处理。",
      "",
      "为了解决这类问题，Kotlin 引入了一种被称为 内联类 的特殊类，它通过在类的前面定义一个 inline 修饰符来声明：",
      "",
      "",
      "inline class Password(val value: String)",
      "内联类必须含有唯一的一个属性在主构造函数中初始化。在运行时，将使用这个唯一属性来表示内联类的实例（关于运行时的内部表达请参阅下文）：",
      "",
      "",
      "// 不存在 'Password' 类的真实实例对象",
      "// 在运行时，'securePassword' 仅仅包含 'String'",
      "val securePassword = Password(\"Don't try this in production\")",
      "这就是内联类的主要特性，它灵感来源于 “inline” 这个名称：类的数据被 “内联”到该类使用的地方（类似于内联函数中的代码被内联到该函数调用的地方）。",
      "",
      "成员",
      "",
      "内联类支持普通类中的一些功能。特别是，内联类可以声明属性与函数：",
      "",
      "",
      "inline class Name(val s: String) {",
      "    val length: Int",
      "        get() = s.length",
      "​",
      "    fun greet() {",
      "        println(\"Hello, $s\")",
      "    }",
      "}    ",
      "​",
      "fun main() {",
      "    val name = Name(\"Kotlin\")",
      "    name.greet() // `greet` 方法会作为一个静态方法被调用",
      "    println(name.length) // 属性的 get 方法会作为一个静态方法被调用",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "然而，内联类的成员也有一些限制：",
      "",
      "内联类不能含有 init 代码块",
      "内联类不能含有幕后字段",
      "因此，内联类只能含有简单的计算属性（不能含有延迟初始化/委托属性）",
      "继承",
      "",
      "内联类允许去继承接口",
      "",
      "",
      "interface Printable {",
      "    fun prettyPrint(): String",
      "}",
      "​",
      "inline class Name(val s: String) : Printable {",
      "    override fun prettyPrint(): String = \"Let's $s!\"",
      "}    ",
      "​",
      "fun main() {",
      "    val name = Name(\"Kotlin\")",
      "    println(name.prettyPrint()) // 仍然会作为一个静态方法被调用",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "禁止内联类参与到类的继承关系结构中。这就意味着内联类不能继承其他的类而且必须是 final。"
    ]
  },
  "kt-委托": {
    "prefix": "kt-委托",
    "body": [
      "由委托实现",
      "",
      "委托模式已经证明是实现继承的一个很好的替代方式， 而 Kotlin 可以零样板代码地原生支持它。 Derived 类可以通过将其所有公有成员都委托给指定对象来实现一个接口 Base：",
      "",
      "",
      "interface Base {",
      "    fun print()",
      "}",
      "​",
      "class BaseImpl(val x: Int) : Base {",
      "    override fun print() { print(x) }",
      "}",
      "​",
      "class Derived(b: Base) : Base by b",
      "​",
      "fun main() {",
      "    val b = BaseImpl(10)",
      "    Derived(b).print()",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Derived 的超类型列表中的 by-子句表示 b 将会在 Derived 中内部存储， 并且编译器将生成转发给 b 的所有 Base 的方法。",
      "覆盖由委托实现的接口成员",
      "",
      "覆盖符合预期：编译器会使用 override 覆盖的实现而不是委托对象中的。如果将 override fun printMessage() { print(\"abc\") } 添加到 Derived，那么当调用 printMessage 时程序会输出“abc”而不是“10”：",
      "",
      "",
      "interface Base {",
      "    fun printMessage()",
      "    fun printMessageLine()",
      "}",
      "​",
      "class BaseImpl(val x: Int) : Base {",
      "    override fun printMessage() { print(x) }",
      "    override fun printMessageLine() { println(x) }",
      "}",
      "​",
      "class Derived(b: Base) : Base by b {",
      "    override fun printMessage() { print(\"abc\") }",
      "}",
      "​",
      "fun main() {",
      "    val b = BaseImpl(10)",
      "    Derived(b).printMessage()",
      "    Derived(b).printMessageLine()",
      "}",
      "但请注意，以这种方式重写的成员不会在委托对象的成员中调用 ，委托对象的成员只能访问其自身对接口成员实现：",
      "",
      "",
      "interface Base {",
      "    val message: String",
      "    fun print()",
      "}",
      "​",
      "class BaseImpl(val x: Int) : Base {",
      "    override val message = \"BaseImpl: x = $x\"",
      "    override fun print() { println(message) }",
      "}",
      "​",
      "class Derived(b: Base) : Base by b {",
      "    // 在 b 的 `print` 实现中不会访问到这个属性",
      "    override val message = \"Message of Derived\"",
      "}",
      "​",
      "fun main() {",
      "    val b = BaseImpl(10)",
      "    val derived = Derived(b)",
      "    derived.print()",
      "    println(derived.message)",
      "}",
      "BaseImpl: x = 10",
      "Message of Derived"
    ]
  },
  "kt-委托属性": {
    "prefix": "kt-委托属性",
    "body": [
      "class Example {",
      "    var p: String by Delegate()",
      "}",
      "import kotlin.reflect.KProperty",
      "",
      "class Delegate {",
      "    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {",
      "        return \"$thisRef, thank you for delegating '${property.name}' to me!\"",
      "    }",
      " ",
      "    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {",
      "        println(\"$value has been assigned to '${property.name}' in $thisRef.\")",
      "    }",
      "}"
    ]
  },
  "kt-延迟属性 Lazy": {
    "prefix": "kt-延迟属性 Lazy",
    "body": [
      "lazy() 是接受一个 lambda 并返回一个 Lazy <T> 实例的函数，返回的实例可以作为实现延迟属性的委托： 第一次调用 get() 会执行已传递给 lazy() 的 lambda 表达式并记录结果， 后续调用 get() 只是返回记录的结果。",
      "",
      "",
      "val lazyValue: String by lazy {",
      "    println(\"computed!\")",
      "    \"Hello\"",
      "}",
      "​",
      "fun main() {",
      "    println(lazyValue)",
      "    println(lazyValue)",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "默认情况下，对于 lazy 属性的求值是同步锁的（synchronized）：该值只在一个线程中计算，并且所有线程会看到相同的值。如果初始化委托的同步锁不是必需的，这样多个线程可以同时执行，那么将 LazyThreadSafetyMode.PUBLICATION 作为参数传递给 lazy() 函数。 而如果你确定初始化将总是发生在与属性使用位于相同的线程， 那么可以使用 LazyThreadSafetyMode.NONE 模式：它不会有任何线程安全的保证以及相关的开销。"
    ]
  },
  "kt-可观察属性 Observable": {
    "prefix": "kt-可观察属性 Observable",
    "body": [
      "Delegates.observable() 接受两个参数：初始值与修改时处理程序（handler）。 每当我们给属性赋值时会调用该处理程序（在赋值后执行）。它有三个参数：被赋值的属性、旧值与新值：",
      "",
      "",
      "import kotlin.properties.Delegates",
      "​",
      "class User {",
      "    var name: String by Delegates.observable(\"<no name>\") {",
      "        prop, old, new ->",
      "        println(\"$old -> $new\")",
      "    }",
      "}",
      "​",
      "fun main() {",
      "    val user = User()",
      "    user.name = \"first\"",
      "    user.name = \"second\"",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果你想截获赋值并“否决”它们，那么使用 vetoable() 取代 observable()。 在属性被赋新值生效之前会调用传递给 vetoable 的处理程序。"
    ]
  },
  "kt-把属性储存在映射中": {
    "prefix": "kt-把属性储存在映射中",
    "body": [
      "一个常见的用例是在一个映射（map）里存储属性的值。 这经常出现在像解析 JSON 或者做其他“动态”事情的应用中。 在这种情况下，你可以使用映射实例自身作为委托来实现委托属性。",
      "",
      "",
      "class User(val map: Map<String, Any?>) {",
      "    val name: String by map",
      "    val age: Int     by map",
      "}",
      "在这个例子中，构造函数接受一个映射参数：",
      "",
      "",
      "val user = User(mapOf(",
      "    \"name\" to \"John Doe\",",
      "    \"age\"  to 25",
      "))",
      "委托属性会从这个映射中取值（通过字符串键——属性的名称）：",
      "",
      "",
      "println(user.name) // Prints \"John Doe\"",
      "println(user.age)  // Prints 25",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这也适用于 var 属性，如果把只读的 Map 换成 MutableMap 的话：",
      "",
      "",
      "class MutableUser(val map: MutableMap<String, Any?>) {",
      "    var name: String by map",
      "    var age: Int     by map",
      "}"
    ]
  },
  "kt-函数ALL": {
    "prefix": "kt-函数ALL",
    "body": [
      "函数声明",
      "",
      "Kotlin 中的函数使用 fun 关键字声明：",
      "",
      "",
      "fun double(x: Int): Int {",
      "    return 2 * x",
      "}",
      "函数用法",
      "",
      "调用函数使用传统的方法：",
      "",
      "",
      "val result = double(2)",
      "调用成员函数使用点表示法：",
      "",
      "",
      "Stream().read() // 创建类 Stream 实例并调用 read()",
      "参数",
      "",
      "函数参数使用 Pascal 表示法定义，即 name: type。参数用逗号隔开。每个参数必须有显式类型：",
      "",
      "",
      "fun powerOf(number: Int, exponent: Int) { /*……*/ }",
      "默认参数",
      "",
      "函数参数可以有默认值，当省略相应的参数时使用默认值。与其他语言相比，这可以减少重载数量：",
      "",
      "",
      "fun read(b: Array<Byte>, off: Int = 0, len: Int = b.size) { /*……*/ }",
      "默认值通过类型后面的 = 及给出的值来定义。",
      "",
      "覆盖方法总是使用与基类型方法相同的默认参数值。 当覆盖一个带有默认参数值的方法时，必须从签名中省略默认参数值：",
      "",
      "",
      "open class A {",
      "    open fun foo(i: Int = 10) { /*……*/ }",
      "}",
      "​",
      "class B : A() {",
      "    override fun foo(i: Int) { /*……*/ }  // 不能有默认值",
      "}",
      "如果一个默认参数在一个无默认值的参数之前，那么该默认值只能通过使用具名参数调用该函数来使用：",
      "",
      "",
      "fun foo(bar: Int = 0, baz: Int) { /*……*/ }",
      "​",
      "foo(baz = 1) // 使用默认值 bar = 0",
      "如果在默认参数之后的最后一个参数是 lambda 表达式，那么它既可以作为具名参数在括号内传入，也可以在括号外传入：",
      "",
      "",
      "fun foo(bar: Int = 0, baz: Int = 1, qux: () -> Unit) { /*……*/ }",
      "​",
      "foo(1) { println(\"hello\") }     // 使用默认值 baz = 1",
      "foo(qux = { println(\"hello\") }) // 使用两个默认值 bar = 0 与 baz = 1",
      "foo { println(\"hello\") }        // 使用两个默认值 bar = 0 与 baz = 1",
      "具名参数",
      "",
      "可以在调用函数时使用具名的函数参数。当一个函数有大量的参数或默认参数时这会非常方便。",
      "",
      "给定以下函数：",
      "",
      "",
      "fun reformat(str: String,",
      "             normalizeCase: Boolean = true,",
      "             upperCaseFirstLetter: Boolean = true,",
      "             divideByCamelHumps: Boolean = false,",
      "             wordSeparator: Char = ' ') {",
      "/*……*/",
      "}",
      "我们可以使用默认参数来调用它：",
      "",
      "",
      "reformat(str)",
      "然而，当使用非默认参数调用它时，该调用看起来就像：",
      "",
      "",
      "reformat(str, true, true, false, '_')",
      "使用具名参数我们可以使代码更具有可读性：",
      "",
      "",
      "reformat(str,",
      "    normalizeCase = true,",
      "    upperCaseFirstLetter = true,",
      "    divideByCamelHumps = false,",
      "    wordSeparator = '_'",
      ")",
      "并且如果我们不需要所有的参数：",
      "",
      "",
      "reformat(str, wordSeparator = '_')",
      "当一个函数调用混用位置参数与具名参数时，所有位置参数都要放在第一个具名参数之前。例如，允许调用 f(1, y = 2) 但不允许 f(x = 1, 2)。",
      "",
      "可以通过使用星号操作符将可变数量参数（vararg） 以具名形式传入：",
      "",
      "",
      "fun foo(vararg strings: String) { /*……*/ }",
      "​",
      "foo(strings = *arrayOf(\"a\", \"b\", \"c\"))",
      "对于 JVM 平台：在调用 Java 函数时不能使用具名参数语法，因为 Java 字节码并不总是保留函数参数的名称。",
      "返回 Unit 的函数",
      "",
      "如果一个函数不返回任何有用的值，它的返回类型是 Unit。Unit 是一种只有一个值——Unit 的类型。这个值不需要显式返回：",
      "",
      "",
      "fun printHello(name: String?): Unit {",
      "    if (name != null)",
      "        println(\"Hello $name\")",
      "    else",
      "        println(\"Hi there!\")",
      "    // `return Unit` 或者 `return` 是可选的",
      "}",
      "Unit 返回类型声明也是可选的。上面的代码等同于：",
      "",
      "",
      "fun printHello(name: String?) { …… }",
      "单表达式函数",
      "",
      "当函数返回单个表达式时，可以省略花括号并且在 = 符号之后指定代码体即可：",
      "",
      "",
      "fun double(x: Int): Int = x * 2",
      "当返回值类型可由编译器推断时，显式声明返回类型是可选的：",
      "",
      "",
      "fun double(x: Int) = x * 2",
      "显式返回类型",
      "",
      "具有块代码体的函数必须始终显式指定返回类型，除非他们旨在返回 Unit，在这种情况下它是可选的。 Kotlin 不推断具有块代码体的函数的返回类型，因为这样的函数在代码体中可能有复杂的控制流，并且返回类型对于读者（有时甚至对于编译器）是不明显的。",
      "",
      "可变数量的参数（Varargs）",
      "",
      "函数的参数（通常是最后一个）可以用 vararg 修饰符标记：",
      "",
      "",
      "fun <T> asList(vararg ts: T): List<T> {",
      "    val result = ArrayList<T>()",
      "    for (t in ts) // ts is an Array",
      "        result.add(t)",
      "    return result",
      "}",
      "允许将可变数量的参数传递给函数：",
      "",
      "",
      "val list = asList(1, 2, 3)",
      "在函数内部，类型 T 的 vararg 参数的可见方式是作为 T 数组，即上例中的 ts 变量具有类型 Array <out T>。",
      "",
      "只有一个参数可以标注为 vararg。如果 vararg 参数不是列表中的最后一个参数， 可以使用具名参数语法传递其后的参数的值，或者，如果参数具有函数类型，则通过在括号外部传一个 lambda。",
      "",
      "当我们调用 vararg-函数时，我们可以一个接一个地传参，例如 asList(1, 2, 3)，或者，如果我们已经有一个数组并希望将其内容传给该函数，我们使用伸展（spread）操作符（在数组前面加 *）：",
      "",
      "",
      "val a = arrayOf(1, 2, 3)",
      "val list = asList(-1, 0, *a, 4)"
    ]
  },
  "kt-高阶函数与 lambda 表达式": {
    "prefix": "kt-高阶函数与 lambda 表达式",
    "body": [
      "函数类型",
      "",
      "Kotlin 使用类似 (Int) -> String 的一系列函数类型来处理函数的声明： val onClick: () -> Unit = ……。",
      "",
      "这些类型具有与函数签名相对应的特殊表示法，即它们的参数和返回值：",
      "",
      "所有函数类型都有一个圆括号括起来的参数类型列表以及一个返回类型：(A, B) -> C 表示接受类型分别为 A 与 B 两个参数并返回一个 C 类型值的函数类型。 参数类型列表可以为空，如 () -> A。Unit 返回类型不可省略。",
      "",
      "函数类型可以有一个额外的接收者类型，它在表示法中的点之前指定： 类型 A.(B) -> C 表示可以在 A 的接收者对象上以一个 B 类型参数来调用并返回一个 C 类型值的函数。 带有接收者的函数字面值通常与这些类型一起使用。",
      "",
      "挂起函数属于特殊种类的函数类型，它的表示法中有一个 suspend 修饰符 ，例如 suspend () -> Unit 或者 suspend A.(B) -> C。",
      "",
      "函数类型表示法可以选择性地包含函数的参数名：(x: Int, y: Int) -> Point。 这些名称可用于表明参数的含义。",
      "",
      "如需将函数类型指定为可空，请使用圆括号：((Int, Int) -> Int)?。",
      "",
      "函数类型可以使用圆括号进行接合：(Int) -> ((Int) -> Unit)",
      "",
      "箭头表示法是右结合的，(Int) -> (Int) -> Unit 与前述示例等价，但不等于 ((Int) -> (Int)) -> Unit。",
      "还可以通过使用类型别名给函数类型起一个别称：",
      "",
      "",
      "typealias ClickHandler = (Button, ClickEvent) -> Unit",
      "函数类型实例化",
      "",
      "有几种方法可以获得函数类型的实例：",
      "",
      "使用函数字面值的代码块，采用以下形式之一：",
      "lambda 表达式: { a, b -> a + b },",
      "匿名函数: fun(s: String): Int { return s.toIntOrNull() ?: 0 }",
      "带有接收者的函数字面值可用作带有接收者的函数类型的值。",
      "",
      "使用已有声明的可调用引用：",
      "顶层、局部、成员、扩展函数：::isOdd、 String::toInt，",
      "顶层、成员、扩展属性：List<Int>::size，",
      "构造函数：::Regex",
      "这包括指向特定实例成员的绑定的可调用引用：foo::toString。",
      "",
      "使用实现函数类型接口的自定义类的实例：",
      "",
      "class IntTransformer: (Int) -> Int {",
      "    override operator fun invoke(x: Int): Int = TODO()",
      "}",
      "​",
      "val intFunction: (Int) -> Int = IntTransformer()",
      "如果有足够信息，编译器可以推断变量的函数类型：",
      "",
      "",
      "val a = { i: Int -> i + 1 } // 推断出的类型是 (Int) -> Int",
      "带与不带接收者的函数类型非字面值可以互换，其中接收者可以替代第一个参数，反之亦然。例如，(A, B) -> C 类型的值可以传给或赋值给期待 A.(B) -> C 的地方，反之亦然：",
      "",
      "",
      "val repeatFun: String.(Int) -> String = { times -> this.repeat(times) }",
      "val twoParameters: (String, Int) -> String = repeatFun // OK",
      "​",
      "fun runTransformation(f: (String, Int) -> String): String {",
      "    return f(\"hello\", 3)",
      "}",
      "val result = runTransformation(repeatFun) // OK",
      "​",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "请注意，默认情况下推断出的是没有接收者的函数类型，即使变量是通过扩展函数引用来初始化的。 如需改变这点，请显式指定变量类型。",
      "函数类型实例调用",
      "",
      "函数类型的值可以通过其 invoke(……) 操作符调用：f.invoke(x) 或者直接 f(x)。",
      "",
      "如果该值具有接收者类型，那么应该将接收者对象作为第一个参数传递。 调用带有接收者的函数类型值的另一个方式是在其前面加上接收者对象， 就好比该值是一个扩展函数：1.foo(2)，",
      "",
      "例如：",
      "",
      "",
      "val stringPlus: (String, String) -> String = String::plus",
      "val intPlus: Int.(Int) -> Int = Int::plus",
      "​",
      "println(stringPlus.invoke(\"<-\", \"->\"))",
      "println(stringPlus(\"Hello, \", \"world!\")) ",
      "​",
      "println(intPlus.invoke(1, 1))",
      "println(intPlus(1, 2))",
      "println(2.intPlus(3)) // 类扩展调用",
      "​",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "内联函数",
      "",
      "有时使用内联函数可以为高阶函数提供灵活的控制流。",
      "",
      "Lambda 表达式与匿名函数",
      "",
      "lambda 表达式与匿名函数是“函数字面值”，即未声明的函数， 但立即做为表达式传递。考虑下面的例子：",
      "",
      "",
      "max(strings, { a, b -> a.length < b.length })",
      "函数 max 是一个高阶函数，它接受一个函数作为第二个参数。 其第二个参数是一个表达式，它本身是一个函数，即函数字面值，它等价于以下具名函数：",
      "",
      "",
      "fun compare(a: String, b: String): Boolean = a.length < b.length",
      "Lambda 表达式语法",
      "",
      "Lambda 表达式的完整语法形式如下：",
      "",
      "",
      "val sum: (Int, Int) -> Int = { x: Int, y: Int -> x + y }",
      "lambda 表达式总是括在花括号中， 完整语法形式的参数声明放在花括号内，并有可选的类型标注， 函数体跟在一个 -> 符号之后。如果推断出的该 lambda 的返回类型不是 Unit，那么该 lambda 主体中的最后一个（或可能是单个） 表达式会视为返回值。",
      "",
      "如果我们把所有可选标注都留下，看起来如下：",
      "",
      "",
      "val sum = { x: Int, y: Int -> x + y }",
      "传递末尾的 lambda 表达式",
      "",
      "在 Kotlin 中有一个约定：如果函数的最后一个参数是函数，那么作为相应参数传入的 lambda 表达式可以放在圆括号之外：",
      "",
      "",
      "val product = items.fold(1) { acc, e -> acc * e }",
      "这种语法也称为拖尾 lambda 表达式。",
      "",
      "如果该 lambda 表达式是调用时唯一的参数，那么圆括号可以完全省略：",
      "",
      "",
      "run { println(\"...\") }",
      "it：单个参数的隐式名称",
      "",
      "一个 lambda 表达式只有一个参数是很常见的。",
      "",
      "如果编译器自己可以识别出签名，也可以不用声明唯一的参数并忽略 ->。 该参数会隐式声明为 it：",
      "",
      "",
      "ints.filter { it > 0 } // 这个字面值是“(it: Int) -> Boolean”类型的",
      "从 lambda 表达式中返回一个值",
      "",
      "我们可以使用限定的返回语法从 lambda 显式返回一个值。 否则，将隐式返回最后一个表达式的值。",
      "",
      "因此，以下两个片段是等价的：",
      "",
      "",
      "ints.filter {",
      "    val shouldFilter = it > 0 ",
      "    shouldFilter",
      "}",
      "​",
      "ints.filter {",
      "    val shouldFilter = it > 0 ",
      "    return@filter shouldFilter",
      "}",
      "这一约定连同在圆括号外传递 lambda 表达式一起支持 LINQ-风格 的代码：",
      "",
      "",
      "strings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() }",
      "下划线用于未使用的变量（自 1.1 起）",
      "",
      "如果 lambda 表达式的参数未使用，那么可以用下划线取代其名称：",
      "",
      "",
      "map.forEach { _, value -> println(\"$value!\") }",
      "在 lambda 表达式中解构（自 1.1 起）",
      "",
      "在 lambda 表达式中解构是作为解构声明的一部分描述的。",
      "",
      "匿名函数",
      "",
      "上面提供的 lambda 表达式语法缺少的一个东西是指定函数的返回类型的能力。在大多数情况下，这是不必要的。因为返回类型可以自动推断出来。然而，如果确实需要显式指定，可以使用另一种语法： 匿名函数 。",
      "",
      "",
      "fun(x: Int, y: Int): Int = x + y",
      "匿名函数看起来非常像一个常规函数声明，除了其名称省略了。其函数体可以是表达式（如上所示）或代码块：",
      "",
      "",
      "fun(x: Int, y: Int): Int {",
      "    return x + y",
      "}",
      "参数和返回类型的指定方式与常规函数相同，除了能够从上下文推断出的参数类型可以省略：",
      "",
      "",
      "ints.filter(fun(item) = item > 0)",
      "匿名函数的返回类型推断机制与正常函数一样：对于具有表达式函数体的匿名函数将自动推断返回类型，而具有代码块函数体的返回类型必须显式指定（或者已假定为 Unit）。",
      "",
      "请注意，匿名函数参数总是在括号内传递。 允许将函数留在圆括号外的简写语法仅适用于 lambda 表达式。",
      "",
      "Lambda表达式与匿名函数之间的另一个区别是非局部返回的行为。一个不带标签的 return 语句总是在用 fun 关键字声明的函数中返回。这意味着 lambda 表达式中的 return 将从包含它的函数返回，而匿名函数中的 return 将从匿名函数自身返回。"
    ]
  },
  "kt-集合类型": {
    "prefix": "kt-集合类型",
    "body": [
      "val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")",
      "numbers.add(\"five\")   // 这是可以的",
      "//numbers = mutableListOf(\"six\", \"seven\")      // 编译错误",
      "fun printAll(strings: Collection<String>) {",
      "        for(s in strings) print(\"$s \")",
      "        println()",
      "    }",
      "    ",
      "fun main() {",
      "    val stringList = listOf(\"one\", \"two\", \"one\")",
      "    printAll(stringList)",
      "    ",
      "    val stringSet = setOf(\"one\", \"two\", \"three\")",
      "    printAll(stringSet)",
      "}"
    ]
  },
  "kt-List": {
    "prefix": "kt-List",
    "body": [
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "println(\"Number of elements: ${numbers.size}\")",
      "println(\"Third element: ${numbers.get(2)}\")",
      "println(\"Fourth element: ${numbers[3]}\")",
      "println(\"Index of element \\\"two\\\" ${numbers.indexOf(\"two\")}\")",
      "val bob = Person(\"Bob\", 31)",
      "val people = listOf<Person>(Person(\"Adam\", 20), bob, bob)",
      "val people2 = listOf<Person>(Person(\"Adam\", 20), Person(\"Bob\", 31), bob)",
      "println(people == people2)",
      "bob.age = 32",
      "println(people == people2)",
      "val numbers = mutableListOf(1, 2, 3, 4)",
      "numbers.add(5)",
      "numbers.removeAt(1)",
      "numbers[0] = 0",
      "numbers.shuffle()",
      "println(numbers)"
    ]
  },
  "kt-Set": {
    "prefix": "kt-Set",
    "body": [
      "val numbers = setOf(1, 2, 3, 4)",
      "println(\"Number of elements: ${numbers.size}\")",
      "if (numbers.contains(1)) println(\"1 is in the set\")",
      "",
      "val numbersBackwards = setOf(4, 3, 2, 1)",
      "println(\"The sets are equal: ${numbers == numbersBackwards}\")",
      "Set的默认实现 - LinkedHashSet – 保留元素插入的顺序。 因此，依赖于顺序的函数，例如 first() 或 last()，会在这些 set 上返回可预测的结果。",
      "",
      "val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation",
      "val numbersBackwards = setOf(4, 3, 2, 1)",
      "",
      "println(numbers.first() == numbersBackwards.first())",
      "println(numbers.first() == numbersBackwards.last())",
      "val numbers = setOf(1, 2, 3, 4)  // LinkedHashSet is the default implementation",
      "val numbersBackwards = setOf(4, 3, 2, 1)",
      "​",
      "println(numbers.first() == numbersBackwards.first())",
      "println(numbers.first() == numbersBackwards.last())"
    ]
  },
  "kt-Map": {
    "prefix": "kt-Map",
    "body": [
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)",
      "",
      "println(\"All keys: ${numbersMap.keys}\")",
      "println(\"All values: ${numbersMap.values}\")",
      "if (\"key2\" in numbersMap) println(\"Value by key \\\"key2\\\": ${numbersMap[\"key2\"]}\")    ",
      "if (1 in numbersMap.values) println(\"The value 1 is in the map\")",
      "if (numbersMap.containsValue(1)) println(\"The value 1 is in the map\") // 同上",
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)    ",
      "val anotherMap = mapOf(\"key2\" to 2, \"key1\" to 1, \"key4\" to 1, \"key3\" to 3)",
      "",
      "println(\"The maps are equal: ${numbersMap == anotherMap}\")",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)",
      "numbersMap.put(\"three\", 3)",
      "numbersMap[\"one\"] = 11",
      "",
      "println(numbersMap)"
    ]
  },
  "kt-构造集合": {
    "prefix": "kt-构造集合",
    "body": [
      "由元素构造",
      "创建集合的最常用方法是使用标准库函数 listOf<T>()、setOf<T>()、mutableListOf<T>()、mutableSetOf<T>()。 如果以逗号分隔的集合元素列表作为参数，编译器会自动检测元素类型。创建空集合时，须明确指定类型。",
      "",
      "setOf",
      "val numbersSet = setOf(\"one\", \"two\", \"three\", \"four\")",
      "val emptySet = mutableSetOf<String>()",
      "同样的，Map 也有这样的函数 mapOf() 与 mutableMapOf()。映射的键和值作为 Pair 对象传递（通常使用中缀函数 to 创建）。",
      "",
      " ",
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key4\" to 1)",
      "注意，to 符号创建了一个短时存活的 Pair 对象，因此建议仅在性能不重要时才使用它。 为避免过多的内存使用，请使用其他方法。例如，可以创建可写 Map 并使用写入操作填充它。 apply() 函数可以帮助保持初始化流畅。",
      "",
      "val numbersMap = mutableMapOf<String, String>().apply { this[\"one\"] = \"1\"; this[\"two\"] = \"2\" }"
    ]
  },
  "kt-空集合": {
    "prefix": "kt-空集合",
    "body": [
      "还有用于创建没有任何元素的集合的函数：emptyList()、emptySet() 与 emptyMap()。 创建空集合时，应指定集合将包含的元素类型。",
      "",
      "val empty = emptyList<String>()"
    ]
  },
  "kt-list 的初始化函数": {
    "prefix": "kt-list 的初始化函数",
    "body": [
      "对于 List，有一个接受 List 的大小与初始化函数的构造函数，该初始化函数根据索引定义元素的值。",
      "",
      "val doubled = List(3, { it * 2 })  // 如果你想操作这个集合，应使用 MutableList",
      "println(doubled)"
    ]
  },
  "kt-集合转换": {
    "prefix": "kt-集合转换",
    "body": [
      "val sourceList = mutableListOf(1, 2, 3)",
      "val copyList = sourceList.toMutableList()",
      "val readOnlyCopyList = sourceList.toList()",
      "sourceList.add(4)",
      "println(\"Copy size: ${copyList.size}\")   ",
      "",
      "//readOnlyCopyList.add(4)             // 编译异常",
      "println(\"Read-only copy size: ${readOnlyCopyList.size}\")",
      "val sourceList = mutableListOf(1, 2, 3)    ",
      "val copySet = sourceList.toMutableSet()",
      "copySet.add(3)",
      "copySet.add(4)    ",
      "println(copySet)"
    ]
  },
  "kt-迭代器": {
    "prefix": "kt-迭代器",
    "body": [
      "对于遍历集合元素， Kotlin 标准库支持 迭代器 的常用机制——对象可按顺序提供对元素的访问权限，而不会暴露集合的底层结构。 当需要逐个处理集合的所有元素（例如打印值或对其进行类似更新）时，迭代器非常有用。",
      "",
      "Iterable<T> 接口的继承者（包括 Set 与 List）可以通过调用 iterator() 函数获得迭代器。 一旦获得迭代器它就指向集合的第一个元素；调用 next() 函数将返回此元素，并将迭代器指向下一个元素（如果下一个元素存在）。 一旦迭代器通过了最后一个元素，它就不能再用于检索元素；也无法重新指向到以前的任何位置。要再次遍历集合，请创建一个新的迭代器。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val numbersIterator = numbers.iterator()",
      "while (numbersIterator.hasNext()) {",
      "    println(numbersIterator.next())",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "遍历 Iterable 集合的另一种方法是众所周知的 for 循环。在集合中使用 for 循环时，将隐式获取迭代器。因此，以下代码与上面的示例等效：",
      "",
      "for (item in numbers) {",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "for (item in numbers) {",
      "    println(item)",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "最后，有一个好用的 forEach() 函数，可自动迭代集合并为每个元素执行给定的代码。因此，等效的示例如下所示：",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "numbers.forEach {",
      "    println(it)",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "List 迭代器",
      "对于列表，有一个特殊的迭代器实现： ListIterator 它支持列表双向迭代：正向与反向。 反向迭代由 hasPrevious() 和 previous() 函数实现。 此外， ListIterator 通过 nextIndex() 与 previousIndex() 函数提供有关元素索引的信息。",
      "",
      " ",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val listIterator = numbers.listIterator()",
      "while (listIterator.hasNext()) listIterator.next()",
      "println(\"Iterating backwards:\")",
      "while (listIterator.hasPrevious()) {",
      "    print(\"Index: ${listIterator.previousIndex()}\")",
      "    println(\", value: ${listIterator.previous()}\")",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "具有双向迭代的能力意味着 ListIterator 在到达最后一个元素后仍可以使用。",
      "",
      "可变迭代器",
      "为了迭代可变集合，于是有了 MutableIterator 来扩展 Iterator 使其具有元素删除函数 remove() 。因此，可以在迭代时从集合中删除元素。",
      "",
      "remove",
      "val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\") ",
      "val mutableIterator = numbers.iterator()",
      "​",
      "mutableIterator.next()",
      "mutableIterator.remove()    ",
      "println(\"After removal: $numbers\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "除了删除元素， MutableListIterator 还可以在迭代列表时插入和替换元素。",
      "",
      "val numbers = mutableListOf(\"one\", \"four\", \"four\") ",
      "val mutableListIterator = numbers.listIterator()",
      "",
      "mutableListIterator.next()",
      "mutableListIterator.add(\"two\")",
      "mutableListIterator.next()",
      "mutableListIterator.set(\"three\")   ",
      "println(numbers)",
      "val numbers = mutableListOf(\"one\", \"four\", \"four\") ",
      "val mutableListIterator = numbers.listIterator()",
      "​",
      "mutableListIterator.next()",
      "mutableListIterator.add(\"two\")",
      "mutableListIterator.next()",
      "mutableListIterator.set(\"three\")   ",
      "println(numbers)"
    ]
  },
  "kt-区间与数列": {
    "prefix": "kt-区间与数列",
    "body": [
      "Kotlin 可通过调用 kotlin.ranges 包中的 rangeTo() 函数及其操作符形式的 .. 轻松地创建两个值的区间。 通常，rangeTo() 会辅以 in 或 !in 函数。",
      "",
      "if (i in 1..4) {  // 等同于 1 <= i && i <= 4",
      "",
      "if (i in 1..4) {  // 等同于 1 <= i && i <= 4",
      "    print(i)",
      "}",
      "整数类型区间（IntRange、LongRange、CharRange）还有一个拓展特性：可以对其进行迭代。 这些区间也是相应整数类型的等差数列。 这种区间通常用于 for 循环中的迭代。",
      "",
      "for (i in 1..4) print(i)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要反向迭代数字，请使用 downTo 函数而不是 .. 。",
      "",
      "for (i in 4 downTo 1) print(i)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "也可以通过任意步长（不一定为 1 ）迭代数字。 这是通过 step 函数完成的。",
      "",
      "for (i in 1..8 step 2) print(i)",
      "println()",
      "for (i in 8 downTo 1 step 2) print(i)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要迭代不包含其结束元素的数字区间，请使用 until 函数：",
      "",
      "for (i in 1 until 10) {       // i in [1, 10), 10被排除",
      "    print(i)",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "区间",
      "区间从数学意义上定义了一个封闭的间隔：它由两个端点值定义，这两个端点值都包含在该区间内。 区间是为可比较类型定义的：具有顺序，可以定义任意实例是否在两个给定实例之间的区间内。 区间的主要操作是 contains，通常以 in 与 !in 操作符的形式使用。",
      "",
      "要为类创建一个区间，请在区间起始值上调用 rangeTo() 函数，并提供结束值作为参数。 rangeTo() 通常以操作符 .. 形式调用。",
      "",
      "versionRange",
      "val versionRange = Version(1, 11)..Version(1, 30)",
      "println(Version(0, 9) in versionRange)",
      "println(Version(1, 20) in versionRange)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "数列",
      "如上个示例所示，整数类型的区间（例如 Int、Long 与 Char）可视为等差数列。 在 Kotlin 中，这些数列由特殊类型定义：IntProgression、LongProgression 与 CharProgression。",
      "",
      "数列具有三个基本属性：first 元素、last 元素和一个非零的 step。 首个元素为 first，后续元素是前一个元素加上一个 step。 以确定的步长在数列上进行迭代等效于 Java/JavaScript 中基于索引的 for 循环。",
      "",
      "for (int i = first; i <= last; i += step) {",
      "  // ……",
      "}",
      "for (int i = first; i <= last; i += step) {",
      "  // ……",
      "}",
      "通过迭代数列隐式创建区间时，此数列的 first 与 last 元素是区间的端点，step 为 1 。",
      "",
      "..",
      "for (i in 1..10) print(i)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要指定数列步长，请在区间上使用 step 函数。",
      "",
      " ",
      "for (i in 1..8 step 2) print(i)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "数列的 last 元素是这样计算的：",
      "",
      "对于正步长：不大于结束值且满足 (last - first) % step == 0 的最大值。",
      "对于负步长：不小于结束值且满足 (last - first) % step == 0 的最小值。",
      "因此，last 元素并非总与指定的结束值相同。",
      "",
      "for (i in 1..9 step 3) print(i) // 最后一个元素是 7",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要创建反向迭代的数列，请在定义其区间时使用 downTo 而不是 ..。",
      "",
      "for (i in 4 downTo 1) print(i)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "数列实现 Iterable<N>，其中 N 分别是 Int、Long 或 Char，因此可以在各种集合函数（如 map、filter 与其他）中使用它们。",
      "",
      "println((1..10).filter { it % 2 == 0 })",
      "println((1..10).filter { it % 2 == 0 })"
    ]
  },
  "kt-序列sequenceOf": {
    "prefix": "kt-序列sequenceOf",
    "body": [
      "由元素",
      "要创建一个序列，请调用 sequenceOf() 函数，列出元素作为其参数。",
      "",
      "sequenceOf",
      "val numbersSequence = sequenceOf(\"four\", \"three\", \"two\", \"one\")",
      "由 Iterable",
      "如果已经有一个 Iterable 对象（例如 List 或 Set），则可以通过调用 asSequence() 从而创建一个序列。",
      "",
      "val numbersSequence = numbers.asSequence()",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val numbersSequence = numbers.asSequence()",
      "由函数",
      "创建序列的另一种方法是通过使用计算其元素的函数来构建序列。 要基于函数构建序列，请以该函数作为参数调用 generateSequence()。 （可选）可以将第一个元素指定为显式值或函数调用的结果。 当提供的函数返回 null 时，序列生成停止。因此，以下示例中的序列是无限的。",
      "",
      "toList",
      "val oddNumbers = generateSequence(1) { it + 2 } // `it` 是上一个元素",
      "println(oddNumbers.take(5).toList())",
      "//println(oddNumbers.count())     // 错误：此序列是无限的。",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要使用 generateSequence() 创建有限序列，请提供一个函数，该函数在需要的最后一个元素之后返回 null。",
      "",
      "val oddNumbersLessThan10 = generateSequence(1) { if (it < 10) it + 2 else null }",
      "println(oddNumbersLessThan10.count())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "由组块",
      "最后，有一个函数可以逐个或按任意大小的组块生成序列元素——sequence() 函数。 此函数采用一个 lambda 表达式，其中包含 yield() 与 yieldAll() 函数的调用。 它们将一个元素返回给序列使用者，并暂停 sequence() 的执行，直到使用者请求下一个元素。 yield() 使用单个元素作为参数；yieldAll() 中可以采用 Iterable 对象、Iterable 或其他 Sequence。yieldAll() 的 Sequence 参数可以是无限的。 当然，这样的调用必须是最后一个：之后的所有调用都永远不会执行。",
      "",
      ").",
      "val oddNumbers = sequence {",
      "    yield(1)",
      "    yieldAll(listOf(3, 5))",
      "    yieldAll(generateSequence(7) { it + 2 })",
      "}",
      "println(oddNumbers.take(5).toList())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "序列操作",
      "关于序列操作，根据其状态要求可以分为以下几类：",
      "",
      "无状态 操作不需要状态，并且可以独立处理每个元素，例如 map() 或 filter()。 无状态操作还可能需要少量常数个状态来处理元素，例如 take() 与 drop()。",
      "有状态 操作需要大量状态，通常与序列中元素的数量成比例。",
      "如果序列操作返回延迟生成的另一个序列，则称为 中间序列。 否则，该操作为 末端 操作。 末端操作的示例为 toList() 或 sum()。只能通过末端操作才能检索序列元素。",
      "",
      "序列可以多次迭代；但是，某些序列实现可能会约束自己仅迭代一次。其文档中特别提到了这一点。",
      "",
      "序列处理示例",
      "我们通过一个示例来看 Iterable 与 Sequence 之间的区别。",
      "",
      "Iterable",
      "假定有一个单词列表。下面的代码过滤长于三个字符的单词，并打印前四个单词的长度。",
      "",
      "val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")",
      "val lengthsList = words.filter { println(\"filter: $it\"); it.length > 3 }",
      "    .map { println(\"length: ${it.length}\"); it.length }",
      "    .take(4)",
      "​",
      "println(\"Lengths of first 4 words longer than 3 chars:\")",
      "println(lengthsList)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "运行此代码时，会看到 filter() 与 map() 函数的执行顺序与代码中出现的顺序相同。 首先，将看到 filter：对于所有元素，然后是 length：对于在过滤之后剩余的元素，然后是最后两行的输出。 列表处理如下图：",
      "",
      "List processing",
      "",
      "Sequence",
      "现在用序列写相同的逻辑：",
      "",
      "val words = \"The quick brown fox jumps over the lazy dog\".split(\" \")",
      "// 将列表转换为序列",
      "val wordsSequence = words.asSequence()",
      "​",
      "val lengthsSequence = wordsSequence.filter { println(\"filter: $it\"); it.length > 3 }",
      "    .map { println(\"length: ${it.length}\"); it.length }",
      "    .take(4)",
      "​",
      "println(\"Lengths of first 4 words longer than 3 chars\")",
      "// 末端操作：以列表形式获取结果。",
      "println(lengthsSequence.toList())"
    ]
  },
  "kt-集合转换2": {
    "prefix": "kt-集合转换2",
    "body": [
      "Kotlin 标准库为集合 转换 提供了一组扩展函数。 这些函数根据提供的转换规则从现有集合中构建新集合。 在此页面中，我们将概述可用的集合转换函数。",
      "",
      "映射",
      "映射 转换从另一个集合的元素上的函数结果创建一个集合。 基本的映射函数是 map()。 它将给定的 lambda 函数应用于每个后续元素，并返回 lambda 结果列表。 结果的顺序与元素的原始顺序相同。 如需应用还要用到元素索引作为参数的转换，请使用 mapIndexed()。",
      "",
      "println(numbers.mapIndexed { idx, value -> value * idx })",
      "val numbers = setOf(1, 2, 3)",
      "println(numbers.map { it * 3 })",
      "println(numbers.mapIndexed { idx, value -> value * idx })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果转换在某些元素上产生 null 值，则可以通过调用 mapNotNull() 函数取代 map() 或 mapIndexedNotNull() 取代 mapIndexed() 来从结果集中过滤掉 null 值。",
      "",
      "val numbers = setOf(1, 2, 3)",
      "println(numbers.mapNotNull { if ( it == 2) null else it * 3 })",
      "println(numbers.mapIndexedNotNull { idx, value -> if (idx == 0) null else value * idx })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "映射转换时，有两个选择：转换键，使值保持不变，反之亦然。 要将指定转换应用于键，请使用 mapKeys()；反过来，mapValues() 转换值。 这两个函数都使用将映射条目作为参数的转换，因此可以操作其键与值。",
      "",
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)",
      "println(numbersMap.mapKeys { it.key.toUpperCase() })",
      "println(numbersMap.mapValues { it.value + it.key.length })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "双路合并",
      "双路合并 转换是根据两个集合中具有相同位置的元素构建配对。 在 Kotlin 标准库中，这是通过 zip() 扩展函数完成的。 在一个集合（或数组）上以另一个集合（或数组）作为参数调用时，zip() 返回 Pair 对象的列表（List）。 接收者集合的元素是这些配对中的第一个元素。 如果集合的大小不同，则 zip() 的结果为较小集合的大小；结果中不包含较大集合的后续元素。 zip() 也可以中缀形式调用 a zip b 。",
      "",
      "val colors = listOf(\"red\", \"brown\", \"grey\")",
      "val animals = listOf(\"fox\", \"bear\", \"wolf\")",
      "println(colors zip animals)",
      "​",
      "val twoAnimals = listOf(\"fox\", \"bear\")",
      "println(colors.zip(twoAnimals))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "也可以使用带有两个参数的转换函数来调用 zip()：接收者元素和参数元素。 在这种情况下，结果 List 包含在具有相同位置的接收者对和参数元素对上调用的转换函数的返回值。",
      "",
      "animal",
      "val colors = listOf(\"red\", \"brown\", \"grey\")",
      "val animals = listOf(\"fox\", \"bear\", \"wolf\")",
      "​",
      "println(colors.zip(animals) { color, animal -> \"The ${animal.capitalize()} is $color\"})",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "当拥有 Pair 的 List 时，可以进行反向转换 unzipping——从这些键值对中构建两个列表：",
      "",
      "第一个列表包含原始列表中每个 Pair 的键。",
      "第二个列表包含原始列表中每个 Pair 的值。",
      "要分割键值对列表，请调用 unzip()。",
      "",
      "println(numberPairs.unzip())",
      "val numberPairs = listOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"four\" to 4)",
      "println(numberPairs.unzip())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "关联",
      "关联 转换允许从集合元素和与其关联的某些值构建 Map。 在不同的关联类型中，元素可以是关联 Map 中的键或值。",
      "",
      "基本的关联函数 associateWith() 创建一个 Map，其中原始集合的元素是键，并通过给定的转换函数从中产生值。 如果两个元素相等，则仅最后一个保留在 Map 中。",
      "",
      "associateWith",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "println(numbers.associateWith { it.length })",
      "{one=3, two=3, three=5, four=4}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "为了使用集合元素作为值来构建 Map，有一个函数 associateBy()。 它需要一个函数，该函数根据元素的值返回键。如果两个元素相等，则仅最后一个保留在 Map 中。 还可以使用值转换函数来调用 associateBy()。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "println(numbers.associateBy { it.first().toUpperCase() })",
      "println(numbers.associateBy(keySelector = { it.first().toUpperCase() }, valueTransform = { it.length }))",
      "{O=one, T=three, F=four}",
      "{O=3, T=5, F=4}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "另一种构建 Map 的方法是使用函数 associate()，其中 Map 键和值都是通过集合元素生成的。 它需要一个 lambda 函数，该函数返回 Pair：键和相应 Map 条目的值。",
      "",
      "请注意，associate() 会生成临时的 Pair 对象，这可能会影响性能。 因此，当性能不是很关键或比其他选项更可取时，应使用 associate()。",
      "",
      "后者的一个示例：从一个元素一起生成键和相应的值。",
      "",
      "val names = listOf(\"Alice Adams\", \"Brian Brown\", \"Clara Campbell\")",
      "println(names.associate { name -> parseFullName(name).let { it.lastName to it.firstName } })  ",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "此时，首先在一个元素上调用一个转换函数，然后根据该函数结果的属性建立 Pair。",
      "",
      "打平",
      "如需操作嵌套的集合，则可能会发现提供对嵌套集合元素进行打平访问的标准库函数很有用。",
      "",
      "第一个函数为 flatten()。可以在一个集合的集合（例如，一个 Set 组成的 List）上调用它。 该函数返回嵌套集合中的所有元素的一个 List。",
      "",
      "println(numberSets.flatten())",
      "val numberSets = listOf(setOf(1, 2, 3), setOf(4, 5, 6), setOf(1, 2))",
      "println(numberSets.flatten())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "另一个函数——flatMap() 提供了一种灵活的方式来处理嵌套的集合。 它需要一个函数将一个集合元素映射到另一个集合。 因此，flatMap() 返回单个列表其中包含所有元素的值。 所以，flatMap() 表现为 map()（以集合作为映射结果）与 flatten() 的连续调用。",
      "",
      "val containers = listOf(",
      "    StringContainer(listOf(\"one\", \"two\", \"three\")),",
      "    StringContainer(listOf(\"four\", \"five\", \"six\")),",
      "    StringContainer(listOf(\"seven\", \"eight\"))",
      ")",
      "println(containers.flatMap { it.values })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "字符串表示",
      "如果需要以可读格式检索集合内容，请使用将集合转换为字符串的函数：joinToString() 与 joinTo()。",
      "",
      "joinToString() 根据提供的参数从集合元素构建单个 String。 joinTo() 执行相同的操作，但将结果附加到给定的 Appendable 对象。",
      "",
      "当使用默认参数调用时，函数返回的结果类似于在集合上调用 toString()：各元素的字符串表示形式以空格分隔而成的 String。",
      "",
      ")",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "println(numbers)         ",
      "println(numbers.joinToString())",
      "​",
      "val listString = StringBuffer(\"The list of numbers: \")",
      "numbers.joinTo(listString)",
      "println(listString)",
      "[one, two, three, four]",
      "one, two, three, four",
      "The list of numbers: one, two, three, four",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要构建自定义字符串表示形式，可以在函数参数 separator、prefix 与 postfix中指定其参数。 结果字符串将以 prefix 开头，以 postfix 结尾。除最后一个元素外，separator 将位于每个元素之后。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")    ",
      "println(numbers.joinToString(separator = \" | \", prefix = \"start: \", postfix = \": end\"))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "对于较大的集合，可能需要指定 limit ——将包含在结果中元素的数量。 如果集合大小超出 limit，所有其他元素将被 truncated 参数的单个值替换。",
      "",
      "val numbers = (1..100).toList()",
      "println(numbers.joinToString(limit = 10, truncated = \"<...>\"))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "最后，要自定义元素本身的表示形式，请提供 transform 函数。",
      "",
      "joinToString",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "println(numbers.joinToString { \"Element: ${it.toUpperCase()}\"})"
    ]
  },
  "kt-过滤filter": {
    "prefix": "kt-过滤filter",
    "body": [
      "过滤是最常用的集合处理任务之一。在Kotlin中，过滤条件由 谓词 定义——接受一个集合元素并且返回布尔值的 lambda 表达式：true 说明给定元素与谓词匹配，false 则表示不匹配。",
      "",
      "标准库包含了一组让你能够通过单个调用就可以过滤集合的扩展函数。这些函数不会改变原始集合，因此它们既可用于可变集合也可用于只读集合。为了操作过滤结果，应该在过滤后将其赋值给变量或链接其他函数。",
      "",
      "按谓词过滤",
      "基本的过滤函数是 filter()。当使用一个谓词来调用时，filter() 返回与其匹配的集合元素。对于 List 和 Set，过滤结果都是一个 List，对 Map 来说结果还是一个 Map。",
      "",
      "value",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")  ",
      "val longerThan3 = numbers.filter { it.length > 3 }",
      "println(longerThan3)",
      "​",
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)",
      "val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}",
      "println(filteredMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "filter() 中的谓词只能检查元素的值。如果想在过滤中使用元素在集合中的位置，应该使用 filterIndexed()。它接受一个带有两个参数的谓词：元素的索引和元素的值。",
      "",
      "如果想使用否定条件来过滤集合，请使用 filterNot()。它返回一个让谓词产生 false 的元素列表。",
      "",
      "val filteredNot = numbers.filterNot { it.length <= 3 }",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "val filteredIdx = numbers.filterIndexed { index, s -> (index != 0) && (s.length < 5)  }",
      "val filteredNot = numbers.filterNot { it.length <= 3 }",
      "​",
      "println(filteredIdx)",
      "println(filteredNot)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还有一些函数能够通过过滤给定类型的元素来缩小元素的类型：",
      "",
      "filterIsInstance() 返回给定类型的集合元素。在一个 List<Any> 上被调用时，filterIsInstance<T>() 返回一个 List<T>，从而让你能够在集合元素上调用 T 类型的函数。",
      "    println(it.toUpperCase())",
      "",
      "val numbers = listOf(null, 1, \"two\", 3.0, \"four\")",
      "println(\"All String elements in upper case:\")",
      "numbers.filterIsInstance<String>().forEach {",
      "    println(it.toUpperCase())",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "filterNotNull() 返回所有的非空元素。在一个 List<T?> 上被调用时，filterNotNull() 返回一个 List<T: Any>，从而让你能够将所有元素视为非空对象。",
      "val numbers = listOf(null, \"one\", \"two\", null)",
      "numbers.filterNotNull().forEach {",
      "    println(it.length)   // 对可空的 String 来说长度不可用",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "划分",
      "另一个过滤函数 – partition() – 通过一个谓词过滤集合并且将不匹配的元素存放在一个单独的列表中。因此，你得到一个 List 的 Pair 作为返回值：第一个列表包含与谓词匹配的元素并且第二个列表包含原始集合中的所有其他元素。",
      "",
      "partition",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val (match, rest) = numbers.partition { it.length > 3 }",
      "​",
      "println(match)",
      "println(rest)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "检验谓词",
      "最后，有些函数只是针对集合元素简单地检测一个谓词：",
      "",
      "如果至少有一个元素匹配给定谓词，那么 any() 返回 true。",
      "如果没有元素与给定谓词匹配，那么 none() 返回 true。",
      "如果所有元素都匹配给定谓词，那么 all() 返回 true。注意，在一个空集合上使用任何有效的谓词去调用 all() 都会返回 true 。这种行为在逻辑上被称为 vacuous truth。",
      "emptyList",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "println(numbers.any { it.endsWith(\"e\") })",
      "println(numbers.none { it.endsWith(\"a\") })",
      "println(numbers.all { it.endsWith(\"e\") })",
      "​",
      "println(emptyList<Int>().all { it > 5 })   // vacuous truth",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "any() 和 none() 也可以不带谓词使用：在这种情况下它们只是用来检查集合是否为空。 如果集合中有元素，any() 返回 true，否则返回 false；none() 则相反。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val empty = emptyList<String>()",
      "​",
      "println(numbers.any())",
      "println(empty.any())",
      "​",
      "println(numbers.none())",
      "println(empty.none())"
    ]
  },
  "kt-plus 与 minus 操作符": {
    "prefix": "kt-plus 与 minus 操作符",
    "body": [
      "在 Kotlin 中，为集合定义了 plus (+) 和 minus (-) 操作符。 它们把一个集合作为第一个操作数；第二个操作数可以是一个元素或者是另一个集合。 返回值是一个新的只读集合：",
      "",
      "plus 的结果包含原始集合 和 第二个操作数中的元素。",
      "minus 的结果包含原始集合中的元素，但第二个操作数中的元素 除外。 如果第二个操作数是一个元素，那么 minus 移除其在原始集合中的 第一次 出现；如果是一个集合，那么移除其元素在原始集合中的 所有 出现。",
      "val minusList = numbers - listOf(\"three\", \"four\")",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "val plusList = numbers + \"five\"",
      "val minusList = numbers - listOf(\"three\", \"four\")",
      "println(plusList)",
      "println(minusList)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "有关 map 的 plus 和 minus 操作符的详细信息，请参见 Map 相关操作。 也为集合定义了广义赋值操作符 plusAssign (+=) 和 minusAssign (-=)。 然而，对于只读集合，它们实际上使用 plus 或者 minus 操作符并尝试将结果赋值给同一变量。 因此，它们仅在由 var 声明的只读集合中可用。 对于可变集合，如果它是一个 val，那么它们会修改集合。更多详细信息请参见集合写操作。"
    ]
  },
  "kt-取集合的一部分slice": {
    "prefix": "kt-取集合的一部分slice",
    "body": [
      "Kotlin 标准库包含用于取集合的一部分的扩展函数。 这些函数提供了多种方法来选择结果集合的元素：显式列出其位置、指定结果大小等。",
      "",
      "Slice",
      "slice() 返回具有给定索引的集合元素列表。 索引既可以是作为区间传入的也可以是作为整数值的集合传入的。",
      "",
      "slice",
      "​",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")    ",
      "println(numbers.slice(1..3))",
      "println(numbers.slice(0..4 step 2))",
      "println(numbers.slice(setOf(3, 5, 0)))    ",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Take 与 drop",
      "要从头开始获取指定数量的元素，请使用 take() 函数。 要从尾开始获取指定数量的元素，请使用 takeLast()。 当调用的数字大于集合的大小时，两个函数都将返回整个集合。",
      "",
      "要从头或从尾去除给定数量的元素，请调用 drop() 或 dropLast() 函数。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")",
      "println(numbers.take(3))",
      "println(numbers.takeLast(3))",
      "println(numbers.drop(1))",
      "println(numbers.dropLast(5))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还可以使用谓词来定义要获取或去除的元素的数量。 有四个与上述功能相似的函数：",
      "",
      "takeWhile() 是带有谓词的 take()：它将不停获取元素直到排除与谓词匹配的首个元素。如果首个集合元素与谓词匹配，则结果为空。",
      "takeLastWhile() 与 takeLast() 类似：它从集合末尾获取与谓词匹配的元素区间。区间的首个元素是与谓词不匹配的最后一个元素右边的元素。如果最后一个集合元素与谓词匹配，则结果为空。",
      "dropWhile() 与具有相同谓词的 takeWhile() 相反：它将首个与谓词不匹配的元素返回到末尾。",
      "dropLastWhile() 与具有相同谓词的 takeLastWhile() 相反：它返回从开头到最后一个与谓词不匹配的元素。",
      "takeLastWhile",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")",
      "println(numbers.takeWhile { !it.startsWith('f') })",
      "println(numbers.takeLastWhile { it != \"three\" })",
      "println(numbers.dropWhile { it.length == 3 })",
      "println(numbers.dropLastWhile { it.contains('i') })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Chunked",
      "要将集合分解为给定大小的“块”，请使用 chunked() 函数。 chunked() 采用一个参数（块的大小），并返回一个 List 其中包含给定大小的 List。 第一个块从第一个元素开始并包含 size 元素，第二个块包含下一个 size 元素，依此类推。 最后一个块的大小可能较小。",
      "",
      "val numbers = (0..13).toList()",
      "println(numbers.chunked(3))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还可以立即对返回的块应用转换。 为此，请在调用 chunked() 时将转换作为 lambda 函数提供。 lambda 参数是集合的一块。当通过转换调用 chunked() 时， 这些块是临时的 List，应立即在该 lambda 中使用。",
      "",
      "val numbers = (0..13).toList() ",
      "println(numbers.chunked(3) { it.sum() })  // `it` 为原始集合的一个块",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Windowed",
      "可以检索给定大小的集合元素中所有可能区间。 获取它们的函数称为 windowed()：它返回一个元素区间列表，比如通过给定大小的滑动窗口查看集合，则会看到该区间。 与 chunked() 不同，windowed() 返回从每个集合元素开始的元素区间（窗口）。 所有窗口都作为单个 List 的元素返回。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    ",
      "println(numbers.windowed(3))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "windowed() 通过可选参数提供更大的灵活性：",
      "",
      "step 定义两个相邻窗口的第一个元素之间的距离。默认情况下，该值为 1，因此结果包含从所有元素开始的窗口。如果将 step 增加到 2，将只收到以奇数元素开头的窗口：第一个、第三个等。",
      "partialWindows 包含从集合末尾的元素开始的较小的窗口。例如，如果请求三个元素的窗口，就不能为最后两个元素构建它们。在本例中，启用 partialWindows 将包括两个大小为2与1的列表。",
      "最后，可以立即对返回的区间应用转换。 为此，在调用 windowed() 时将转换作为 lambda 函数提供。",
      "",
      "val numbers = (1..10).toList()",
      "println(numbers.windowed(3, step = 2, partialWindows = true))",
      "println(numbers.windowed(3) { it.sum() })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要构建两个元素的窗口，有一个单独的函数——zipWithNext()。 它创建接收器集合的相邻元素对。 请注意，zipWithNext() 不会将集合分成几对；它为 每个 元素创建除最后一个元素外的对，因此它在 [1, 2, 3, 4] 上的结果为 [[1, 2], [2, 3], [3, 4]]，而不是 [[1, 2]，[3, 4]]。 zipWithNext() 也可以通过转换函数来调用；它应该以接收者集合的两个元素作为参数。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")    ",
      "println(numbers.zipWithNext())",
      "println(numbers.zipWithNext() { s1, s2 -> s1.length > s2.length})"
    ]
  },
  "kt-取单个元素": {
    "prefix": "kt-取单个元素",
    "body": [
      "Kotlin 集合提供了一套从集合中检索单个元素的函数。 此页面描述的函数适用于 list 和 set。",
      "",
      "正如 list 的定义所言，list 是有序集合。 因此，list 中的每个元素都有其位置可供你引用。 除了此页面上描述的函数外，list 还提供了更广泛的一套方法去按索引检索和搜索元素。 有关更多详细信息，请参见 List 相关操作。",
      "",
      "反过来，从定义来看，set 并不是有序集合。 但是，Kotlin 中的 Set 按某些顺序存储元素。 这些可以是插入顺序（在 LinkedHashSet 中）、自然排序顺序（在 SortedSet 中）或者其他顺序。 一组元素的顺序也可以是未知的。 在这种情况下，元素仍会以某种顺序排序，因此，依赖元素位置的函数仍会返回其结果。 但是，除非调用者知道所使用的 Set 的具体实现，否则这些结果对于调用者是不可预测的。",
      "",
      "按位置取",
      "为了检索特定位置的元素，有一个函数 elementAt()。 用一个整数作为参数来调用它，你会得到给定位置的集合元素。 第一个元素的位置是 0，最后一个元素的位置是 (size - 1)。",
      "",
      "elementAt() 对于不提供索引访问或非静态已知提供索引访问的集合很有用。 在使用 List 的情况下，使用索引访问操作符 （get() 或 []）更为习惯。",
      "",
      "elementAt",
      "val numbers = linkedSetOf(\"one\", \"two\", \"three\", \"four\", \"five\")",
      "println(numbers.elementAt(3))    ",
      "​",
      "val numbersSortedSet = sortedSetOf(\"one\", \"two\", \"three\", \"four\")",
      "println(numbersSortedSet.elementAt(0)) // 元素以升序存储",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还有一些有用的别名来检索集合的第一个和最后一个元素：first() 和 last()。",
      "",
      "last",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")",
      "println(numbers.first())    ",
      "println(numbers.last())    ",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "为了避免在检索位置不存在的元素时出现异常，请使用 elementAt() 的安全变体：",
      "",
      "当指定位置超出集合范围时，elementAtOrNull() 返回 null。",
      "elementAtOrElse() 还接受一个 lambda 表达式，该表达式能将一个 Int 参数映射为一个集合元素类型的实例。 当使用一个越界位置来调用时，elementAtOrElse() 返回对给定值调用该 lambda 表达式的结果。",
      "elementAtOrElse",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\")",
      "println(numbers.elementAtOrNull(5))",
      "println(numbers.elementAtOrElse(5) { index -> \"The value for index $index is undefined\"})",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "按条件取",
      "函数 first() 和 last() 还可以让你在集合中搜索与给定谓词匹配的元素。 当你使用测试集合元素的谓词调用 first() 时，你会得到对其调用谓词产生 true 的第一个元素。 反过来，带有一个谓词的 last() 返回与其匹配的最后一个元素。",
      "",
      "println(numbers.first { it.length > 3 })",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")",
      "println(numbers.first { it.length > 3 })",
      "println(numbers.last { it.startsWith(\"f\") })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果没有元素与谓词匹配，两个函数都会抛异常。 为了避免它们，请改用 firstOrNull() 和 lastOrNull()：如果找不到匹配的元素，它们将返回 null。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")",
      "println(numbers.firstOrNull { it.length > 6 })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "或者，如果别名更适合你的情况，那么可以使用别名：",
      "",
      "使用 find() 代替 firstOrNull()",
      "使用 findLast() 代替 lastOrNull()",
      "val numbers = listOf(1, 2, 3, 4)",
      "println(numbers.find { it % 2 == 0 })",
      "println(numbers.findLast { it % 2 == 0 })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "随机取元素",
      "如果需要检索集合的一个随机元素，那么请调用 random() 函数。 你可以不带参数或者使用一个 Random 对象作为随机源来调用它。",
      "",
      "val numbers = listOf(1, 2, 3, 4)",
      "println(numbers.random())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "检测存在与否",
      "如需检查集合中某个元素的存在，可以使用 contains() 函数。 如果存在一个集合元素等于（equals()）函数参数，那么它返回 true。 你可以使用 in 关键字以操作符的形式调用 contains()。",
      "",
      "如需一次检查多个实例的存在，可以使用这些实例的集合作为参数调用 containsAll()。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")",
      "println(numbers.contains(\"four\"))",
      "println(\"zero\" in numbers)",
      "​",
      "println(numbers.containsAll(listOf(\"four\", \"two\")))",
      "println(numbers.containsAll(listOf(\"one\", \"zero\")))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "此外，你可以通过调用 isEmpty() 和 isNotEmpty() 来检查集合中是否包含任何元素。",
      "",
      "val empty = emptyList<String>()",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\")",
      "println(numbers.isEmpty())",
      "println(numbers.isNotEmpty())",
      "​",
      "val empty = emptyList<String>()",
      "println(empty.isEmpty())",
      "println(empty.isNotEmpty())"
    ]
  },
  "kt-集合排序": {
    "prefix": "kt-集合排序",
    "body": [
      "元素的顺序是某些集合类型的一个重要方面。 例如，如果拥有相同元素的两个列表的元素顺序不同，那么这两个列表也不相等。",
      "",
      "在 Kotlin 中，可以通过多种方式定义对象的顺序。",
      "",
      "首先，有 自然 顺序。它是为 Comparable 接口的继承者定义的。 当没有指定其他顺序时，使用自然顺序为它们排序。",
      "",
      "大多数内置类型是可比较的：",
      "",
      "数值类型使用传统的数值顺序：1 大于 0； -3.4f 大于 -5f，以此类推。",
      "Char 和 String 使用字典顺序： b 大于 a； world 大于 hello。",
      "如需为用户定义的类型定义一个自然顺序，可以让这个类型继承 Comparable。 这需要实现 compareTo() 函数。 compareTo() 必须将另一个具有相同类型的对象作为参数并返回一个整数值来显示哪个对象更大：",
      "",
      "正值表明接收者对象更大。",
      "负值表明它小于参数。",
      "0 说明对象相等。",
      "下面是一个类，可用于排序由主版本号和次版本号两部分组成的版本。",
      "",
      "minor",
      "class Version(val major: Int, val minor: Int): Comparable<Version> {",
      "    override fun compareTo(other: Version): Int {",
      "        if (this.major != other.major) {",
      "            return this.major - other.major",
      "        } else if (this.minor != other.minor) {",
      "            return this.minor - other.minor",
      "        } else return 0",
      "    }",
      "}",
      "​",
      "fun main() {    ",
      "    println(Version(1, 2) > Version(1, 3))",
      "    println(Version(2, 0) > Version(1, 5))",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "自定义 顺序让你可以按自己喜欢的方式对任何类型的实例进行排序。 特别是，你可以为不可比较类型定义顺序，或者为可比较类型定义非自然顺序。 如需为类型定义自定义顺序，可以为其创建一个 Comparator。 Comparator 包含 compare() 函数：它接受一个类的两个实例并返回它们之间比较的整数结果。 如上所述，对结果的解释与 compareTo() 的结果相同。",
      "",
      "println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))",
      "val lengthComparator = Comparator { str1: String, str2: String -> str1.length - str2.length }",
      "println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(lengthComparator))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "有了 lengthComparator，你可以按照字符串的长度而不是默认的字典顺序来排列字符串。",
      "",
      "定义一个 Comparator 的一种比较简短的方式是标准库中的 compareBy() 函数。 compareBy() 接受一个 lambda 表达式，该表达式从一个实例产生一个 Comparable 值，并将自定义顺序定义为生成值的自然顺序。 使用 compareBy()，上面示例中的长度比较器如下所示：",
      "",
      "​",
      "println(listOf(\"aaa\", \"bb\", \"c\").sortedWith(compareBy { it.length }))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Kotlin 集合包提供了用于按照自然顺序、自定义顺序甚至随机顺序对集合排序的函数。 在此页面上，我们将介绍适用于只读集合的排序函数。 这些函数将它们的结果作为一个新集合返回，集合里包含了按照请求顺序排序的来自原始集合的元素。 如果想学习就地对可变集合排序的函数，请参见 List 相关操作。",
      "",
      "自然顺序",
      "基本的函数 sorted() 和 sortedDescending() 返回集合的元素，这些元素按照其自然顺序升序和降序排序。 这些函数适用于 Comparable 元素的集合。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "println(\"Sorted ascending: ${numbers.sorted()}\")",
      "println(\"Sorted descending: ${numbers.sortedDescending()}\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "自定义顺序",
      "为了按照自定义顺序排序或者对不可比较对象排序，可以使用函数 sortedBy() 和 sortedByDescending()。 它们接受一个将集合元素映射为 Comparable 值的选择器函数，并以该值的自然顺序对集合排序。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "val sortedNumbers = numbers.sortedBy { it.length }",
      "println(\"Sorted by length ascending: $sortedNumbers\")",
      "val sortedByLast = numbers.sortedByDescending { it.last() }",
      "println(\"Sorted by the last letter descending: $sortedByLast\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如需为集合排序定义自定义顺序，可以提供自己的 Comparator。 为此，调用传入 Comparator 的 sortedWith() 函数。 使用此函数，按照字符串长度排序如下所示：",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "println(\"Sorted by length ascending: ${numbers.sortedWith(compareBy { it.length })}\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "倒序",
      "你可以使用 reversed() 函数以相反的顺序检索集合。",
      "",
      "reversed",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "println(numbers.reversed())",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "reversed() 返回带有元素副本的新集合。 因此，如果你之后改变了原始集合，这并不会影响先前获得的 reversed() 的结果。",
      "",
      "另一个反向函数——asReversed()——返回相同集合实例的一个反向视图，因此，如果原始列表不会发生变化，那么它会比 reversed() 更轻量，更合适。",
      "",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val reversedNumbers = numbers.asReversed()",
      "println(reversedNumbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果原始列表是可变的，那么其所有更改都会反映在其反向视图中，反之亦然。",
      "",
      "val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")",
      "val reversedNumbers = numbers.asReversed()",
      "println(reversedNumbers)",
      "numbers.add(\"five\")",
      "println(reversedNumbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "但是，如果列表的可变性未知或者源根本不是一个列表，那么 reversed() 更合适，因为其结果是一个未来不会更改的副本。",
      "",
      "随机顺序",
      "最后，shuffled() 函数返回一个包含了以随机顺序排序的集合元素的新的 List。 你可以不带参数或者使用 Random 对象来调用它。",
      "",
      "numbers",
      "val numbers = listOf(\"one\", \"two\", \"three\", \"four\")",
      "println(numbers.shuffled())"
    ]
  },
  "kt-集合聚合操作": {
    "prefix": "kt-集合聚合操作",
    "body": [
      "Kotlin 集合包含用于常用的 聚合操作 （基于集合内容返回单个值的操作）的函数 。 其中大多数是众所周知的，并且其工作方式与在其他语言中相同。",
      "",
      "min() 与 max() 分别返回最小和最大的元素；",
      "average() 返回数字集合中元素的平均值；",
      "sum() 返回数字集合中元素的总和；",
      "count() 返回集合中元素的数量；",
      "listOf",
      "val numbers = listOf(6, 42, 10, 4)",
      "​",
      "println(\"Count: ${numbers.count()}\")",
      "println(\"Max: ${numbers.max()}\")",
      "println(\"Min: ${numbers.min()}\")",
      "println(\"Average: ${numbers.average()}\")",
      "println(\"Sum: ${numbers.sum()}\")",
      "Count: 4",
      "Max: 42",
      "Min: 4",
      "Average: 15.5",
      "Sum: 62",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还有一些通过某些选择器函数或自定义 Comparator 来检索最小和最大元素的函数。",
      "",
      "maxBy()/minBy() 接受一个选择器函数并返回使选择器返回最大或最小值的元素。",
      "maxWith()/minWith() 接受一个 Comparator 对象并且根据此 Comparator 对象返回最大或最小元素。",
      "val numbers = listOf(5, 42, 10, 4)",
      "val min3Remainder = numbers.minBy { it % 3 }",
      "println(min3Remainder)",
      "​",
      "val strings = listOf(\"one\", \"two\", \"three\", \"four\")",
      "val longestString = strings.maxWith(compareBy { it.length })",
      "println(longestString)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "此外，有一些高级的求和函数，它们接受一个函数并返回对所有元素调用此函数的返回值的总和：",
      "",
      "sumBy() 使用对集合元素调用返回 Int 值的函数。",
      "sumByDouble() 与返回 Double 的函数一起使用。",
      "​",
      "val numbers = listOf(5, 42, 10, 4)",
      "println(numbers.sumBy { it * 2 })",
      "println(numbers.sumByDouble { it.toDouble() / 2 })",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Fold 与 reduce",
      "对于更特定的情况，有函数 reduce() 和 fold()，它们依次将所提供的操作应用于集合元素并返回累积的结果。 操作有两个参数：先前的累积值和集合元素。",
      "",
      "这两个函数的区别在于：fold() 接受一个初始值并将其用作第一步的累积值，而 reduce() 的第一步则将第一个和第二个元素作为第一步的操作参数。",
      "",
      ",",
      "val numbers = listOf(5, 2, 10, 4)",
      "​",
      "val sum = numbers.reduce { sum, element -> sum + element }",
      "println(sum)",
      "val sumDoubled = numbers.fold(0) { sum, element -> sum + element * 2 }",
      "println(sumDoubled)",
      "​",
      "//val sumDoubledReduce = numbers.reduce { sum, element -> sum + element * 2 } //错误：第一个元素在结果中没有加倍",
      "//println(sumDoubledReduce)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "上面的实例展示了区别：fold() 用于计算加倍的元素之和。 如果将相同的函数传给 reduce()，那么它会返回另一个结果，因为在第一步中它将列表的第一个和第二个元素作为参数，所以第一个元素不会被加倍。",
      "",
      "如需将函数以相反的顺序应用于元素，可以使用函数 reduceRight() 和 foldRight() 它们的工作方式类似于 fold() 和 reduce()，但从最后一个元素开始，然后再继续到前一个元素。 记住，在使用 foldRight 或 reduceRight 时，操作参数会更改其顺序：第一个参数变为元素，然后第二个参数变为累积值。",
      "",
      "val numbers = listOf(5, 2, 10, 4)",
      "val sumDoubledRight = numbers.foldRight(0) { element, sum -> sum + element * 2 }",
      "println(sumDoubledRight)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "你还可以使用将元素索引作为参数的操作。 为此，使用函数 reduceIndexed() 和 foldIndexed() 传递元素索引作为操作的第一个参数。",
      "",
      "最后，还有将这些操作从右到左应用于集合元素的函数——reduceRightIndexed() 与 foldRightIndexed()。",
      "",
      "val numbers = listOf(5, 2, 10, 4)",
      "val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }",
      "println(sumEven)",
      "",
      "val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }",
      "println(sumEvenRight)",
      "val numbers = listOf(5, 2, 10, 4)",
      "val sumEven = numbers.foldIndexed(0) { idx, sum, element -> if (idx % 2 == 0) sum + element else sum }",
      "println(sumEven)",
      "​",
      "val sumEvenRight = numbers.foldRightIndexed(0) { idx, element, sum -> if (idx % 2 == 0) sum + element else sum }",
      "println(sumEvenRight)"
    ]
  },
  "kt-集合写操作": {
    "prefix": "kt-集合写操作",
    "body": [
      "集合写操作",
      "可变集合支持更改集合内容的操作，例如添加或删除元素。 在此页面上，我们将描述实现 MutableCollection 的所有写操作。 有关 List 与 Map 可用的更多特定操作，请分别参见 List 相关操作与 Map 相关操作。",
      "",
      "添加元素",
      "要将单个元素添加到列表或集合，请使用 add() 函数。指定的对象将添加到集合的末尾。",
      "",
      "numbers.add(5)",
      "",
      "val numbers = mutableListOf(1, 2, 3, 4)",
      "numbers.add(5)",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "addAll() 将参数对象的每个元素添加到列表或集合中。参数可以是 Iterable、Sequence 或 Array。 接收者的类型和参数可能不同，例如，你可以将所有内容从 Set 添加到 List。",
      "",
      "当在列表上调用时，addAll() 会按照在参数中出现的顺序添加各个新元素。 你也可以调用 addAll() 时指定一个元素位置作为第一参数。 参数集合的第一个元素会被插入到这个位置。 其他元素将跟随在它后面，将接收者元素移到末尾。",
      "",
      "setOf",
      "val numbers = mutableListOf(1, 2, 5, 6)",
      "numbers.addAll(arrayOf(7, 8))",
      "println(numbers)",
      "numbers.addAll(2, setOf(3, 4))",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "你还可以使用 plus 运算符 - plusAssign (+=) 添加元素。 当应用于可变集合时，+= 将第二个操作数(一个元素或另一个集合)追加到集合的末尾。",
      "",
      "listOf",
      "val numbers = mutableListOf(\"one\", \"two\")",
      "numbers += \"three\"",
      "println(numbers)",
      "numbers += listOf(\"four\", \"five\")    ",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "删除元素",
      "若要从可变集合中移除元素，请使用 remove() 函数。 remove() 接受元素值，并删除该值的一个匹配项。",
      "",
      "numbers",
      "val numbers = mutableListOf(1, 2, 3, 4, 3)",
      "numbers.remove(3)                    // 删除了第一个 `3`",
      "println(numbers)",
      "numbers.remove(5)                    // 什么都没删除",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要一次删除多个元素，有以下函数：",
      "",
      "removeAll() 移除参数集合中存在的所有元素。 或者，你可以用谓词作为参数来调用它；在这种情况下，函数移除谓词产生 true 的所有元素。",
      "retainAll() 与 removeAll() 相反：它移除除参数集合中的元素之外的所有元素。 当与谓词一起使用时，它只留下与之匹配的元素。",
      "clear() 从列表中移除所有元素并将其置空。",
      "numbers",
      "val numbers = mutableListOf(1, 2, 3, 4)",
      "println(numbers)",
      "numbers.retainAll { it >= 3 }",
      "println(numbers)",
      "numbers.clear()",
      "println(numbers)",
      "​",
      "val numbersSet = mutableSetOf(\"one\", \"two\", \"three\", \"four\")",
      "numbersSet.removeAll(setOf(\"one\", \"two\"))",
      "println(numbersSet)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "从集合中移除元素的另一种方法是使用 minusAssign (-=) ——原地修改版的 minus 操作符。 minus 操作符。 第二个参数可以是元素类型的单个实例或另一个集合。 右边是单个元素时，-= 会移除它的第一个匹配项。 反过来，如果它是一个集合，那么它的所有元素的每次出现都会删除。 例如，如果列表包含重复的元素，它们将被同时删除。 第二个操作数可以包含集合中不存在的元素。这些元素不会影响操作的执行。",
      "",
      "listOf",
      "val numbers = mutableListOf(\"one\", \"two\", \"three\", \"three\", \"four\")",
      "numbers -= \"three\"",
      "println(numbers)",
      "numbers -= listOf(\"four\", \"five\")    ",
      "//numbers -= listOf(\"four\")    // 与上述相同",
      "println(numbers)    ",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "更新元素",
      "list 和 map 还提供更新元素的操作。 它们在 List 相关操作与 Map 相关操作中有所描述。 对于 set 来说，更新没有意义，因为它实际上是移除一个元素并添加另一个元素。"
    ]
  },
  "kt-List 相关操作": {
    "prefix": "kt-List 相关操作",
    "body": [
      "List 相关操作",
      "List 是 Kotlin 标准库中最受欢迎的集合类型。对列表元素的索引访问为 List 提供了一组强大的操作。",
      "",
      "按索引取元素",
      "List 支持按索引取元素的所有常用操作： elementAt() 、 first() 、 last() 与取单个元素中列出的其他操作。 List 的特点是能通过索引访问特定元素，因此读取元素的最简单方法是按索引检索它。 这是通过 get() 函数或简写语法 [index] 来传递索引参数完成的。",
      "",
      "如果 List 长度小于指定的索引，则抛出异常。 另外，还有两个函数能避免此类异常：",
      "",
      "getOrElse() 提供用于计算默认值的函数，如果集合中不存在索引，则返回默认值。",
      "getOrNull() 返回 null 作为默认值。",
      "println(numbers[0])",
      "",
      "val numbers = listOf(1, 2, 3, 4)",
      "println(numbers.get(0))",
      "println(numbers[0])",
      "//numbers.get(5)                         // exception!",
      "println(numbers.getOrNull(5))             // null",
      "println(numbers.getOrElse(5, {it}))        // 5",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "取列表的一部分",
      "除了取集合的一部分中常用的操作， List 还提供 subList() 该函数将指定元素范围的视图作为列表返回。 因此，如果原始集合的元素发生变化，则它在先前创建的子列表中也会发生变化，反之亦然。",
      "",
      "println(numbers.subList(3, 6))",
      "val numbers = (0..13).toList()",
      "println(numbers.subList(3, 6))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "查找元素位置",
      "线性查找",
      "在任何列表中，都可以使用 indexOf() 或 lastIndexOf() 函数找到元素的位置。 它们返回与列表中给定参数相等的元素的第一个或最后一个位置。 如果没有这样的元素，则两个函数均返回 -1。",
      "",
      "))",
      "val numbers = listOf(1, 2, 3, 4, 2, 5)",
      "println(numbers.indexOf(2))",
      "println(numbers.lastIndexOf(2))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还有一对函数接受谓词并搜索与之匹配的元素：",
      "",
      "indexOfFirst() 返回与谓词匹配的第一个元素的索引，如果没有此类元素，则返回 -1。",
      "indexOfLast() 返回与谓词匹配的最后一个元素的索引，如果没有此类元素，则返回 -1。",
      "val numbers = mutableListOf(1, 2, 3, 4)",
      "println(numbers.indexOfFirst { it > 2})",
      "println(numbers.indexOfLast { it % 2 == 1})",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "在有序列表中二分查找",
      "还有另一种搜索列表中元素的方法——二分查找算法。 它的工作速度明显快于其他内置搜索功能，但要求该列表按照一定的顺序（自然排序或函数参数中提供的另一种排序）按升序排序过。 否则，结果是不确定的。",
      "",
      "要搜索已排序列表中的元素，请调用 binarySearch() 函数，并将该值作为参数传递。 如果存在这样的元素，则函数返回其索引；否则，将返回 (-insertionPoint - 1)，其中 insertionPoint 为应插入此元素的索引，以便列表保持排序。 如果有多个具有给定值的元素，搜索则可以返回其任何索引。",
      "",
      "还可以指定要搜索的索引区间：在这种情况下，该函数仅在两个提供的索引之间搜索。",
      "",
      "binarySearch",
      "val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")",
      "numbers.sort()",
      "println(numbers)",
      "println(numbers.binarySearch(\"two\"))  // 3",
      "println(numbers.binarySearch(\"z\")) // -5",
      "println(numbers.binarySearch(\"two\", 0, 2))  // -3",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Comparator 二分搜索",
      "如果列表元素不是 Comparable，则应提供一个用于二分搜索的 Comparator。 该列表必须根据此 Comparator 以升序排序。来看一个例子：",
      "",
      "\",",
      "val productList = listOf(",
      "    Product(\"WebStorm\", 49.0),",
      "    Product(\"AppCode\", 99.0),",
      "    Product(\"DotTrace\", 129.0),",
      "    Product(\"ReSharper\", 149.0))",
      "​",
      "println(productList.binarySearch(Product(\"AppCode\", 99.0), compareBy<Product> { it.price }.thenBy { it.name }))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "这是一个不可排序的 Product 实例列表，以及一个定义排序的 Comparator：如果 p1 的价格小于 p2 的价格，则产品 p1 在产品 p2 之前。 因此，按照此顺序对列表进行升序排序后，使用 binarySearch() 查找指定的 Product的索引。",
      "",
      "当列表使用与自然排序不同的顺序时（例如，对 String 元素不区分大小写的顺序），自定义 Comparator 也很方便。",
      "",
      "val colors = listOf(\"Blue\", \"green\", \"ORANGE\", \"Red\", \"yellow\")",
      "println(colors.binarySearch(\"RED\", String.CASE_INSENSITIVE_ORDER)) // 3",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "比较函数二分搜索",
      "使用 比较 函数的二分搜索无需提供明确的搜索值即可查找元素。 取而代之的是，它使用一个比较函数将元素映射到 Int 值，并搜索函数返回 0 的元素。 该列表必须根据提供的函数以升序排序；换句话说，比较的返回值必须从一个列表元素增长到下一个列表元素。",
      "",
      "data class Product(val name: String, val price: Double)",
      "​",
      "fun priceComparison(product: Product, price: Double) = sign(product.price - price).toInt()",
      "​",
      "fun main() {",
      "    val productList = listOf(",
      "        Product(\"WebStorm\", 49.0),",
      "        Product(\"AppCode\", 99.0),",
      "        Product(\"DotTrace\", 129.0),",
      "        Product(\"ReSharper\", 149.0))",
      "​",
      "    println(productList.binarySearch { priceComparison(it, 99.0) })",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "Comparator 与比较函数二分搜索都可以针对列表区间执行。",
      "",
      "List 写操作",
      "除了集合写操作中描述的集合修改操作之外，可变列表还支持特定的写操作。 这些操作使用索引来访问元素以扩展列表修改功能。",
      "",
      "添加",
      "要将元素添加到列表中的特定位置，请使用 add() 或 addAll() 并提供元素插入的位置作为附加参数。 位置之后的所有元素都将向右移动。",
      "",
      "val numbers = mutableListOf(\"one\", \"five\", \"six\")",
      "numbers.add(1, \"two\")",
      "numbers.addAll(2, listOf(\"three\", \"four\"))",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "更新",
      "列表还提供了在指定位置替换元素的函数——set() 及其操作符形式 []。set() 不会更改其他元素的索引。",
      "",
      "mutableListOf",
      "val numbers = mutableListOf(\"one\", \"five\", \"three\")",
      "numbers[1] =  \"two\"",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "fill() 简单地将所有集合元素的值替换为指定值。",
      "",
      "val numbers = mutableListOf(1, 2, 3, 4)",
      "numbers.fill(3)",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "删除",
      "要从列表中删除指定位置的元素，请使用 removeAt() 函数，并将位置作为参数。 在元素被删除之后出现的所有元素索引将减 1。",
      "",
      "val numbers = mutableListOf(1, 2, 3, 4, 3)    ",
      "numbers.removeAt(1)",
      "println(numbers)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "排序",
      "在集合排序中，描述了按特定顺序检索集合元素的操作。 对于可变列表，标准库中提供了类似的扩展函数，这些扩展函数可以执行相同的排序操作。 将此类操作应用于列表实例时，它将更改指定实例中元素的顺序。",
      "",
      "就地排序函数的名称与应用于只读列表的函数的名称相似，但没有 ed/d 后缀：",
      "",
      "sort* 在所有排序函数的名称中代替 sorted*：sort()、sortDescending()、sortBy() 等等。",
      "shuffle() 代替 shuffled()。",
      "reverse() 代替 reversed()。",
      "asReversed() 在可变列表上调用会返回另一个可变列表，该列表是原始列表的反向视图。在该视图中的更改将反映在原始列表中。 以下示例展示了可变列表的排序函数：",
      "",
      "to ascending: $numbers\")",
      "numbers.sortDescending()",
      "println(\"Sort into descending: $numbers\")",
      "",
      "numbers.sortBy { it.length }",
      "println(\"Sort into ascending by length: $numbers\")",
      "numbers.sortByDescending { it.last() }",
      "println(\"Sort into descending by the last letter: $numbers\")",
      "",
      "numbers.sortWith(compareBy<String> { it.length }.thenBy { it })",
      "println(\"Sort by Comparator: $numbers\")",
      "",
      "numbers.shuffle()",
      "println(\"Shuffle: $numbers\")",
      "",
      "numbers.reverse()",
      "val numbers = mutableListOf(\"one\", \"two\", \"three\", \"four\")",
      "​",
      "numbers.sort()",
      "println(\"Sort into ascending: $numbers\")",
      "numbers.sortDescending()",
      "println(\"Sort into descending: $numbers\")",
      "​",
      "numbers.sortBy { it.length }",
      "println(\"Sort into ascending by length: $numbers\")",
      "numbers.sortByDescending { it.last() }",
      "println(\"Sort into descending by the last letter: $numbers\")",
      "​",
      "numbers.sortWith(compareBy<String> { it.length }.thenBy { it })",
      "println(\"Sort by Comparator: $numbers\")",
      "​",
      "numbers.shuffle()",
      "println(\"Shuffle: $numbers\")",
      "​",
      "numbers.reverse()",
      "println(\"Reverse: $numbers\")"
    ]
  },
  "kt-Set 相关操作": {
    "prefix": "kt-Set 相关操作",
    "body": [
      "Kotlin 集合包中包含 set 常用操作的扩展函数：查找交集、并集或差集。",
      "",
      "要将两个集合合并为一个（并集），可使用 union() 函数。也能以中缀形式使用 a union b。 注意，对于有序集合，操作数的顺序很重要：在结果集合中，左侧操作数在前。",
      "",
      "要查找两个集合中都存在的元素（交集），请使用 intersect() 。 要查找另一个集合中不存在的集合元素（差集），请使用 subtract() 。 这两个函数也能以中缀形式调用，例如， a intersect b 。",
      "",
      "val numbers = setOf(\"one\", \"two\", \"three\")",
      "​",
      "println(numbers union setOf(\"four\", \"five\"))",
      "println(setOf(\"four\", \"five\") union numbers)",
      "​",
      "println(numbers intersect setOf(\"two\", \"one\"))",
      "println(numbers subtract setOf(\"three\", \"four\"))",
      "println(numbers subtract setOf(\"four\", \"three\")) // 相同的输出",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "注意， List 也支持 Set 操作。 但是，对 List 进行 Set 操作的结果仍然是 Set ，因此将删除所有重复的元素。"
    ]
  },
  "kt-Map 相关操作": {
    "prefix": "kt-Map 相关操作",
    "body": [
      "在 map 中，键和值的类型都是用户定义的。 对基于键的访问启用了各种特定于 map 的处理函数，从键获取值到对键和值进行单独过滤。 在此页面上，我们提供了来自标准库的 map 处理功能的描述。",
      "",
      "取键与值",
      "要从 Map 中检索值，必须提供其键作为 get() 函数的参数。 还支持简写 [key] 语法。 如果找不到给定的键，则返回 null 。 还有一个函数 getValue() ，它的行为略有不同：如果在 Map 中找不到键，则抛出异常。 此外，还有两个选项可以解决键缺失的问题：",
      "",
      "getOrElse() 与 list 的工作方式相同：对于不存在的键，其值由给定的 lambda 表达式返回。",
      "getOrDefault() 如果找不到键，则返回指定的默认值。",
      "five",
      "val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "println(numbersMap.get(\"one\"))",
      "println(numbersMap[\"one\"])",
      "println(numbersMap.getOrDefault(\"four\", 10))",
      "println(numbersMap[\"five\"])               // null",
      "//numbersMap.getValue(\"six\")      // exception!",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要对 map 的所有键或所有值执行操作，可以从属性 keys 和 values 中相应地检索它们。 keys 是 Map 中所有键的集合， values 是 Map 中所有值的集合。",
      "",
      "values",
      "val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "println(numbersMap.keys)",
      "println(numbersMap.values)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "过滤",
      "可以使用 filter() 函数来过滤 map 或其他集合。 对 map 使用 filter() 函数时， Pair 将作为参数的谓词传递给它。 它将使用谓词同时过滤其中的键和值。",
      "",
      "val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}",
      "",
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)",
      "val filteredMap = numbersMap.filter { (key, value) -> key.endsWith(\"1\") && value > 10}",
      "println(filteredMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还有两种用于过滤 map 的特定函数：按键或按值。 这两种方式，都有对应的函数： filterKeys() 和 filterValues() 。 两者都将返回一个新 Map ，其中包含与给定谓词相匹配的条目。 filterKeys() 的谓词仅检查元素键， filterValues() 的谓词仅检查值。",
      "",
      "val numbersMap = mapOf(\"key1\" to 1, \"key2\" to 2, \"key3\" to 3, \"key11\" to 11)",
      "val filteredKeysMap = numbersMap.filterKeys { it.endsWith(\"1\") }",
      "val filteredValuesMap = numbersMap.filterValues { it < 10 }",
      "​",
      "println(filteredKeysMap)",
      "println(filteredValuesMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "plus 与 minus 操作",
      "由于需要访问元素的键，plus（+）与 minus（-）运算符对 map 的作用与其他集合不同。 plus 返回包含两个操作数元素的 Map ：左侧的 Map 与右侧的 Pair 或另一个 Map 。 当右侧操作数中有左侧 Map 中已存在的键时，该条目将使用右侧的值。",
      "",
      "println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))",
      "val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "println(numbersMap + Pair(\"four\", 4))",
      "println(numbersMap + Pair(\"one\", 10))",
      "println(numbersMap + mapOf(\"five\" to 5, \"one\" to 11))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "minus 将根据左侧 Map 条目创建一个新 Map ，右侧操作数带有键的条目将被剔除。 因此，右侧操作数可以是单个键或键的集合： list 、 set 等。",
      "",
      "val numbersMap = mapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "println(numbersMap - \"one\")",
      "println(numbersMap - listOf(\"two\", \"four\"))",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "关于在可变 Map 中使用 plusAssign（+=）与 minusAssign（-=）运算符的详细信息，请参见 Map 写操作 。",
      "",
      "Map 写操作",
      "Mutable Map （可变 Map ）提供特定的 Map 写操作。 这些操作使你可以使用键来访问或更改 Map 值。",
      "",
      "Map 写操作的一些规则：",
      "",
      "值可以更新。 反过来，键也永远不会改变：添加条目后，键是不变的。",
      "每个键都有一个与之关联的值。也可以添加和删除整个条目。",
      "下面是对可变 Map 中可用写操作的标准库函数的描述。",
      "",
      "添加与更新条目",
      "要将新的键值对添加到可变 Map ，请使用 put() 。 将新条目放入 LinkedHashMap （Map的默认实现）后，会添加该条目，以便在 Map 迭代时排在最后。 在 Map 类中，新元素的位置由其键顺序定义。",
      "",
      "numbersMap",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)",
      "numbersMap.put(\"three\", 3)",
      "println(numbersMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "要一次添加多个条目，请使用 putAll() 。它的参数可以是 Map 或一组 Pair ： Iterable 、 Sequence 或 Array 。",
      "",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "numbersMap.putAll(setOf(\"four\" to 4, \"five\" to 5))",
      "println(numbersMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "如果给定键已存在于 Map 中，则 put() 与 putAll() 都将覆盖值。 因此，可以使用它们来更新 Map 条目的值。",
      "",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)",
      "val previousValue = numbersMap.put(\"one\", 11)",
      "println(\"value associated with 'one', before: $previousValue, after: ${numbersMap[\"one\"]}\")",
      "println(numbersMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还可以使用快速操作符将新条目添加到 Map 。 有两种方式：",
      "",
      "plusAssign （+=） 操作符。",
      "[] 操作符为 put() 的别名。",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2)",
      "numbersMap[\"three\"] = 3     // 调用 numbersMap.put(\"three\", 3)",
      "numbersMap += mapOf(\"four\" to 4, \"five\" to 5)",
      "println(numbersMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "使用 Map 中存在的键进行操作时，将覆盖相应条目的值。",
      "",
      "删除条目",
      "要从可变 Map 中删除条目，请使用 remove() 函数。 调用 remove() 时，可以传递键或整个键值对。 如果同时指定键和值，则仅当键值都匹配时，才会删除此的元素。",
      "",
      "numbersMap.remove(\"three\", 4)            //不会删除任何条目",
      "",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "numbersMap.remove(\"one\")",
      "println(numbersMap)",
      "numbersMap.remove(\"three\", 4)            //不会删除任何条目",
      "println(numbersMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "还可以通过键或值从可变 Map 中删除条目。 在 Map 的 .keys 或 .values 中调用 remove() 并提供键或值来删除条目。 在 .values 中调用时， remove() 仅删除给定值匹配到的的第一个条目。",
      "",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3, \"threeAgain\" to 3)",
      "numbersMap.keys.remove(\"one\")",
      "println(numbersMap)",
      "numbersMap.values.remove(3)",
      "println(numbersMap)",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "minusAssign （-=） 操作符也可用于可变 Map 。",
      "",
      "numbersMap",
      "val numbersMap = mutableMapOf(\"one\" to 1, \"two\" to 2, \"three\" to 3)",
      "numbersMap -= \"two\"",
      "println(numbersMap)",
      "numbersMap -= \"five\"             //不会删除任何条目",
      "println(numbersMap)"
    ]
  },
  "kt-协程取消与超时": {
    "prefix": "kt-协程取消与超时",
    "body": [
      "取消与超时",
      "这一部分包含了协程的取消与超时。",
      "",
      "取消协程的执行",
      "在一个长时间运行的应用程序中，你也许需要对你的后台协程进行细粒度的控制。 比如说，一个用户也许关闭了一个启动了协程的界面，那么现在协程的执行结果已经不再被需要了，这时，它应该是可以被取消的。 该 launch 函数返回了一个可以被用来取消运行中的协程的 Job：",
      "",
      "job.join() // 等待作业执行结束",
      "",
      "val job = launch {",
      "    repeat(1000) { i ->",
      "        println(\"job: I'm sleeping $i ...\")",
      "        delay(500L)",
      "    }",
      "}",
      "delay(1300L) // 延迟一段时间",
      "println(\"main: I'm tired of waiting!\")",
      "job.cancel() // 取消该作业",
      "job.join() // 等待作业执行结束",
      "println(\"main: Now I can quit.\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "程序执行后的输出如下：",
      "",
      "job: I'm sleeping 0 ...",
      "job: I'm sleeping 1 ...",
      "job: I'm sleeping 2 ...",
      "main: I'm tired of waiting!",
      "main: Now I can quit.",
      "一旦 main 函数调用了 job.cancel，我们在其它的协程中就看不到任何输出，因为它被取消了。 这里也有一个可以使 Job 挂起的函数 cancelAndJoin 它合并了对 cancel 以及 join 的调用。",
      "",
      "取消是协作的",
      "协程的取消是 协作 的。一段协程代码必须协作才能被取消。 所有 kotlinx.coroutines 中的挂起函数都是 可被取消的 。它们检查协程的取消， 并在取消时抛出 CancellationException。 然而，如果协程正在执行计算任务，并且没有检查取消的话，那么它是不能被取消的，就如如下示例代码所示：",
      "",
      "val startTime = System.currentTimeMillis()",
      "val job = launch(Dispatchers.Default) {",
      "    var nextPrintTime = startTime",
      "    var i = 0",
      "    while (i < 5) { // 一个执行计算的循环，只是为了占用 CPU",
      "        // 每秒打印消息两次",
      "        if (System.currentTimeMillis() >= nextPrintTime) {",
      "            println(\"job: I'm sleeping ${i++} ...\")",
      "            nextPrintTime += 500L",
      "        }",
      "    }",
      "}",
      "delay(1300L) // 等待一段时间",
      "println(\"main: I'm tired of waiting!\")",
      "job.cancelAndJoin() // 取消一个作业并且等待它结束",
      "println(\"main: Now I can quit.\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "运行示例代码，并且我们可以看到它连续打印出了“I'm sleeping”，甚至在调用取消后， 作业仍然执行了五次循环迭代并运行到了它结束为止。",
      "",
      "使计算代码可取消",
      "我们有两种方法来使执行计算的代码可以被取消。第一种方法是定期调用挂起函数来检查取消。对于这种目的 yield 是一个好的选择。 另一种方法是显式的检查取消状态。让我们试试第二种方法。",
      "",
      "将前一个示例中的 while (i < 5) 替换为 while (isActive) 并重新运行它。",
      "",
      "val startTime = System.currentTimeMillis()",
      "val job = launch(Dispatchers.Default) {",
      "    var nextPrintTime = startTime",
      "    var i = 0",
      "    while (isActive) { // 可以被取消的计算循环",
      "        // 每秒打印消息两次",
      "        if (System.currentTimeMillis() >= nextPrintTime) {",
      "            println(\"job: I'm sleeping ${i++} ...\")",
      "            nextPrintTime += 500L",
      "        }",
      "    }",
      "}",
      "delay(1300L) // 等待一段时间",
      "println(\"main: I'm tired of waiting!\")",
      "job.cancelAndJoin() // 取消该作业并等待它结束",
      "println(\"main: Now I can quit.\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "你可以看到，现在循环被取消了。isActive 是一个可以被使用在 CoroutineScope 中的扩展属性。",
      "",
      "在 finally 中释放资源",
      "我们通常使用如下的方法处理在被取消时抛出 CancellationException 的可被取消的挂起函数。比如说，try {……} finally {……} 表达式以及 Kotlin 的 use 函数一般在协程被取消的时候执行它们的终结动作：",
      "",
      "val job = launch {",
      "    try {",
      "        repeat(1000) { i ->",
      "            println(\"job: I'm sleeping $i ...\")",
      "            delay(500L)",
      "        }",
      "    } finally {",
      "        println(\"job: I'm running finally\")",
      "    }",
      "}",
      "delay(1300L) // 延迟一段时间",
      "println(\"main: I'm tired of waiting!\")",
      "job.cancelAndJoin() // 取消该作业并且等待它结束",
      "println(\"main: Now I can quit.\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "join 和 cancelAndJoin 等待了所有的终结动作执行完毕， 所以运行示例得到了下面的输出：",
      "",
      "job: I'm sleeping 0 ...",
      "job: I'm sleeping 1 ...",
      "job: I'm sleeping 2 ...",
      "main: I'm tired of waiting!",
      "job: I'm running finally",
      "main: Now I can quit.",
      "运行不能取消的代码块",
      "在前一个例子中任何尝试在 finally 块中调用挂起函数的行为都会抛出 CancellationException，因为这里持续运行的代码是可以被取消的。通常，这并不是一个问题，所有良好的关闭操作（关闭一个文件、取消一个作业、或是关闭任何一种通信通道）通常都是非阻塞的，并且不会调用任何挂起函数。然而，在真实的案例中，当你需要挂起一个被取消的协程，你可以将相应的代码包装在 withContext(NonCancellable) {……} 中，并使用 withContext 函数以及 NonCancellable 上下文，见如下示例所示：",
      "",
      "val job = launch {",
      "    try {",
      "        repeat(1000) { i ->",
      "            println(\"job: I'm sleeping $i ...\")",
      "            delay(500L)",
      "        }",
      "    } finally {",
      "        withContext(NonCancellable) {",
      "            println(\"job: I'm running finally\")",
      "            delay(1000L)",
      "            println(\"job: And I've just delayed for 1 sec because I'm non-cancellable\")",
      "        }",
      "    }",
      "}",
      "delay(1300L) // 延迟一段时间",
      "println(\"main: I'm tired of waiting!\")",
      "job.cancelAndJoin() // 取消该作业并等待它结束",
      "println(\"main: Now I can quit.\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "超时",
      "在实践中绝大多数取消一个协程的理由是它有可能超时。 当你手动追踪一个相关 Job 的引用并启动了一个单独的协程在延迟后取消追踪，这里已经准备好使用 withTimeout 函数来做这件事。 来看看示例代码：",
      "",
      "500L",
      "withTimeout(1300L) {",
      "    repeat(1000) { i ->",
      "        println(\"I'm sleeping $i ...\")",
      "        delay(500L)",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "运行后得到如下输出：",
      "",
      "I'm sleeping 0 ...",
      "I'm sleeping 1 ...",
      "I'm sleeping 2 ...",
      "Exception in thread \"main\" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms",
      "withTimeout 抛出了 TimeoutCancellationException，它是 CancellationException 的子类。 我们之前没有在控制台上看到堆栈跟踪信息的打印。这是因为在被取消的协程中 CancellationException 被认为是协程执行结束的正常原因。 然而，在这个示例中我们在 main 函数中正确地使用了 withTimeout。",
      "",
      "由于取消只是一个例外，所有的资源都使用常用的方法来关闭。 如果你需要做一些各类使用超时的特别的额外操作，可以使用类似 withTimeout 的 withTimeoutOrNull 函数，并把这些会超时的代码包装在 try {...} catch (e: TimeoutCancellationException) {...} 代码块中，而 withTimeoutOrNull 通过返回 null 来进行超时操作，从而替代抛出一个异常：",
      "",
      "val result = withTimeoutOrNull(1300L) {",
      "    repeat(1000) { i ->",
      "        println(\"I'm sleeping $i ...\")",
      "        delay(500L)",
      "    }",
      "    \"Done\" // 在它运行得到结果之前取消它",
      "}",
      "println(\"Result is $result\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "运行这段代码时不再抛出异常：",
      "",
      "I'm sleeping 0 ...",
      "I'm sleeping 1 ...",
      "I'm sleeping 2 ...",
      "Result is null"
    ]
  },
  "kt-协程组合挂起函数": {
    "prefix": "kt-协程组合挂起函数",
    "body": [
      "组合挂起函数",
      "本节介绍了将挂起函数组合的各种方法。",
      "",
      "默认顺序调用",
      "假设我们在不同的地方定义了两个进行某种调用远程服务或者进行计算的挂起函数。我们只假设它们都是有用的，但是实际上它们在这个示例中只是为了该目的而延迟了一秒钟：",
      "",
      "    delay(1000L) // 假设我们在这里做了一些有用的事",
      "",
      "suspend fun doSomethingUsefulOne(): Int {",
      "    delay(1000L) // 假设我们在这里做了一些有用的事",
      "    return 13",
      "}",
      "​",
      "suspend fun doSomethingUsefulTwo(): Int {",
      "    delay(1000L) // 假设我们在这里也做了一些有用的事",
      "    return 29",
      "}",
      "如果需要按 顺序 调用它们，我们接下来会做什么——首先调用 doSomethingUsefulOne 接下来 调用 doSomethingUsefulTwo，并且计算它们结果的和吗？ 实际上，如果我们要根据第一个函数的结果来决定是否我们需要调用第二个函数或者决定如何调用它时，我们就会这样做。",
      "",
      "我们使用普通的顺序来进行调用，因为这些代码是运行在协程中的，只要像常规的代码一样 顺序 都是默认的。下面的示例展示了测量执行两个挂起函数所需要的总时间：",
      "",
      "doSomethingUsefulTwo",
      "val time = measureTimeMillis {",
      "    val one = doSomethingUsefulOne()",
      "    val two = doSomethingUsefulTwo()",
      "    println(\"The answer is ${one + two}\")",
      "}",
      "println(\"Completed in $time ms\")",
      "The answer is 42",
      "Completed in 2012 ms",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "它的打印输出如下：",
      "",
      "The answer is 42",
      "Completed in 2017 ms",
      "使用 async 并发",
      "如果 doSomethingUsefulOne 与 doSomethingUsefulTwo 之间没有依赖，并且我们想更快的得到结果，让它们进行 并发 吗？这就是 async 可以帮助我们的地方。",
      "",
      "在概念上，async 就类似于 launch。它启动了一个单独的协程，这是一个轻量级的线程并与其它所有的协程一起并发的工作。不同之处在于 launch 返回一个 Job 并且不附带任何结果值，而 async 返回一个 Deferred —— 一个轻量级的非阻塞 future， 这代表了一个将会在稍后提供结果的 promise。你可以使用 .await() 在一个延期的值上得到它的最终结果， 但是 Deferred 也是一个 Job，所以如果需要的话，你可以取消它。",
      "",
      "}",
      "",
      "val time = measureTimeMillis {",
      "    val one = async { doSomethingUsefulOne() }",
      "    val two = async { doSomethingUsefulTwo() }",
      "    println(\"The answer is ${one.await() + two.await()}\")",
      "}",
      "println(\"Completed in $time ms\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "它的打印输出如下：",
      "",
      "The answer is 42",
      "Completed in 1017 ms",
      "这里快了两倍，因为两个协程并发执行。 请注意，使用协程进行并发总是显式的。",
      "",
      "惰性启动的 async",
      "可选的，async 可以通过将 start 参数设置为 CoroutineStart.LAZY 而变为惰性的。 在这个模式下，只有结果通过 await 获取的时候协程才会启动，或者在 Job 的 start 函数调用的时候。运行下面的示例：",
      "",
      "start",
      "val time = measureTimeMillis {",
      "    val one = async(start = CoroutineStart.LAZY) { doSomethingUsefulOne() }",
      "    val two = async(start = CoroutineStart.LAZY) { doSomethingUsefulTwo() }",
      "    // 执行一些计算",
      "    one.start() // 启动第一个",
      "    two.start() // 启动第二个",
      "    println(\"The answer is ${one.await() + two.await()}\")",
      "}",
      "println(\"Completed in $time ms\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "它的打印输出如下：",
      "",
      "The answer is 42",
      "Completed in 1017 ms",
      "因此，在先前的例子中这里定义的两个协程没有执行，但是控制权在于程序员准确的在开始执行时调用 start。我们首先 调用 one，然后调用 two，接下来等待这个协程执行完毕。",
      "",
      "注意，如果我们只是在 println 中调用 await，而没有在单独的协程中调用 start，这将会导致顺序行为，直到 await 启动该协程 执行并等待至它结束，这并不是惰性的预期用例。 在计算一个值涉及挂起函数时，这个 async(start = CoroutineStart.LAZY) 的用例用于替代标准库中的 lazy 函数。",
      "",
      "async 风格的函数",
      "我们可以定义异步风格的函数来 异步 的调用 doSomethingUsefulOne 和 doSomethingUsefulTwo 并使用 async 协程建造器并带有一个显式的 GlobalScope 引用。 我们给这样的函数的名称中加上“……Async”后缀来突出表明：事实上，它们只做异步计算并且需要使用延期的值来获得结果。",
      "",
      "    doSomethingUsefulTwo()",
      "",
      "// somethingUsefulOneAsync 函数的返回值类型是 Deferred<Int>",
      "fun somethingUsefulOneAsync() = GlobalScope.async {",
      "    doSomethingUsefulOne()",
      "}",
      "​",
      "// somethingUsefulTwoAsync 函数的返回值类型是 Deferred<Int>",
      "fun somethingUsefulTwoAsync() = GlobalScope.async {",
      "    doSomethingUsefulTwo()",
      "}",
      "注意，这些 xxxAsync 函数不是 挂起 函数。它们可以在任何地方使用。 然而，它们总是在调用它们的代码中意味着异步（这里的意思是 并发 ）执行。",
      "",
      "下面的例子展示了它们在协程的外面是如何使用的：",
      "",
      "  val time = measureTimeMillis {",
      "        // 我们可以在协程外面启动异步执行",
      "        val one = somethingUsefulOneAsync()",
      "        val two = somethingUsefulTwoAsync()",
      "        // 但是等待结果必须调用其它的挂起或者阻塞",
      "        // 当我们等待结果的时候，这里我们使用 `runBlocking { …… }` 来阻塞主线程",
      "        runBlocking {",
      "            println(\"The answer is ${one.await() + two.await()}\")",
      "        }",
      "    }",
      "    println(\"Completed in $time ms\")",
      "// 注意，在这个示例中我们在 `main` 函数的右边没有加上 `runBlocking`",
      "fun main() {",
      "    val time = measureTimeMillis {",
      "        // 我们可以在协程外面启动异步执行",
      "        val one = somethingUsefulOneAsync()",
      "        val two = somethingUsefulTwoAsync()",
      "        // 但是等待结果必须调用其它的挂起或者阻塞",
      "        // 当我们等待结果的时候，这里我们使用 `runBlocking { …… }` 来阻塞主线程",
      "        runBlocking {",
      "            println(\"The answer is ${one.await() + two.await()}\")",
      "        }",
      "    }",
      "    println(\"Completed in $time ms\")",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "这种带有异步函数的编程风格仅供参考，因为这在其它编程语言中是一种受欢迎的风格。在 Kotlin 的协程中使用这种风格是强烈不推荐的， 原因如下所述。",
      "",
      "考虑一下如果 val one = somethingUsefulOneAsync() 这一行和 one.await() 表达式这里在代码中有逻辑错误， 并且程序抛出了异常以及程序在操作的过程中中止，将会发生什么。 通常情况下，一个全局的异常处理者会捕获这个异常，将异常打印成日记并报告给开发者，但是反之该程序将会继续执行其它操作。但是这里我们的 somethingUsefulOneAsync 仍然在后台执行， 尽管如此，启动它的那次操作也会被终止。这个程序将不会进行结构化并发，如下一小节所示。",
      "",
      "使用 async 的结构化并发",
      "让我们使用使用 async 的并发这一小节的例子并且提取出一个函数并发的调用 doSomethingUsefulOne 与 doSomethingUsefulTwo 并且返回它们两个的结果之和。 由于 async 被定义为了 CoroutineScope 上的扩展，我们需要将它写在作用域内，并且这是 coroutineScope 函数所提供的：",
      "",
      "one.await() + two.await()",
      "suspend fun concurrentSum(): Int = coroutineScope {",
      "    val one = async { doSomethingUsefulOne() }",
      "    val two = async { doSomethingUsefulTwo() }",
      "    one.await() + two.await()",
      "}",
      "这种情况下，如果在 concurrentSum 函数内部发生了错误，并且它抛出了一个异常， 所有在作用域中启动的协程都会被取消。",
      "",
      "answer",
      "val time = measureTimeMillis {",
      "    println(\"The answer is ${concurrentSum()}\")",
      "}",
      "println(\"Completed in $time ms\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "从上面的 main 函数的输出可以看出，我们仍然可以同时执行这两个操作：",
      "",
      "The answer is 42",
      "Completed in 1017 ms",
      "取消始终通过协程的层次结构来进行传递：",
      "",
      "import kotlinx.coroutines.*",
      "​",
      "fun main() = runBlocking<Unit> {",
      "    try {",
      "        failedConcurrentSum()",
      "    } catch(e: ArithmeticException) {",
      "        println(\"Computation failed with ArithmeticException\")",
      "    }",
      "}",
      "​",
      "suspend fun failedConcurrentSum(): Int = coroutineScope {",
      "    val one = async<Int> { ",
      "        try {",
      "            delay(Long.MAX_VALUE) // 模拟一个长时间的运算",
      "            42",
      "        } finally {",
      "            println(\"First child was cancelled\")",
      "        }",
      "    }",
      "    val two = async<Int> { ",
      "        println(\"Second child throws an exception\")",
      "        throw ArithmeticException()",
      "    }",
      "    one.await() + two.await()",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "请注意，如果其中一个子协程（即 two）失败，第一个 async 以及等待中的父协程都会被取消：",
      "",
      "Second child throws an exception",
      "First child was cancelled",
      "Computation failed with ArithmeticException"
    ]
  },
  "kt-协程上下文与调度器": {
    "prefix": "kt-协程上下文与调度器",
    "body": [
      "协程总是运行在一些以 CoroutineContext 类型为代表的上下文中，它们被定义在了 Kotlin 的标准库里。",
      "",
      "协程上下文是各种不同元素的集合。其中主元素是协程中的 Job， 我们在前面的文档中见过它以及它的调度器，而本文将对它进行介绍。",
      "",
      "调度器与线程",
      "协程上下文包含一个 协程调度器 （参见 CoroutineDispatcher）它确定了哪些线程或与线程相对应的协程执行。协程调度器可以将协程限制在一个特定的线程执行，或将它分派到一个线程池，亦或是让它不受限地运行。",
      "",
      "所有的协程构建器诸如 launch 和 async 接收一个可选的 CoroutineContext 参数，它可以被用来显式的为一个新协程或其它上下文元素指定一个调度器。",
      "",
      "尝试下面的示例：",
      "",
      "Unconfined",
      "launch { // 运行在父协程的上下文中，即 runBlocking 主协程",
      "    println(\"main runBlocking      : I'm working in thread ${Thread.currentThread().name}\")",
      "}",
      "launch(Dispatchers.Unconfined) { // 不受限的——将工作在主线程中",
      "    println(\"Unconfined            : I'm working in thread ${Thread.currentThread().name}\")",
      "}",
      "launch(Dispatchers.Default) { // 将会获取默认调度器",
      "    println(\"Default               : I'm working in thread ${Thread.currentThread().name}\")",
      "}",
      "launch(newSingleThreadContext(\"MyOwnThread\")) { // 将使它获得一个新的线程",
      "    println(\"newSingleThreadContext: I'm working in thread ${Thread.currentThread().name}\")",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "它执行后得到了如下输出（也许顺序会有所不同）：",
      "",
      "Unconfined            : I'm working in thread main",
      "Default               : I'm working in thread DefaultDispatcher-worker-1",
      "newSingleThreadContext: I'm working in thread MyOwnThread",
      "main runBlocking      : I'm working in thread main",
      "当调用 launch { …… } 时不传参数，它从启动了它的 CoroutineScope 中承袭了上下文（以及调度器）。在这个案例中，它从 main 线程中的 runBlocking 主协程承袭了上下文。",
      "",
      "Dispatchers.Unconfined 是一个特殊的调度器且似乎也运行在 main 线程中，但实际上， 它是一种不同的机制，这会在后文中讲到。",
      "",
      "当协程在 GlobalScope 中启动时，使用的是由 Dispatchers.Default 代表的默认调度器。 默认调度器使用共享的后台线程池。 所以 launch(Dispatchers.Default) { …… } 与 GlobalScope.launch { …… } 使用相同的调度器。",
      "",
      "newSingleThreadContext 为协程的运行启动了一个线程。 一个专用的线程是一种非常昂贵的资源。 在真实的应用程序中两者都必须被释放，当不再需要的时候，使用 close 函数，或存储在一个顶层变量中使它在整个应用程序中被重用。",
      "",
      "非受限调度器 vs 受限调度器",
      "Dispatchers.Unconfined 协程调度器在调用它的线程启动了一个协程，但它仅仅只是运行到第一个挂起点。挂起后，它恢复线程中的协程，而这完全由被调用的挂起函数来决定。非受限的调度器非常适用于执行不消耗 CPU 时间的任务，以及不更新局限于特定线程的任何共享数据（如UI）的协程。",
      "",
      "另一方面，该调度器默认继承了外部的 CoroutineScope。 runBlocking 协程的默认调度器，特别是， 当它被限制在了调用者线程时，继承自它将会有效地限制协程在该线程运行并且具有可预测的 FIFO 调度。",
      "",
      "launch(Dispatchers.Unconfined) { // 非受限的——将和主线程一起工作",
      "    println(\"Unconfined      : I'm working in thread ${Thread.currentThread().name}\")",
      "    delay(500)",
      "    println(\"Unconfined      : After delay in thread ${Thread.currentThread().name}\")",
      "}",
      "launch { // 父协程的上下文，主 runBlocking 协程",
      "    println(\"main runBlocking: I'm working in thread ${Thread.currentThread().name}\")",
      "    delay(1000)",
      "    println(\"main runBlocking: After delay in thread ${Thread.currentThread().name}\")",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "执行后的输出：",
      "",
      "Unconfined      : I'm working in thread main",
      "main runBlocking: I'm working in thread main",
      "Unconfined      : After delay in thread kotlinx.coroutines.DefaultExecutor",
      "main runBlocking: After delay in thread main",
      "所以，该协程的上下文继承自 runBlocking {...} 协程并在 main 线程中运行，当 delay 函数调用的时候，非受限的那个协程在默认的执行者线程中恢复执行。",
      "",
      "非受限的调度器是一种高级机制，可以在某些极端情况下提供帮助而不需要调度协程以便稍后执行或产生不希望的副作用， 因为某些操作必须立即在协程中执行。 非受限调度器不应该在通常的代码中使用。",
      "",
      "调试协程与线程",
      "协程可以在一个线程上挂起并在其它线程上恢复。 甚至一个单线程的调度器也是难以弄清楚协程在何时何地正在做什么事情。使用通常调试应用程序的方法是让线程在每一个日志文件的日志声明中打印线程的名字。这种特性在日志框架中是普遍受支持的。但是在使用协程时，单独的线程名称不会给出很多协程上下文信息，所以 kotlinx.coroutines 包含了调试工具来让它更简单。",
      "",
      "使用 -Dkotlinx.coroutines.debug JVM 参数运行下面的代码：",
      "",
      "log(\"The answer is ${a.await() * b.await()}\")",
      "val a = async {",
      "    log(\"I'm computing a piece of the answer\")",
      "    6",
      "}",
      "val b = async {",
      "    log(\"I'm computing another piece of the answer\")",
      "    7",
      "}",
      "log(\"The answer is ${a.await() * b.await()}\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "这里有三个协程，包括 runBlocking 内的主协程 (#1) ， 以及计算延期的值的另外两个协程 a (#2) 和 b (#3)。 它们都在 runBlocking 上下文中执行并且被限制在了主线程内。 这段代码的输出如下：",
      "",
      "[main @coroutine#2] I'm computing a piece of the answer",
      "[main @coroutine#3] I'm computing another piece of the answer",
      "[main @coroutine#1] The answer is 42",
      "这个 log 函数在方括号种打印了线程的名字，并且你可以看到它是 main 线程，并且附带了当前正在其上执行的协程的标识符。这个标识符在调试模式开启时，将连续分配给所有创建的协程。",
      "",
      "当 JVM 以 -ea 参数配置运行时，调试模式也会开启。 你可以在 DEBUG_PROPERTY_NAME 属性的文档中阅读有关调试工具的更多信息。",
      "",
      "在不同线程间跳转",
      "使用 -Dkotlinx.coroutines.debug JVM 参数运行下面的代码（参见调试）：",
      "",
      "ctx2",
      "newSingleThreadContext(\"Ctx1\").use { ctx1 ->",
      "    newSingleThreadContext(\"Ctx2\").use { ctx2 ->",
      "        runBlocking(ctx1) {",
      "            log(\"Started in ctx1\")",
      "            withContext(ctx2) {",
      "                log(\"Working in ctx2\")",
      "            }",
      "            log(\"Back to ctx1\")",
      "        }",
      "    }",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "它演示了一些新技术。其中一个使用 runBlocking 来显式指定了一个上下文，并且另一个使用 withContext 函数来改变协程的上下文，而仍然驻留在相同的协程中，正如可以在下面的输出中所见到的：",
      "",
      "[Ctx1 @coroutine#1] Started in ctx1",
      "[Ctx2 @coroutine#1] Working in ctx2",
      "[Ctx1 @coroutine#1] Back to ctx1",
      "注意，在这个例子中，当我们不再需要某个在 newSingleThreadContext 中创建的线程的时候， 它使用了 Kotlin 标准库中的 use 函数来释放该线程。",
      "",
      "上下文中的作业",
      "协程的 Job 是上下文的一部分，并且可以使用 coroutineContext [Job] 表达式在上下文中检索它：",
      "",
      "println(\"My job is ${coroutineContext[Job]}\")",
      "println(\"My job is ${coroutineContext[Job]}\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "在调试模式下，它将输出如下这些信息：",
      "",
      "My job is \"coroutine#1\":BlockingCoroutine{Active}@6d311334",
      "请注意，CoroutineScope 中的 isActive 只是 coroutineContext[Job]?.isActive == true 的一种方便的快捷方式。",
      "",
      "子协程",
      "当一个协程被其它协程在 CoroutineScope 中启动的时候， 它将通过 CoroutineScope.coroutineContext 来承袭上下文，并且这个新协程的 Job 将会成为父协程作业的 子 作业。当一个父协程被取消的时候，所有它的子协程也会被递归的取消。",
      "",
      "然而，当使用 GlobalScope 来启动一个协程时，则新协程的作业没有父作业。 因此它与这个启动的作用域无关且独立运作。",
      "",
      "        delay(100)",
      "",
      "// 启动一个协程来处理某种传入请求（request）",
      "val request = launch {",
      "    // 孵化了两个子作业, 其中一个通过 GlobalScope 启动",
      "    GlobalScope.launch {",
      "        println(\"job1: I run in GlobalScope and execute independently!\")",
      "        delay(1000)",
      "        println(\"job1: I am not affected by cancellation of the request\")",
      "    }",
      "    // 另一个则承袭了父协程的上下文",
      "    launch {",
      "        delay(100)",
      "        println(\"job2: I am a child of the request coroutine\")",
      "        delay(1000)",
      "        println(\"job2: I will not execute this line if my parent request is cancelled\")",
      "    }",
      "}",
      "delay(500)",
      "request.cancel() // 取消请求（request）的执行",
      "delay(1000) // 延迟一秒钟来看看发生了什么",
      "println(\"main: Who has survived request cancellation?\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "这段代码的输出如下：",
      "",
      "job1: I run in GlobalScope and execute independently!",
      "job2: I am a child of the request coroutine",
      "job1: I am not affected by cancellation of the request",
      "main: Who has survived request cancellation?",
      "父协程的职责",
      "一个父协程总是等待所有的子协程执行结束。父协程并不显式的跟踪所有子协程的启动，并且不必使用 Job.join 在最后的时候等待它们：",
      "",
      "// 启动一个协程来处理某种传入请求（request）",
      "val request = launch {",
      "    repeat(3) { i -> // 启动少量的子作业",
      "        launch  {",
      "            delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒的时间",
      "            println(\"Coroutine $i is done\")",
      "        }",
      "    }",
      "    println(\"request: I'm done and I don't explicitly join my children that are still active\")",
      "}",
      "request.join() // 等待请求的完成，包括其所有子协程",
      "println(\"Now processing of the request is complete\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "结果如下所示：",
      "",
      "request: I'm done and I don't explicitly join my children that are still active",
      "Coroutine 0 is done",
      "Coroutine 1 is done",
      "Coroutine 2 is done",
      "Now processing of the request is complete",
      "命名协程以用于调试",
      "当协程经常打印日志并且你只需要关联来自同一个协程的日志记录时， 则自动分配的 id 是非常好的。然而，当一个协程与特定请求的处理相关联时或做一些特定的后台任务，最好将其明确命名以用于调试目的。 CoroutineName 上下文元素与线程名具有相同的目的。当调试模式开启时，它被包含在正在执行此协程的线程名中。",
      "",
      "下面的例子演示了这一概念：",
      "",
      "log(\"Started main coroutine\")",
      "// 运行两个后台值计算",
      "val v1 = async(CoroutineName(\"v1coroutine\")) {",
      "    delay(500)",
      "    log(\"Computing v1\")",
      "    252",
      "}",
      "val v2 = async(CoroutineName(\"v2coroutine\")) {",
      "    delay(1000)",
      "    log(\"Computing v2\")",
      "    6",
      "}",
      "log(\"The answer for v1 / v2 = ${v1.await() / v2.await()}\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "程序执行使用了 -Dkotlinx.coroutines.debug JVM 参数，输出如下所示：",
      "",
      "[main @main#1] Started main coroutine",
      "[main @v1coroutine#2] Computing v1",
      "[main @v2coroutine#3] Computing v2",
      "[main @main#1] The answer for v1 / v2 = 42",
      "组合上下文中的元素",
      "有时我们需要在协程上下文中定义多个元素。我们可以使用 + 操作符来实现。 比如说，我们可以显式指定一个调度器来启动协程并且同时显式指定一个命名：",
      "",
      "Dispatchers.Defaul",
      "launch(Dispatchers.Default + CoroutineName(\"test\")) {",
      "    println(\"I'm working in thread ${Thread.currentThread().name}\")",
      "}",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "这段代码使用了 -Dkotlinx.coroutines.debug JVM 参数，输出如下所示：",
      "",
      "I'm working in thread DefaultDispatcher-worker-1 @test#2",
      "协程作用域",
      "让我们将关于上下文，子协程以及作业的知识综合在一起。假设我们的应用程序拥有一个具有生命周期的对象，但这个对象并不是一个协程。举例来说，我们编写了一个 Android 应用程序并在 Android 的 activity 上下文中启动了一组协程来使用异步操作拉取并更新数据以及执行动画等等。所有这些协程必须在这个 activity 销毁的时候取消以避免内存泄漏。当然，我们也可以手动操作上下文与作业，以结合 activity 的生命周期与它的协程，但是 kotlinx.coroutines 提供了一个封装：CoroutineScope 的抽象。 你应该已经熟悉了协程作用域，因为所有的协程构建器都声明为在它之上的扩展。",
      "",
      "我们通过创建一个 CoroutineScope 实例来管理协程的生命周期，并使它与 activit 的生命周期相关联。CoroutineScope 可以通过 CoroutineScope() 创建或者通过MainScope() 工厂函数。前者创建了一个通用作用域，而后者为使用 Dispatchers.Main 作为默认调度器的 UI 应用程序 创建作用域：",
      "",
      "        mainScope.cancel()",
      "",
      "class Activity {",
      "    private val mainScope = MainScope()",
      "​",
      "    fun destroy() {",
      "        mainScope.cancel()",
      "    }",
      "    // 继续运行……",
      "Now, we can launch coroutines in the scope of this Activity using the defined scope. For the demo, we launch ten coroutines that delay for a different time:",
      "",
      "                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间",
      "",
      "// 在 Activity 类中",
      "    fun doSomething() {",
      "        // 在示例中启动了 10 个协程，且每个都工作了不同的时长",
      "        repeat(10) { i ->",
      "            mainScope.launch {",
      "                delay((i + 1) * 200L) // 延迟 200 毫秒、400 毫秒、600 毫秒等等不同的时间",
      "                println(\"Coroutine $i is done\")",
      "            }",
      "        }",
      "    }",
      "} // Activity 类结束",
      "在 main 函数中我们创建 activity，调用测试函数 doSomething，并且在 500 毫秒后销毁这个 activity。 这取消了从 doSomething 启动的所有协程。我们可以观察到这些是由于在销毁之后， 即使我们再等一会儿，activity 也不再打印消息。",
      "",
      "val activity = Activity()",
      "activity.doSomething() // 运行测试函数",
      "println(\"Launched coroutines\")",
      "delay(500L) // 延迟半秒钟",
      "println(\"Destroying activity!\")",
      "activity.destroy() // 取消所有的协程",
      "delay(1000) // 为了在视觉上确认它们没有工作",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "这个示例的输出如下所示：",
      "",
      "Launched coroutines",
      "Coroutine 0 is done",
      "Coroutine 1 is done",
      "Destroying activity!",
      "你可以看到，只有前两个协程打印了消息，而另一个协程在 Activity.destroy() 中单次调用了 job.cancel()。",
      "",
      "注意，Android 在所有具有生命周期的实体中都对协程作用域提供了一等的支持。 请查看相关文档。",
      "",
      "线程局部数据",
      "有时，能够将一些线程局部数据传递到协程与协程之间是很方便的。 然而，由于它们不受任何特定线程的约束，如果手动完成，可能会导致出现样板代码。",
      "",
      "ThreadLocal， asContextElement 扩展函数在这里会充当救兵。它创建了额外的上下文元素， 且保留给定 ThreadLocal 的值，并在每次协程切换其上下文时恢复它。",
      "",
      "它很容易在下面的代码中演示：",
      "",
      "    yield()",
      "",
      "threadLocal.set(\"main\")",
      "println(\"Pre-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")",
      "val job = launch(Dispatchers.Default + threadLocal.asContextElement(value = \"launch\")) {",
      "    println(\"Launch start, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")",
      "    yield()",
      "    println(\"After yield, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")",
      "}",
      "job.join()",
      "println(\"Post-main, current thread: ${Thread.currentThread()}, thread local value: '${threadLocal.get()}'\")",
      "Target platform: JVMRunning on kotlin v. 1.3.72",
      "可以在这里获取完整代码。",
      "",
      "在这个例子中我们使用 Dispatchers.Default 在后台线程池中启动了一个新的协程，所以它工作在线程池中的不同线程中，但它仍然具有线程局部变量的值， 我们指定使用 threadLocal.asContextElement(value = \"launch\")， 无论协程执行在什么线程中都是没有问题的。 因此，其输出如（调试）所示：",
      "",
      "Pre-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'",
      "Launch start, current thread: Thread[DefaultDispatcher-worker-1 @coroutine#2,5,main], thread local value: 'launch'",
      "After yield, current thread: Thread[DefaultDispatcher-worker-2 @coroutine#2,5,main], thread local value: 'launch'",
      "Post-main, current thread: Thread[main @coroutine#1,5,main], thread local value: 'main'",
      "这很容易忘记去设置相应的上下文元素。如果运行协程的线程不同， 在协程中访问的线程局部变量则可能会产生意外的值。 为了避免这种情况，建议使用 ensurePresent 方法并且在不正确的使用时快速失败。",
      "",
      "ThreadLocal 具有一流的支持，可以与任何 kotlinx.coroutines 提供的原语一起使用。 但它有一个关键限制，即：当一个线程局部变量变化时，则这个新值不会传播给协程调用者（因为上下文元素无法追踪所有 ThreadLocal 对象访问），并且下次挂起时更新的值将丢失。 使用 withContext 在协程中更新线程局部变量，详见 asContextElement。",
      "",
      "另外，一个值可以存储在一个可变的域中，例如 class Counter(var i: Int)，是的，反过来， 可以存储在线程局部的变量中。然而，在这个案例中你完全有责任来进行同步可能的对这个可变的域进行的并发的修改。",
      "",
      "对于高级的使用，例如，那些在内部使用线程局部传递数据的用于与日志记录 MDC 集成，以及事务上下文或任何其它库，请参见需要实现的 ThreadContextElement 接口的文档。"
    ]
  },
  "kt-在 Kotlin 中使用 JNI": {
    "prefix": "kt-在 Kotlin 中使用 JNI",
    "body": [
      "要声明一个在本地（C 或 C++）代码中实现的函数，你需要使用 external 修饰符来标记它：",
      "",
      "external fun foo(x: Int): Double",
      "external fun foo(x: Int): Double",
      "其余的过程与 Java 中的工作方式完全相同。"
    ]
  },
  "kt-在 Kotlin 中调用 Java 代码": {
    "prefix": "kt-在 Kotlin 中调用 Java 代码",
    "body": []
  },
  "kt-Java 中调用 Kotlin": {
    "prefix": "kt-Java 中调用 Kotlin",
    "body": [
      "Java 可以轻松调用 Kotlin 代码。 例如，可以在 Java 方法中无缝创建与操作 Kotlin 类的实例。 然而，在将 Kotlin 代码集成到 Java 中时， 需要注意 Java 与 Kotlin 之间的一些差异。 在本页，我们会描述定制 Kotlin 代码与其 Java 客户端的互操作的方法。",
      "",
      "属性",
      "Kotlin 属性会编译成以下 Java 元素：",
      "",
      "一个 getter 方法，名称通过加前缀 get 算出；",
      "一个 setter 方法，名称通过加前缀 set 算出（只适用于 var 属性）；",
      "一个私有字段，与属性名称相同（仅适用于具有幕后字段的属性）。",
      "例如，var firstName: String 编译成以下 Java 声明：",
      "",
      "private String firstName;",
      "​",
      "public String getFirstName() {",
      "    return firstName;",
      "}",
      "​",
      "public void setFirstName(String firstName) {",
      "    this.firstName = firstName;",
      "}",
      "如果属性的名称以 is 开头，则使用不同的名称映射规则：getter 的名称与属性名称相同，并且 setter 的名称是通过将 is 替换为 set 获得。 例如，对于属性 isOpen，其 getter 会称做 isOpen()，而其 setter 会称做 setOpen()。 这一规则适用于任何类型的属性，并不仅限于 Boolean。",
      "",
      "包级函数",
      "在 org.example 包内的 app.kt 文件中声明的所有的函数和属性，包括扩展函数， 都编译成一个名为 org.example.AppKt 的 Java 类的静态方法。",
      "",
      "fun getTime() { /*……*/ }",
      "// app.kt",
      "package org.example",
      "​",
      "class Util",
      "​",
      "fun getTime() { /*……*/ }",
      "// Java",
      "new org.example.Util();",
      "org.example.AppKt.getTime();",
      "可以使用 @JvmName 注解修改生成的 Java 类的类名：",
      "",
      "@file:JvmName(\"DemoUtils\")",
      "​",
      "package org.example",
      "​",
      "class Util",
      "​",
      "fun getTime() { /*……*/ }",
      "// Java",
      "new org.example.Util();",
      "org.example.DemoUtils.getTime();",
      "如果多个文件中生成了相同的 Java 类名（包名相同并且类名相同或者有相同的 @JvmName 注解）通常是错误的。然而，编译器能够生成一个单一的 Java 外观类，它具有指定的名称且包含来自所有文件中具有该名称的所有声明。 要启用生成这样的外观，请在所有相关文件中使用 @JvmMultifileClass 注解。",
      "",
      "// oldutils.kt",
      "@file:JvmName(\"Utils\")",
      "@file:JvmMultifileClass",
      "​",
      "package org.example",
      "​",
      "fun getTime() { /*……*/ }",
      "// newutils.kt",
      "@file:JvmName(\"Utils\")",
      "@file:JvmMultifileClass",
      "​",
      "package org.example",
      "​",
      "fun getDate() { /*……*/ }",
      "// Java",
      "org.example.Utils.getTime();",
      "org.example.Utils.getDate();",
      "实例字段",
      "如果需要在 Java 中将 Kotlin 属性作为字段暴露，那就使用 @JvmField 注解对其标注。 该字段将具有与底层属性相同的可见性。如果一个属性有幕后字段（backing field）、非私有、没有 open /override 或者 const 修饰符并且不是被委托的属性，那么你可以用 @JvmField 注解该属性。",
      "",
      "@JvmField val ID = id",
      "class User(id: String) {",
      "    @JvmField val ID = id",
      "}",
      "String",
      "// Java",
      "class JavaClient {",
      "    public String getID(User user) {",
      "        return user.ID;",
      "    }",
      "}",
      "延迟初始化的属性（在Java中）也会暴露为字段。 该字段的可见性与 lateinit 属性的 setter 相同。",
      "",
      "静态字段",
      "在具名对象或伴生对象中声明的 Kotlin 属性会在该具名对象或包含伴生对象的类中具有静态幕后字段。",
      "",
      "通常这些字段是私有的，但可以通过以下方式之一暴露出来：",
      "",
      "@JvmField 注解；",
      "lateinit 修饰符；",
      "const 修饰符。",
      "使用 @JvmField 标注这样的属性使其成为与属性本身具有相同可见性的静态字段。",
      "",
      "Comparator",
      "class Key(val value: Int) {",
      "    companion object {",
      "        @JvmField",
      "        val COMPARATOR: Comparator<Key> = compareBy<Key> { it.value }",
      "    }",
      "}",
      "Key.COMPARATOR.compare(key1, key2);",
      "",
      "// Java",
      "Key.COMPARATOR.compare(key1, key2);",
      "// Key 类中的 public static final 字段",
      "在具名对象或者伴生对象中的一个延迟初始化的属性具有与属性 setter 相同可见性的静态幕后字段。",
      "",
      "Provider",
      "object Singleton {",
      "    lateinit var provider: Provider",
      "}",
      "Singleton",
      "// Java",
      "Singleton.provider = new Provider();",
      "// 在 Singleton 类中的 public static 非-final 字段",
      "（在类中以及在顶层）以 const 声明的属性在 Java 中会成为静态字段：",
      "",
      "const val MAX = 239",
      "// 文件 example.kt",
      "​",
      "object Obj {",
      "    const val CONST = 1",
      "}",
      "​",
      "class C {",
      "    companion object {",
      "        const val VERSION = 9",
      "    }",
      "}",
      "​",
      "const val MAX = 239",
      "在 Java 中：",
      "",
      "t = Obj.CONST;",
      "int max = ExampleKt.MAX;",
      "int version = C.VERSION;",
      "int const = Obj.CONST;",
      "int max = ExampleKt.MAX;",
      "int version = C.VERSION;",
      "静态方法",
      "如上所述，Kotlin 将包级函数表示为静态方法。 Kotlin 还可以为具名对象或伴生对象中定义的函数生成静态方法，如果你将这些函数标注为 @JvmStatic 的话。 如果你使用该注解，编译器既会在相应对象的类中生成静态方法，也会在对象自身中生成实例方法。 例如：",
      "",
      "class C {",
      "    companion object {",
      "        @JvmStatic fun callStatic() {}",
      "        fun callNonStatic() {}",
      "    }",
      "}",
      "现在，callStatic() 在 Java 中是静态的，而 callNonStatic() 不是：",
      "",
      "Companion",
      "C.callStatic(); // 没问题",
      "C.callNonStatic(); // 错误：不是一个静态方法",
      "C.Companion.callStatic(); // 保留实例方法",
      "C.Companion.callNonStatic(); // 唯一的工作方式",
      "对于具名对象也同样：",
      "",
      "JvmStatic",
      "object Obj {",
      "    @JvmStatic fun callStatic() {}",
      "    fun callNonStatic() {}",
      "}",
      "在 Java 中：",
      "",
      "callStatic",
      "Obj.callStatic(); // 没问题",
      "Obj.callNonStatic(); // 错误",
      "Obj.INSTANCE.callNonStatic(); // 没问题，通过单例实例调用",
      "Obj.INSTANCE.callStatic(); // 也没问题",
      "自 Kotlin 1.3 起，@JvmStatic 也适用于在接口的伴生对象中定义的函数。 这类函数会编译为接口中的静态方法。请注意，接口中的静态方法是 Java 1.8 中引入的， 因此请确保使用相应的编译目标。",
      "",
      "(",
      "interface ChatBot {",
      "    companion object {",
      "        @JvmStatic fun greet(username: String) {",
      "            println(\"Hello, $username\")",
      "        }",
      "    }",
      "}",
      "@JvmStatic　注解也可以应用于对象或伴生对象的属性， 使其 getter 和 setter 方法在该对象或包含该伴生对象的类中是静态成员。",
      "",
      "接口中的默认方法",
      "默认方法仅适用于面向 JVM 1.8 及更高版本。",
      "",
      "@JvmDefault 注解在 Kotlin 1.3 中是实验性的。其名称与行为都可能发生变化，导致将来不兼容。",
      "",
      "自 JDK 1.8 起，Java 中的接口可以包含默认方法。 可以将 Kotlin 接口的非抽象成员为实现它的 Java 类声明为默认。 如需将一个成员声明为默认，请使用 @JvmDefault 注解标记之。 这是一个带有默认方法的 Kotlin 接口的一个示例：",
      "",
      "    @JvmDefault fun move() { println(\"~walking~\") }",
      "",
      "interface Robot {",
      "    @JvmDefault fun move() { println(\"~walking~\") }",
      "    fun speak(): Unit",
      "}",
      "默认实现对于实现该接口的 Java 类都可用。",
      "",
      "//Java 实现",
      "public class C3PO implements Robot {",
      "    // 来自 Robot 的 move() 实现隐式可用",
      "    @Override",
      "    public void speak() {",
      "        System.out.println(\"I beg your pardon, sir\");",
      "    }",
      "}",
      "C3PO c3po = new C3PO();",
      "c3po.move(); // 来自 Robot 接口的默认实现",
      "c3po.speak();",
      "接口的实现者可以覆盖默认方法。",
      "",
      "//Java",
      "public class BB8 implements Robot {",
      "    //自己实现默认方法",
      "    @Override",
      "    public void move() {",
      "        System.out.println(\"~rolling~\");",
      "    }",
      "​",
      "    @Override",
      "    public void speak() {",
      "        System.out.println(\"Beep-beep\");",
      "    }",
      "}",
      "为了让 @JvmDefault 生效，编译该接口必须带有 -Xjvm-default 参数。 根据添加注解的情况，指定下列值之一：",
      "",
      "-Xjvm-default=enabled 只添加带有 @JvmDefault 注解的新方法时使用。 这包括为 API 添加整个接口。",
      "-Xjvm-default=compatibility 将 @JvmDefault 添加到以往 API 中就有的方法时使用。 这种模式有助于避免兼容性破坏：为先前版本编写的所有接口实现都会与新版本完全兼容。 然而，兼容模式可能会增大生成字节码的规模并且影响性能。",
      "关于兼容性的更多详情请参见 @JvmDefault 参考页。",
      "",
      "在委托中使用",
      "请注意，如果将带有 @JvmDefault 的方法的接口用作委托， 那么即是实际的委托类型提供了自己的实现，也会调用默认方法的实现。",
      "",
      "interface",
      "interface Producer {",
      "    @JvmDefault fun produce() {",
      "        println(\"interface method\")",
      "    }",
      "}",
      "​",
      "class ProducerImpl: Producer {",
      "    override fun produce() {",
      "        println(\"class method\")",
      "    }",
      "}",
      "​",
      "class DelegatedProducer(val p: Producer): Producer by p {",
      "}",
      "​",
      "fun main() {",
      "    val prod = ProducerImpl()",
      "    DelegatedProducer(prod).produce() // 输出“interface method”",
      "}",
      "关于 Kotlin 中接口委托的更多详情，请参见委托。",
      "",
      "可见性",
      "Kotlin 的可见性以下列方式映射到 Java：",
      "",
      "private 成员编译成 private 成员；",
      "private 的顶层声明编译成包级局部声明；",
      "protected 保持 protected（注意 Java 允许访问同一个包中其他类的受保护成员， 而 Kotlin 不能，所以 Java 类会访问更广泛的代码）；",
      "internal 声明会成为 Java 中的 public。internal 类的成员会通过名字修饰，使其更难以在 Java 中意外使用到，并且根据 Kotlin 规则使其允许重载相同签名的成员而互不可见；",
      "public 保持 public。",
      "KClass",
      "有时你需要调用有 KClass 类型参数的 Kotlin 方法。 因为没有从 Class 到 KClass 的自动转换，所以你必须通过调用 Class<T>.kotlin 扩展属性的等价形式来手动进行转换：",
      "",
      "JvmClassMappingKt",
      "kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)",
      "用 @JvmName 解决签名冲突",
      "有时我们想让一个 Kotlin 中的具名函数在字节码中有另外一个 JVM 名称。 最突出的例子是由于类型擦除引发的：",
      "",
      "filterValid",
      "fun List<String>.filterValid(): List<String>",
      "fun List<Int>.filterValid(): List<Int>",
      "这两个函数不能同时定义，因为它们的 JVM 签名是一样的：filterValid(Ljava/util/List;)Ljava/util/List;。 如果我们真的希望它们在 Kotlin 中用相同名称，我们需要用 @JvmName 去标注其中的一个（或两个），并指定不同的名称作为参数：",
      "",
      "filterValid",
      "fun List<String>.filterValid(): List<String>",
      "​",
      "@JvmName(\"filterValidInt\")",
      "fun List<Int>.filterValid(): List<Int>",
      "在 Kotlin 中它们可以用相同的名称 filterValid 来访问，而在 Java 中，它们分别是 filterValid 和 filterValidInt。",
      "",
      "同样的技巧也适用于属性 x 和函数 getX() 共存：",
      "",
      "val x: Int",
      "    @JvmName(\"getX_prop\")",
      "    get() = 15",
      "​",
      "fun getX() = 10",
      "如需在没有显式实现 getter 与 setter 的情况下更改属性生成的访问器方法的名称，可以使用 @get:JvmName 与 @set:JvmName：",
      "",
      "@get:JvmName(\"x\")",
      "@set:JvmName(\"changeX\")",
      "var x: Int = 23",
      "生成重载",
      "通常，如果你写一个有默认参数值的 Kotlin 函数，在 Java 中只会有一个所有参数都存在的完整参数签名的方法可见，如果希望向 Java 调用者暴露多个重载，可以使用 @JvmOverloads 注解。",
      "",
      "该注解也适用于构造函数、静态方法等。它不能用于抽象方法，包括在接口中定义的方法。",
      "",
      "draw",
      "class Circle @JvmOverloads constructor(centerX: Int, centerY: Int, radius: Double = 1.0) {",
      "    @JvmOverloads fun draw(label: String, lineWidth: Int = 1, color: String = \"red\") { /*……*/ }",
      "}",
      "对于每一个有默认值的参数，都会生成一个额外的重载，这个重载会把这个参数和它右边的所有参数都移除掉。在上例中，会生成以下代码 ：",
      "",
      "X, int centerY, double radius)",
      "Circle(int centerX, int centerY)",
      "",
      "// 方法",
      "void draw(String label, int lineWidth, String color) { }",
      "void draw(String label, int lineWidth) { }",
      "void draw(String label) { }",
      "// 构造函数：",
      "Circle(int centerX, int centerY, double radius)",
      "Circle(int centerX, int centerY)",
      "​",
      "// 方法",
      "void draw(String label, int lineWidth, String color) { }",
      "void draw(String label, int lineWidth) { }",
      "void draw(String label) { }",
      "请注意，如次构造函数中所述，如果一个类的所有构造函数参数都有默认值，那么会为其生成一个公有的无参构造函数。这就算没有 @JvmOverloads 注解也有效。",
      "",
      "受检异常",
      "如上所述，Kotlin 没有受检异常。 所以，通常 Kotlin 函数的 Java 签名不会声明抛出异常。 于是如果我们有一个这样的 Kotlin 函数：",
      "",
      "// example.kt",
      "",
      "// example.kt",
      "package demo",
      "​",
      "fun writeToFile() {",
      "    /*……*/",
      "    throw IOException()",
      "}",
      "然后我们想要在 Java 中调用它并捕捉这个异常：",
      "",
      "// Java",
      "try {",
      "  demo.Example.writeToFile();",
      "}",
      "catch (IOException e) { // 错误：writeToFile() 未在 throws 列表中声明 IOException",
      "  // ……",
      "}",
      "因为 writeToFile() 没有声明 IOException，我们从 Java 编译器得到了一个报错消息。 为了解决这个问题，要在 Kotlin 中使用 @Throws 注解。",
      "",
      "@Throws(IOException::class)",
      "fun writeToFile() {",
      "    /*……*/",
      "    throw IOException()",
      "}",
      "空安全性",
      "当从 Java 中调用 Kotlin 函数时，没人阻止我们将 null 作为非空参数传递。 这就是为什么 Kotlin 给所有期望非空参数的公有函数生成运行时检测。 这样我们就能在 Java 代码里立即得到 NullPointerException。",
      "",
      "型变的泛型",
      "当 Kotlin 的类使用了声明处型变，有两种选择可以从 Java 代码中看到它们的用法。让我们假设我们有以下类和两个使用它的函数：",
      "",
      "<",
      "class Box<out T>(val value: T)",
      "​",
      "interface Base",
      "class Derived : Base",
      "​",
      "fun boxDerived(value: Derived): Box<Derived> = Box(value)",
      "fun unboxBase(box: Box<Base>): Base = box.value",
      "一种看似理所当然地将这俩函数转换成 Java 代码的方式可能会是：",
      "",
      "Box<Derived> boxDerived(Derived value) { …… }",
      "Base unboxBase(Box<Base> box) { …… }",
      "问题是，在 Kotlin 中我们可以这样写 unboxBase(boxDerived(\"s\"))，但是在 Java 中是行不通的，因为在 Java 中类 Box 在其泛型参数 T 上是不型变的，于是 Box<Derived> 并不是 Box<Base> 的子类。 要使其在 Java 中工作，我们按以下这样定义 unboxBase：",
      "",
      "Base unboxBase(Box<? extends Base> box) { …… }",
      "这里我们使用 Java 的通配符类型（? extends Base）来通过使用处型变来模拟声明处型变，因为在 Java 中只能这样。",
      "",
      "当它作为参数出现时，为了让 Kotlin 的 API 在 Java 中工作，对于协变定义的 Box 我们生成 Box<Super> 作为 Box<? extends Super> （或者对于逆变定义的 Foo 生成 Foo<? super Bar>）。当它是一个返回值时， 我们不生成通配符，因为否则 Java 客户端将必须处理它们（并且它违反常用 Java 编码风格）。因此，我们的示例中的对应函数实际上翻译如下：",
      "",
      "// 作为返回类型——没有通配符",
      "Box<Derived> boxDerived(Derived value) { …… }",
      " ",
      "// 作为参数——有通配符",
      "Base unboxBase(Box<? extends Base> box) { …… }",
      "当参数类型是 final 时，生成通配符通常没有意义，所以无论在什么地方 Box<String>始终转换为 Box<String>。",
      "",
      "如果我们在默认不生成通配符的地方需要通配符，我们可以使用 @JvmWildcard 注解：",
      "",
      "fun boxDerived(value: Derived): Box<@JvmWildcard Derived> = Box(value)",
      "// 将被转换成",
      "// Box<? extends Derived> boxDerived(Derived value) { …… }",
      "另一方面，如果我们根本不需要默认的通配符转换，我们可以使用@JvmSuppressWildcards",
      "",
      "fun unboxBase(box: Box<@JvmSuppressWildcards Base>): Base = box.value",
      "// 会翻译成",
      "// Base unboxBase(Box<Base> box) { …… }",
      "@JvmSuppressWildcards 不仅可用于单个类型参数，还可用于整个声明（如函数或类），从而抑制其中的所有通配符。",
      "",
      "Nothing 类型翻译",
      "类型 Nothing 是特殊的，因为它在 Java 中没有自然的对应。确实，每个 Java 引用类型，包括 java.lang.Void 都可以接受 null 值，但是 Nothing 不行。因此，这种类型不能在 Java 世界中准确表示。这就是为什么在使用 Nothing 参数的地方 Kotlin 生成一个原始类型：",
      "",
      "fun emptyList(): List<Nothing> = listOf()",
      "// 会翻译成",
      "// List emptyList() { …… }",
      "fun emptyList(): List<Nothing> = listOf()",
      "// 会翻译成",
      "// List emptyList() { …… }"
    ]
  },
  "kt-with": {
    "prefix": "kt-with",
    "body": [
      "operator fun String.times(n: Int): String {",
      "    return with(StringBuilder()) {",
      "        repeat(n) {",
      "            append(this@times)",
      "        }",
      "        toString()",
      "    }",
      "}",
      "",
      "作者：Zhujiang",
      "链接：https://juejin.im/post/5eeffd73f265da02ec0bc42e",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt-run": {
    "prefix": "kt-run",
    "body": [
      "operator fun String.times(n: Int): String {",
      "    return StringBuilder().run {",
      "        repeat(n) {",
      "            append(this@times)",
      "        }",
      "        toString()",
      "    }",
      "}",
      "",
      "作者：Zhujiang",
      "链接：https://juejin.im/post/5eeffd73f265da02ec0bc42e",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt-apply": {
    "prefix": "kt-apply",
    "body": [
      "operator fun String.times(n: Int): String {",
      "    return StringBuilder().apply {",
      "        repeat(n) {",
      "            append(this@times)",
      "        }",
      "    }.toString()",
      "}",
      "",
      "作者：Zhujiang",
      "链接：https://juejin.im/post/5eeffd73f265da02ec0bc42e",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt-lateinit": {
    "prefix": "kt-lateinit",
    "body": [
      "lateinit var zhuJ: ZhuJ",
      "复制代码当这样定义全局变量的时候就无需设置为可空了，比如安卓项目中的 adapter ，咱们肯定能确认会赋值，不会为空，那么就可以使用 lateinit 了。",
      "这块需要注意的是，即使咱们觉得不会为空，但肯定会有特殊情况需要进行判断，需要进行判断的话要使用 isInitialized ，使用方法如下：",
      "if (::zhuJ.isInitialized){",
      "    // 判断是否已经进行赋值",
      "}",
      "",
      "作者：Zhujiang",
      "链接：https://juejin.im/post/5eeffd73f265da02ec0bc42e",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt-sealed": {
    "prefix": "kt-sealed",
    "body": [
      "sealed class Results",
      "class Success(val mag: String) : Results()",
      "class Failure(val error: Exception) : Results()",
      "",
      "fun getMessage(result: Results) {",
      "    when (result) {",
      "        is Success -> {",
      "            println(result.mag)",
      "        }",
      "        is Failure -> {",
      "            println(result.error.toString())",
      "        }",
      "    }",
      "}",
      "复",
      "",
      "作者：Zhujiang",
      "链接：https://juejin.im/post/5eeffd73f265da02ec0bc42e",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt-operator": {
    "prefix": "kt-operator",
    "body": [
      "这个关键字是运算符重载，其实在上面标准函数中已经使用到了，就是可以对运算符进行重新自定义，用来实现一些代码上不对劲但实际上对劲的需求，使用起来也很舒服。",
      "这里来说一下咱们常用的运算符需要重载的函数吧：加号对应 plus、减号对应minus、乘号对应 times、除号对应 div、取余对应 rem、自增对应 inc、自减对应 dec。",
      "具体使用方法就是上面那样，再写下吧：",
      "operator fun String.times(n: Int): String {}",
      "",
      "作者：Zhujiang",
      "链接：https://juejin.im/post/5eeffd73f265da02ec0bc42e",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt-inline": {
    "prefix": "kt-inline",
    "body": [
      "这个关键字的意思是内联函数，它的用法非常简单，只需要在高阶函数前加上 inline 关键字即可。如果对高阶函数不太清楚的，建议去看下扔物线的一个视频，好像是讲解 Lanbda 的。",
      "简单说下吧，高阶函数并没有想象中的难，只是名字听着感觉很高大上而已，简单来说就是传入方法（其实本质上还是对象）当作方法参数即为高阶函数。高阶函数的原理其实就是把方法参数转为接口，并创建匿名内部类进行调用，所以每次调用这样的 Lambda 都会创建一个新的匿名内部类和接口实例，造成额外的开销。",
      "所以这就是 inline 出现的原因，它可以去掉这些开销，并没有什么特殊的，只是进行替换，就是在你调用的地方把方法参数进行替换，从而减少内存和性能的开销。来看下使用方法吧：",
      "inline fun high(block:(Int,Int) -> Int,block2:(Int,Int) -> Int){",
      "    block.invoke(5,6)",
      "    block2.invoke(4,5)",
      "}",
      ""
    ]
  },
  "kt-kotlin中的泛型": {
    "prefix": "kt-kotlin中的泛型",
    "body": [
      "其实使用和 Java 中差不多，栗子又来了：",
      "class Generic <T>{",
      "",
      "    fun method(parem:T):T{",
      "        return parem",
      "    }",
      "    ",
      "}",
      "复制代码上面是在类上的使用，当然方法中也可以进行使用：",
      "    fun <S> meth(parem:S):S{",
      "        return parem",
      "    }",
      ""
    ]
  },
  "kt-泛型的实化": {
    "prefix": "kt-泛型的实化",
    "body": [
      "在 Java 中是绝对没有的，也是不现实的，因为 Java 的泛型擦出机制。。。",
      "但是在Kotlin中是可以实现的，但是。。。。有条件！",
      "",
      "函数必须是内联函数，因为只有内联函数才有替换的操作。",
      "声明类型时必须加上 reified 关键字来表示该泛型要进行实化。",
      "",
      "那么，实化有什么作用呢？来看代码吧：",
      "inline fun <reified T> startActivity(context:Context) {",
      "    context.startActivity(Intent(context,T::class.java))",
      "}",
      "复制代码知道了吧。。很方便的！",
      "",
      ""
    ]
  },
  "kt- kotlin支持默认参数": {
    "prefix": "kt- kotlin支持默认参数",
    "body": [
      "class A {",
      "  fun foo(i: Int = 10) {",
      "    /****/",
      "  }",
      "}",
      "复制代码A.foo()方法，如果调用时，不传参数的话， 参数i 默认是10",
      "大叔的自我拷问：",
      "默认参数，有什么用呢？能解决android开发中的什么痛点呢？",
      "默认参数，有什么用呢？能解决android开发中的什么痛点呢？",
      "默认参数，有什么用呢？能解决android开发中的什么痛点呢？",
      "",
      "在android开发中，我们写一个自定义View的时候，我们的构造函数往往要写好几个。",
      "JavaTextView.java",
      "public class JavaTextView extends AppCompatTextView {",
      "  public JavaTextView(Context context) {",
      "    super(context);",
      "  }",
      "",
      "  public JavaTextView(Context context, @Nullable AttributeSet attrs) {",
      "    super(context, attrs);",
      "  }",
      "",
      "  public JavaTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {",
      "    super(context, attrs, defStyleAttr);",
      "  }",
      "}",
      "复制代码有了默认参数，之后。。。",
      "KotlinTextView.kt",
      "class KotlinTextView : AppCompatTextView {",
      "",
      "  constructor(",
      "    context: Context,",
      "    attrs: AttributeSet? = null,",
      "    defStyleAttr: Int = android.R.attr.textViewStyle",
      "  ) : super(context, attrs, defStyleAttr){",
      "",
      "  }",
      "}",
      "复",
      "",
      "作者：IT互联网大叔",
      "链接：https://juejin.im/post/5eef38d66fb9a05854134113",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"
    ]
  },
  "kt- kotlin的use函数，自动关闭closeable": {
    "prefix": "kt- kotlin的use函数，自动关闭closeable",
    "body": []
  },
  "kt-序列化的坑": {
    "prefix": "kt-序列化的坑",
    "body": [
      "如果是旧工程迁移到 Kotlin，那么可能需要注意这个坑:",
      "// 定义一个数据类，其中成员变量 name 是不可为空的 String 类型，默认值是 MOMO",
      "data class Person(val age: Int, val name: String = \"Kotlin\")",
      "val person = gson.fromJson(\"\"\"{\"age\":42}\"\"\", Person::class.java)",
      "print(person.name) // 输出 null",
      "复制代码对于上面的情况，由于 Gson 最初是为 Java 语言设计的序列化框架，并不支持 Kotlin 不可为空、默认值这些特性，从而导致原本不可为空的属性变成null，原本应该有默认值的变量没有默认值。",
      "对于这种情，市面上已经有了解决方案:",
      "",
      "kotlinx.serialization",
      "moshi",
      "",
      "",
      ""
    ]
  },
  "kt-single单例": {
    "prefix": "kt-single单例",
    "body": [
      "class Singleton private constructor(private val param: Int) {",
      "    companion object {",
      "        @Volatile",
      "        private var instance: Singleton? = null",
      "        fun getInstance(property: Int) =",
      "            instance ?: synchronized(this) {",
      "                instance ?: Singleton(property).also { instance = it }",
      "            }",
      "    }",
      "}",
      "",
      "class MainActivity : AppCompatActivity() {",
      "    val a = 1",
      "    ",
      "    object click : View.OnClickListener {",
      "        override fun onClick(v: View) {",
      "            val b = a + 1",
      "        }",
      "    }",
      "}",
      ""
    ]
  },
  "kt-Custom Views - overload": {
    "prefix": "kt-Custom Views - overload",
    "body": [
      "Create a class that extends View",
      "To do this, create a class as we saw earlier. Make it extend from View for instance, but do not indicate any constructor:",
      "",
      "class KotlinView : View {",
      "}",
      "You’ll see that this code won’t compile, because it requires calling the constructor of the parent class.",
      "",
      "If you know that you are only inflating your view from Kotlin code, for example, you could use the unique constructor form we already saw:",
      "",
      "class KotlinView(context: Context?) : View(context) {",
      "}",
      "But be careful, because if someone decides to add this view to an XML, it will fail.",
      "",
      "Spoiler: Do you see that question mark right after the Context? In Kotlin, if we want a variable or parameter to be null, we have to explicitly specify it using a question mark. Then the compiler will force us to check it’s not null before doing anything with it. We’ll see it in next articles.",
      "",
      "Implement the multiple constructors",
      "The constructors use the constructor reserved word, and need to define in their declaration which constructor they call. It can be another constructor of the same class (using this) or the one of the parent class (using super).",
      "",
      "This is how you define the constructors for an Android view:",
      "",
      "class KotlinView : View {",
      "    constructor(context: Context) : this(context, null)",
      "    constructor(context: Context, attrs: AttributeSet?) : this(context, attrs, 0)",
      "    constructor(context: Context, attrs: AttributeSet?, defStyleAttr: Int) : super(context, attrs, defStyleAttr) {",
      "        ...",
      "    }",
      "}",
      "An easier implementation",
      "The alternative that Kirill mentions in the comments (thanks for that!) is much simpler and easier to read. It’s based assigning default values for constructor arguments, but needs a little tweak.",
      "",
      "The thing is that when you create a constructor (or any function) with default values for some arguments, the generated bytecode only allows to use those default values in Kotlin. If you use that constructor in Java, you will be forced to specify a value for all arguments.",
      "",
      "That is because Java doesn’t have this language feature. In Java, you would usually solve it by generating function overloads with all the variations you need.",
      "",
      "You can get this code automatically generated by using the @JvmOverloads annotation in Kotlin.",
      "",
      "The code would be like this:",
      "",
      "class KotlinView @JvmOverloads constructor(",
      "        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0",
      ") : View(context, attrs, defStyleAttr)",
      "Conclusion",
      "Once you see it, it’s not so complicated to generate your custom views thanks to the existence of multiple constructors, and even much easier using the @JvmOverloads annotation.",
    ]
  },
  "kt-JvmOverloads 自定义 View 的坑": {
    "prefix": "kt-JvmOverloads 自定义 View 的坑",
    "body": [
      "详细的可以看这一篇文章： 《Do not always trust @JvmOverloads》",
      "",
      "@JvmOverloads 注解是用来干撒的？",
      "  /**",
      " * Instructs the Kotlin compiler to generate overloads for this function that substitute default parameter values.",
      " *",
      " * If a method has N parameters and M of which have default values, M overloads are generated: the first one",
      " * takes N-1 parameters (all but the last one that takes a default value), the second takes N-2 parameters, and so on.",
      " */",
      "@Target(AnnotationTarget.FUNCTION, AnnotationTarget.CONSTRUCTOR)",
      "@Retention(AnnotationRetention.BINARY)",
      "@MustBeDocumented",
      "public annotation class JvmOverloads",
      "也就是说，如果方法参数中有默认值的，那么这个注解可以帮我们生成多个重载方法，这样方便我们调用，可以省掉一些不关心的参数。",
      "",
      "比如这样：",
      "",
      "   @JvmOverloads",
      "    fun test(name: String = \"hello\",  code: Int = 0){",
      "            ",
      "     }",
      "最终会帮我们重载三个方法出来",
      "",
      "    @JvmOverloads",
      "      public final void test(@NotNull String name, int code) {",
      "         Intrinsics.checkParameterIsNotNull(name, \"name\");",
      "      }",
      "",
      "      @JvmOverloads",
      "      public final void test(@NotNull String name) {",
      "         test$default(this, name, 0, 2, (Object)null);",
      "      }",
      "",
      "      @JvmOverloads",
      "      public final void test() {",
      "         test$default(this, (String)null, 0, 3, (Object)null);",
      "      }",
      "@JvmOverloads 自定义View",
      "  class EmoticonView @JvmOverloads constructor(",
      "        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0",
      ") : RelativeLayout(context, attrs, defStyleAttr)",
      "按照上面的介绍，会帮忙自动生成多个重载方法，那么坑来了的，注意这个 defStyleAttr = 0 。。。",
      "",
      "我们先看看 EditText 的构造函数， 如果是XML来写的布局，那么会调用第二个构造函数，也就是 public EditText(Context context, AttributeSet attrs) , 那么默认传入的 样式 defStyleAttr 就是 com.android.internal.R.attr.editTextStyle",
      "",
      " public class EditText extends TextView {",
      "    public EditText(Context context) {",
      "        this(context, null);",
      "    }",
      "",
      "    public EditText(Context context, AttributeSet attrs) {",
      "        this(context, attrs, com.android.internal.R.attr.editTextStyle);",
      "    }",
      "",
      "    public EditText(Context context, AttributeSet attrs, int defStyleAttr) {",
      "        this(context, attrs, defStyleAttr, 0);",
      "    }",
      "",
      "    public EditText(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {",
      "        super(context, attrs, defStyleAttr, defStyleRes);",
      "    }",
      "而我们如果使用 IDE 自动提示的 @JvmOverload",
      "",
      "image.png",
      "写出来的代码长这样：",
      "",
      " class InputVIew @JvmOverloads constructor(",
      "        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0",
      ") : EditText(context, attrs, defStyleAttr) {",
      "}",
      "看到了么，你的代码 defStyleAttr 默认是 0 而不是 com.android.internal.R.attr.editTextStyle 。",
      "",
      "那么说了这么多，这样会导致什么问题呢？",
      "",
      "亲测，焦点没有了的，点击之后键盘也无法弹起。",
      "",
      "那么这个坑 如何填呢？",
      "修改默认值即可：",
      "",
      "class InputVIew @JvmOverloads constructor(",
      "        context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = android.support.design.R.attr.editTextStyle",
      ") : EditText(context, attrs, defStyleAttr)",
      "注意",
      "像我在开头提到的文章 《Do not always trust @JvmOverloads》 ，在最后写到: Button, EditText, RadioButton, Switch 都会有类似的问题，请大家平时开发过程中要留意。",
      "",
      "作者：IMSk",
      "链接：https://www.jianshu.com/p/48a76d31f3ca",
      "来源：简书",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  },
  "kt-": {
    "prefix": "kt-",
    "body": []
  }
}