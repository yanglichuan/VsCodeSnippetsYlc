{
  "jv-Objects.equals": {
    "prefix": "jv-Objects.equals",
    "body": [
      "Objects.equals(null,\"SnailClimb\");// falseObjects.equals(null,\"SnailClimb\");// false",
    ]
  },
  "jv-SparseArray": {
    "prefix": "jv-SparseArray",
    "body": [
      "SparseArray",
      "该集合类型可以避免自动装箱减少内存的消耗; 对于大量的数据性能不如Java提供的Map集合(二分查询的缺陷);",
      "集合内部维护了两个数组; 一个是对应key另外一个对应value(这里也就产生了有value但是没有对应key的情况可以出现, 后面解释如何产生这种情况)",
      "",
      "SparseArray",
      "SparseIntArray",
      "SparseLongArray",
      "SparseBooleanArray",
      "",
      "SparseArray支持泛型(自定义Value类型)",
      "SparseIntArray这些就是避免自动装箱的集合, 只支持固定的基本类型; 但是他们都只支持key的类型是int, 并且不支持迭代器遍历;",
      "SparseArray的函数",
      "",
      "",
      "SparseArray<E> clone()",
      "",
      "",
      "// 查询",
      "E get(int key)",
      "",
      "E get(int key, E valueIfKeyNotFound)",
      "",
      "// 如果查询不到返回-1",
      "int indexOfKey(int key)",
      "int indexOfValue(E value)",
      "",
      "// 如果查询不到返回默认值",
      "E valueAt(int index)",
      "int keyAt(int index)",
      "",
      "",
      "// 增加",
      "void append(int key, E value)",
      "",
      "void put(int key, E value)",
      "",
      "void setValueAt(int index, E value)",
      "",
      "",
      "// 删除",
      "",
      "void delete(int key)",
      "",
      "void remove(int key)",
      "",
      "void removeAt(int index)",
      "",
      "void removeAtRange(int index, int size)",
      "",
      "void clear()",
      "",
      "    ",
      "int size()",
      "",
      "String toString()",
      "复制代码SparseArray有一些相同函数, 例如delete和remove; 两个函数功能完全相同;",
      "setValueAt这个函数可以不添加key向集合中添加value, 但是最终并不会算在toString之中(并且不会影响size); get()也无法获取到value;",
      "但是可以通过valueAt()函数获取到value值; 这种操作只有SparseArray可以, 类似SparseIntArray都不支持setValueAt()函数;",
      "",
      "作者：刘强东",
      "链接：https://juejin.im/post/5b0e842af265da08f76cced5",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-ArrayMap": {
    "prefix": "jv-ArrayMap",
    "body": [
      "该集合类型和SparseArray同样基于二分查询, 对于千以内的数据量Google推荐使用, 大量数据同样性能不佳;",
      "并且该集合类型不能解决自动装箱问题, 但是也能减少内存消耗;",
      "相比SparseArray就是支持自定义Key的类型;",
      "增加",
      "V put(K key, V value)",
      "",
      "void putAll(ArrayMap<? extends K, ? extends V> array)",
      "",
      "void putAll(Map<? extends K, ? extends V> map)",
      "",
      "V setValueAt(int index, V value)",
      "复制代码删除",
      "V remove(Object key)",
      "",
      "boolean removeAll(Collection<?> collection)",
      "",
      "V removeAt(int index)",
      "",
      "void clear()",
      "复制代码查询",
      "V get(Object key)",
      "",
      "K keyAt(int index)",
      "",
      "V valueAt(int index)",
      "",
      "int indexOfKey(Object key)",
      "",
      "boolean isEmpty()",
      "复制代码",
      "没有indexOfValue()",
      "",
      "遍历",
      "Collection<V> values()",
      "",
      "Set<K> keySet()",
      "",
      "Set<Entry<K, V>> entrySet()",
      "复制代码其他",
      "boolean containsAll(Collection<?> collection)",
      "",
      "boolean containsKey(Object key)",
      "",
      "boolean containsValue(Object value)",
      "",
      "void ensureCapacity(int minimumCapacity)",
      "",
      "boolean equals(Object object)",
      "",
      "",
      "int hashCode()",
      "",
      "boolean retainAll(Collection<?> collection)",
      "",
      "int size()",
      "",
      "String toString()",
      "复制代码ArraySet",
      "该集合和ArrayMap类似, 只不过不是映射关系而已; ArraySet支持迭代器;",
      "",
      "",
      "作者：刘强东",
      "链接：https://juejin.im/post/5b0e842af265da08f76cced5",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-io": {
    "prefix": "jv-io",
    "body": [
      "1、文件（file）：FileInputStream、FileOutputStream、FileReader、FileWriter",
      "2、数组（[]）：",
      "",
      "2.1、字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream",
      "2.2、字符数组（char[]）：CharArrayReader、CharArrayWriter",
      "",
      "",
      "3、管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter",
      "4、基本数据类型：DataInputStream、DataOutputStream",
      "5、缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter",
      "6、打印：PrintStream、PrintWriter",
      "7、对象序列化反序列化：ObjectInputStream、ObjectOutputStream",
      "8、转换：InputStreamReader、OutputStreWriter",
      "9、字符串（String）Java8中已废弃：StringBufferInputStream、StringBufferOutputStream、StringReader、StringWriter",
      "",
      "作者：Wizey",
      "链接：https://juejin.im/post/5b97e5f75188255c8d0fb0c0",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-io读取控制台中的输入": {
    "prefix": "jv-io读取控制台中的输入",
    "body": [
      "import java.io.*;",
      "",
      "public class IOTest {",
      "    public static void main(String[] args) throws IOException {",
      "        // 三个测试方法",
      "//        test01();",
      "//        test02();",
      "        test03();",
      "    }",
      "",
      "    public static void test01() throws IOException {",
      "        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));",
      "        System.out.println(\"请输入一个字符\");",
      "        char c;",
      "        c = (char) bufferedReader.read();",
      "        System.out.println(\"你输入的字符为\"+c);",
      "    }",
      "",
      "    public static void test02() throws IOException {",
      "        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));",
      "        System.out.println(\"请输入一个字符，按 q 键结束\");",
      "        char c;",
      "        do {",
      "            c = (char) bufferedReader.read();",
      "            System.out.println(\"你输入的字符为\"+c);",
      "        } while (c != 'q');",
      "    }",
      "",
      "    public static void test03() throws IOException {",
      "        BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in));",
      "        System.out.println(\"请输入一行字符\");",
      "        String str = bufferedReader.readLine();",
      "        System.out.println(\"你输入的字符为\" + str);",
      "    }",
      "}",
      "",
      "复制代码至于控制台的输出，我们其实一直都在使用呢，System.out.println() ，out 其实是 PrintStream 类对象的引用，PrintStream 类中当然也有 write() 方法，但是我们更常用 print() 方法和 println() 方法，因为这两个方法可以输出的内容种类更多，比如一个打印一个对象，实际调用的对象的 toString() 方法。",
      "",
      "作者：Wizey",
      "链接：https://juejin.im/post/5b97e5f75188255c8d0fb0c0",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-io二进制文件的写入和读取": {
    "prefix": "jv-io二进制文件的写入和读取",
    "body": [
      "@Test",
      "    public void test04() throws IOException {",
      "        byte[] bytes = {12,21,34,11,21};",
      "        FileOutputStream fileOutputStream = new FileOutputStream(new File(\"\").getAbsolutePath()+\"/io/test.txt\");",
      "        // 写入二进制文件，直接打开会出现乱码",
      "        fileOutputStream.write(bytes);",
      "        fileOutputStream.close();",
      "    }",
      "",
      "    @Test",
      "    public void test05() throws IOException {",
      "        FileInputStream fileInputStream = new FileInputStream(new File(\"\").getAbsolutePath()+\"/io/test.txt\");",
      "        int c;",
      "        // 读取写入的二进制文件，输出字节数组",
      "        while ((c = fileInputStream.read()) != -1) {",
      "            System.out.print(c);",
      "        }",
      "    }",
      "",
      "作者：Wizey",
      "链接：https://juejin.im/post/5b97e5f75188255c8d0fb0c0",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-io文本文件的写入和读取": {
    "prefix": "jv-io文本文件的写入和读取",
    "body": [
      "@Test",
      "    public void test06() throws IOException {",
      "        FileWriter fileWriter = new FileWriter(new File(\"\").getAbsolutePath()+\"/io/test.txt\");",
      "        fileWriter.write(\"Hello，world！\n欢迎来到 java 世界\n\");",
      "        fileWriter.write(\"不会覆盖文件原本的内容\n\");",
      "//        fileWriter.write(null); 不能直接写入 null",
      "        fileWriter.append(\"并不是追加一行内容，不要被方法名迷惑\n\");",
      "        fileWriter.append(null);",
      "        fileWriter.flush();",
      "        System.out.println(\"文件的默认编码为\" + fileWriter.getEncoding());",
      "        fileWriter.close();",
      "    }",
      "",
      "    @Test",
      "    public void test07() throws IOException {",
      "        FileWriter fileWriter = new FileWriter(new File(\"\").getAbsolutePath()+\"/io/test.txt\", false); // 关闭追加模式，变为覆盖模式",
      "        fileWriter.write(\"Hello，world！欢迎来到 java 世界\n\");",
      "        fileWriter.write(\"我来覆盖文件原本的内容\");",
      "        fileWriter.append(\"我是下一行\");",
      "        fileWriter.flush();",
      "        System.out.println(\"文件的默认编码为\" + fileWriter.getEncoding());",
      "        fileWriter.close();",
      "    }",
      "",
      "    @Test",
      "    public void test08() throws IOException {",
      "        FileReader fileReader = new FileReader(new File(\"\").getAbsolutePath()+\"/io/test.txt\");",
      "        BufferedReader bufferedReader = new BufferedReader(fileReader);",
      "        String str;",
      "        while ((str = bufferedReader.readLine()) != null) {",
      "            System.out.println(str);",
      "        }",
      "        fileReader.close();",
      "        bufferedReader.close();",
      "    }",
      "",
      "    @Test",
      "    public void test09() throws IOException {",
      "        FileReader fileReader = new FileReader(new File(\"\").getAbsolutePath()+\"/io/test.txt\");",
      "        int c;",
      "        while ((c = fileReader.read()) != -1) {",
      "            System.out.print((char) c);",
      "        }",
      "    }",
      "复制代码使用字节流和字符流的转换类 InputStreamReader 和 OutputStreamWriter 可以指定文件的编码，使用 Buffer 相关的类来读取文件的每一行。",
      "@Test",
      "    public void test10() throws IOException {",
      "        FileOutputStream fileOutputStream = new FileOutputStream(new File(\"\").getAbsolutePath()+\"/io/test2.txt\");",
      "        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(fileOutputStream, \"GBK\"); // 使用 GBK 编码文件",
      "        outputStreamWriter.write(\"Hello，world！\n欢迎来到 java 世界\n\");",
      "        outputStreamWriter.append(\"另外一行内容\");",
      "        outputStreamWriter.flush();",
      "        System.out.println(\"文件的编码为\" + outputStreamWriter.getEncoding());",
      "        outputStreamWriter.close();",
      "        fileOutputStream.close();",
      "    }",
      "",
      "    @Test",
      "    public void test11() throws IOException {",
      "        FileInputStream fileInputStream = new FileInputStream(new File(\"\").getAbsolutePath()+\"/io/test2.txt\");",
      "        InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream, \"GBK\"); // 使用 GBK 解码文件",
      "        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);",
      "        String str;",
      "        while ((str = bufferedReader.readLine()) != null) {",
      "            System.out.println(str);",
      "        }",
      "        bufferedReader.close();",
      "        inputStreamReader.close();",
      "    }",
      "",
      "作者：Wizey",
      "链接：https://juejin.im/post/5b97e5f75188255c8d0fb0c0",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-io复制文件": {
    "prefix": "jv-io复制文件",
    "body": [
      "这里笔者做了一些测试，不使用缓冲对文件复制时间的影响，文件的复制实质还是文件的读写。缓冲流是处理流，是对节点流的装饰。",
      "注：这里的时间是在我这台华硕笔记本上测试得到的，只是为了说明使用缓冲对文件的读写有好处。",
      "@Test",
      "    public void  test12() throws IOException {",
      "        // 输入和输出都使用缓冲流",
      "        FileInputStream in = new FileInputStream(\"E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4\");",
      "        BufferedInputStream inBuffer = new BufferedInputStream(in);",
      "        FileOutputStream out = new FileOutputStream(\"1.1大数据时代.mp4\");",
      "        BufferedOutputStream outBuffer = new BufferedOutputStream(out);",
      "        int len = 0;",
      "        byte[] bs = new byte[1024];",
      "        long begin = System.currentTimeMillis();",
      "        while ((len = inBuffer.read(bs)) != -1) {",
      "            outBuffer.write(bs, 0, len);",
      "        }",
      "        System.out.println(\"复制文件所需的时间：\" + (System.currentTimeMillis() - begin)); // 平均时间约 200 多毫秒",
      "        inBuffer.close();",
      "        in.close();",
      "        outBuffer.close();",
      "        out.close();",
      "    }",
      "",
      "",
      "    @Test",
      "    public void  test13() throws IOException {",
      "        // 只有输入使用缓冲流",
      "        FileInputStream in = new FileInputStream(\"E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4\");",
      "        BufferedInputStream inBuffer = new BufferedInputStream(in);",
      "        FileOutputStream out = new FileOutputStream(\"1.1大数据时代.mp4\");",
      "        int len = 0;",
      "        byte[] bs = new byte[1024];",
      "        long begin = System.currentTimeMillis();",
      "        while ((len = inBuffer.read(bs)) != -1) {",
      "            out.write(bs, 0, len);",
      "        }",
      "        System.out.println(\"复制文件所需时间：\" + (System.currentTimeMillis() - begin)); // 平均时间约 500 多毫秒",
      "        inBuffer.close();",
      "        in.close();",
      "        out.close();",
      "    }",
      "",
      "    @Test",
      "    public void test14() throws IOException {",
      "        // 输入和输出都不使用缓冲流",
      "        FileInputStream in = new FileInputStream(\"E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4\");",
      "        FileOutputStream out = new FileOutputStream(\"1.1大数据时代.mp4\");",
      "        int len = 0;",
      "        byte[] bs = new byte[1024];",
      "        long begin = System.currentTimeMillis();",
      "        while ((len = in.read(bs)) != -1) {",
      "            out.write(bs, 0, len);",
      "        }",
      "        System.out.println(\"复制文件所需时间：\" + (System.currentTimeMillis() - begin)); // 平均时间 700 多毫秒",
      "        in.close();",
      "        out.close();",
      "    }",
      "",
      "    @Test",
      "    public void test15() throws IOException {",
      "        // 不使用缓冲",
      "        FileInputStream in = new FileInputStream(\"E:\\视频资料\\大数据原理与应用\\1.1大数据时代.mp4\");",
      "        FileOutputStream out = new FileOutputStream(\"1.1大数据时代.mp4\");",
      "        int len = 0;",
      "        long begin = System.currentTimeMillis();",
      "        while ((len = in.read()) != -1) {",
      "            out.write(len);",
      "        }",
      "        System.out.println(\"复制文件所需时间：\" + (System.currentTimeMillis() - begin)); // 平均时间约 160000 毫秒，约 2 分多钟",
      "        in.close();",
      "        out.close();",
      "    }",
      "",
      "作者：Wizey",
      "链接：https://juejin.im/post/5b97e5f75188255c8d0fb0c0",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-ObjectOutputStream": {
    "prefix": "jv-ObjectOutputStream",
    "body": [
      "Student类的部分展示：",
      "",
      "public class Student implements Serializable {",
      "    // 序列版本号",
      "    private  static final long serialVersionUID = 3141592653589L;",
      "复制代码",
      "",
      "序列化操作：",
      "// 序列化",
      "    private static void serialized() throws Exception {",
      "        Student stu = new Student(\"迪丽热巴\", \"女\", 18);",
      "        // 开流",
      "        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"D:\\IO\\test3_1.txt\"));",
      "        // 写",
      "        oos.writeObject(stu);",
      "        // 关流",
      "        oos.close();",
      "    }",
      "复制代码",
      "",
      "反序列化操作：",
      "// 反序列化",
      "    private static void deserialized() throws Exception {",
      "        // 开流",
      "        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(\"D:\\IO\\test3_1.txt\"));",
      "        // 读",
      "        Object o = ois.readObject();",
      "        // 查看",
      "        System.out.println((Student)o);",
      "        // 关流",
      "    }",
      "复制代码",
      "",
      "",
      "",
      "​",
      "",
      "作者：Leboy",
      "链接：https://juejin.im/post/5e80a74df265da47ce6ca19d",
      "来源：掘金",
      "著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。",
    ]
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-for1": {
    "prefix": "jv-for1",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        int[] ns = { 1, 4, 9, 16, 25 };",
      "        for (int i=0; i<ns.length; i++) {",
      "            int n = ns[i];",
      "            System.out.println(n);",
      "        }",
      "    }",
      "}",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        int[] ns = { 1, 4, 9, 16, 25 };",
      "        for (int n : ns) {",
      "            System.out.println(n);",
      "        }",
      "    }",
      "}"
    ]
  },
  "jv-冒泡": {
    "prefix": "jv-冒泡",
    "body": [
      "import java.util.Arrays;",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };",
      "        // 排序前:",
      "        System.out.println(Arrays.toString(ns));",
      "        for (int i = 0; i < ns.length - 1; i++) {",
      "            for (int j = 0; j < ns.length - i - 1; j++) {",
      "                if (ns[j] > ns[j+1]) {",
      "                    // 交换ns[j]和ns[j+1]:",
      "                    int tmp = ns[j];",
      "                    ns[j] = ns[j+1];",
      "                    ns[j+1] = tmp;",
      "                }",
      "            }",
      "        }",
      "        // 排序后:",
      "        System.out.println(Arrays.toString(ns));",
      "    }",
      "}"
    ]
  },
  "jv-Arrays.sort": {
    "prefix": "jv-Arrays.sort",
    "body": [
      "import java.util.Arrays;",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        int[] ns = { 28, 12, 89, 73, 65, 18, 96, 50, 8, 36 };",
      "        Arrays.sort(ns);",
      "        System.out.println(Arrays.toString(ns));",
      "    }",
      "}"
    ]
  },
  "jv-二维数组": {
    "prefix": "jv-二维数组",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        int[][] ns = {",
      "            { 1, 2, 3, 4 },",
      "            { 5, 6, 7, 8 },",
      "            { 9, 10, 11, 12 }",
      "        };",
      "        System.out.println(ns.length); // 3",
      "    }",
      "}"
    ]
  },
  "jv-二维数组2": {
    "prefix": "jv-二维数组2",
    "body": [
      "import java.util.Arrays;",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        int[][] ns = {",
      "            { 1, 2, 3, 4 },",
      "            { 5, 6, 7, 8 },",
      "            { 9, 10, 11, 12 }",
      "        };",
      "        System.out.println(Arrays.deepToString(ns));",
      "    }",
      "}",
      "for (int[] arr : ns) {",
      "    for (int n : arr) {",
      "        System.out.print(n);",
      "        System.out.print(', ');",
      "    }",
      "    System.out.println();",
      "}",
      "或者使用Java标准库的Arrays.deepToString()："
    ]
  },
  "jv-StringBuilder": {
    "prefix": "jv-StringBuilder",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        var sb = new StringBuilder(1024);",
      "        sb.append(\"Mr \")",
      "          .append(\"Bob\")",
      "          .append(\"!\")",
      "          .insert(0, \"Hello, \");",
      "        System.out.println(sb.toString());",
      "    }",
      "}"
    ]
  },
  "jv-StringJoiner": {
    "prefix": "jv-StringJoiner",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        String[] names = {\"Bob\", \"Alice\", \"Grace\"};",
      "        var sj = new StringJoiner(\", \");",
      "        for (String name : names) {",
      "            sj.add(name);",
      "        }",
      "        System.out.println(sj.toString());",
      "    }",
      "}",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        String[] names = {\"Bob\", \"Alice\", \"Grace\"};",
      "        var sj = new StringJoiner(\", \", \"Hello \", \"!\");",
      "        for (String name : names) {",
      "            sj.add(name);",
      "        }",
      "        System.out.println(sj.toString());",
      "    }",
      "}"
    ]
  },
  "jv-String.join": {
    "prefix": "jv-String.join",
    "body": [
      "String还提供了一个静态方法join()，这个方法在内部使用了StringJoiner来拼接字符串，在不需要指定“开头”和“结尾”的时候，用String.join()更方便：",
      "",
      "String[] names = {\"Bob\", \"Alice\", \"Grace\"};",
      "var s = String.join(\", \", names);"
    ]
  },
  "jv-BigInteger": {
    "prefix": "jv-BigInteger",
    "body": [
      "BigInteger",
      "在Java中，由CPU原生提供的整型最大范围是64位long型整数。使用long型整数可以直接通过CPU指令进行计算，速度非常快。",
      "",
      "如果我们使用的整数范围超过了long型怎么办？这个时候，就只能用软件来模拟一个大整数。java.math.BigInteger就是用来表示任意大小的整数。BigInteger内部用一个int[]数组来模拟一个非常大的整数：",
      "",
      "BigInteger bi = new BigInteger(\"1234567890\");",
      "System.out.println(bi.pow(5)); // 2867971860299718107233761438093672048294900000",
      "对BigInteger做运算的时候，只能使用实例方法，例如，加法运算：",
      "",
      "BigInteger i1 = new BigInteger(\"1234567890\");",
      "BigInteger i2 = new BigInteger(\"12345678901234567890\");",
      "BigInteger sum = i1.add(i2); // 12345678902469135780",
      "和long型整数运算比，BigInteger不会有范围限制，但缺点是速度比较慢。",
      "",
      "也可以把BigInteger转换成long型：",
      "",
      "BigInteger i = new BigInteger(\"123456789000\");",
      "System.out.println(i.longValue()); // 123456789000",
      "System.out.println(i.multiply(i).longValueExact()); // java.lang.ArithmeticException: BigInteger out of long range",
      "使用longValueExact()方法时，如果超出了long型的范围，会抛出ArithmeticException。",
      "",
      "BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法：",
      "",
      "转换为byte：byteValue()",
      "转换为short：shortValue()",
      "转换为int：intValue()",
      "转换为long：longValue()",
      "转换为float：floatValue()",
      "转换为double：doubleValue()",
      "因此，通过上述方法，可以把BigInteger转换成基本类型。如果BigInteger表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用intValueExact()、longValueExact()等方法，在转换时如果超出范围，将直接抛出ArithmeticException异常。",
      "",
      "如果BigInteger的值甚至超过了float的最大范围（3.4x1038），那么返回的float是什么呢？",
      "",
      "// BigInteger to float",
      "import java.math.BigInteger;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        BigInteger n = new BigInteger(\"999999\").pow(99);",
      "        float f = n.floatValue();",
      "        System.out.println(f);",
      "    }",
      "}",
      "",
      " Run",
      "小结",
      "BigInteger用于表示任意大小的整数；",
      "",
      "BigInteger是不变类，并且继承自Number；",
      "",
      "将BigInteger转换成基本类型时可使用longValueExact()等方法保证结果准确。"
    ]
  },
  "jv-BigDecimal": {
    "prefix": "jv-BigDecimal",
    "body": [
      "和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数。",
      "",
      "BigDecimal bd = new BigDecimal(\"123.4567\");",
      "System.out.println(bd.multiply(bd)); // 15241.55677489",
      "BigDecimal用scale()表示小数位数，例如：",
      "",
      "BigDecimal d1 = new BigDecimal(\"123.45\");",
      "BigDecimal d2 = new BigDecimal(\"123.4500\");",
      "BigDecimal d3 = new BigDecimal(\"1234500\");",
      "System.out.println(d1.scale()); // 2,两位小数",
      "System.out.println(d2.scale()); // 4",
      "System.out.println(d3.scale()); // 0",
      "通过BigDecimal的stripTrailingZeros()方法，可以将一个BigDecimal格式化为一个相等的，但去掉了末尾0的BigDecimal：",
      "",
      "BigDecimal d1 = new BigDecimal(\"123.4500\");",
      "BigDecimal d2 = d1.stripTrailingZeros();",
      "System.out.println(d1.scale()); // 4",
      "System.out.println(d2.scale()); // 2,因为去掉了00",
      "",
      "BigDecimal d3 = new BigDecimal(\"1234500\");",
      "BigDecimal d4 = d3.stripTrailingZeros();",
      "System.out.println(d3.scale()); // 0",
      "System.out.println(d4.scale()); // -2",
      "如果一个BigDecimal的scale()返回负数，例如，-2，表示这个数是个整数，并且末尾有2个0。",
      "",
      "可以对一个BigDecimal设置它的scale，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：",
      "",
      "import java.math.BigDecimal;",
      "import java.math.RoundingMode;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        BigDecimal d1 = new BigDecimal(\"123.456789\");",
      "        BigDecimal d2 = d1.setScale(4, RoundingMode.HALF_UP); // 四舍五入，123.4568",
      "        BigDecimal d3 = d1.setScale(4, RoundingMode.DOWN); // 直接截断，123.4567",
      "        System.out.println(d2);",
      "        System.out.println(d3);",
      "    }",
      "}",
      "",
      " Run",
      "对BigDecimal做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：",
      "",
      "BigDecimal d1 = new BigDecimal(\"123.456\");",
      "BigDecimal d2 = new BigDecimal(\"23.456789\");",
      "BigDecimal d3 = d1.divide(d2, 10, RoundingMode.HALF_UP); // 保留10位小数并四舍五入",
      "BigDecimal d4 = d1.divide(d2); // 报错：ArithmeticException，因为除不尽",
      "还可以对BigDecimal做除法的同时求余数：",
      "",
      "import java.math.BigDecimal;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        BigDecimal n = new BigDecimal(\"12.345\");",
      "        BigDecimal m = new BigDecimal(\"0.12\");",
      "        BigDecimal[] dr = n.divideAndRemainder(m);",
      "        System.out.println(dr[0]); // 102",
      "        System.out.println(dr[1]); // 0.105",
      "    }",
      "}",
      "",
      " Run",
      "调用divideAndRemainder()方法时，返回的数组包含两个BigDecimal，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个BigDecimal是否是整数倍数：",
      "",
      "BigDecimal n = new BigDecimal(\"12.75\");",
      "BigDecimal m = new BigDecimal(\"0.15\");",
      "BigDecimal[] dr = n.divideAndRemainder(m);",
      "if (dr[1].signum() == 0) {",
      "    // n是m的整数倍",
      "}",
      "比较BigDecimal",
      "在比较两个BigDecimal的值是否相等时，要特别注意，使用equals()方法不但要求两个BigDecimal的值相等，还要求它们的scale()相等：",
      "",
      "BigDecimal d1 = new BigDecimal(\"123.456\");",
      "BigDecimal d2 = new BigDecimal(\"123.45600\");",
      "System.out.println(d1.equals(d2)); // false,因为scale不同",
      "System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2",
      "System.out.println(d1.compareTo(d2)); // 0",
      "必须使用compareTo()方法来比较，它根据两个值的大小分别返回负数、正数和0，分别表示小于、大于和等于。",
      "",
      " 总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！",
      "如果查看BigDecimal的源码，可以发现，实际上一个BigDecimal是通过一个BigInteger和一个scale来表示的，即BigInteger表示一个完整的整数，而scale表示小数位数：",
      "",
      "public class BigDecimal extends Number implements Comparable<BigDecimal> {",
      "    private final BigInteger intVal;",
      "    private final int scale;",
      "}",
      "BigDecimal也是从Number继承的，也是不可变对象。",
      "",
      "小结",
      "BigDecimal用于表示精确的小数，常用于财务计算；",
      "",
      "比较BigDecimal的值是否相等，必须使用compareTo()而不能使用equals()。"
    ]
  },
  "jv-Random": {
    "prefix": "jv-Random",
    "body": [
      "Random用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。",
      "",
      "要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble()：",
      "",
      "Random r = new Random();",
      "r.nextInt(); // 2071575453,每次都不一样",
      "r.nextInt(10); // 5,生成一个[0,10)之间的int",
      "r.nextLong(); // 8811649292570369305,每次都不一样",
      "r.nextFloat(); // 0.54335...生成一个[0,1)之间的float",
      "r.nextDouble(); // 0.3716...生成一个[0,1)之间的double",
      "有童鞋问，每次运行程序，生成的随机数都是不同的，没看出伪随机数的特性来。",
      "",
      "这是因为我们创建Random实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。",
      "",
      "如果我们在创建Random实例时指定一个种子，就会得到完全确定的随机数序列：",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        Random r = new Random(12345);",
      "        for (int i = 0; i < 10; i++) {",
      "            System.out.println(r.nextInt(100));",
      "        }",
      "        // 51, 80, 41, 28, 55...",
      "    }",
      "}"
    ]
  },
  "jv-SecureRandom": {
    "prefix": "jv-SecureRandom",
    "body": [
      "有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，SecureRandom就是用来创建安全的随机数的：",
      "",
      "SecureRandom sr = new SecureRandom();",
      "System.out.println(sr.nextInt(100));",
      "SecureRandom无法指定种子，它使用RNG（random number generator）算法。JDK的SecureRandom实际上有多种不同的底层实现，有的使用安全随机种子加上伪随机数算法来产生安全的随机数，有的使用真正的随机数生成器。实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器："
    ]
  },
  "jv-Class": {
    "prefix": "jv-Class",
    "body": [
      "方法一：直接通过一个class的静态变量class获取：",
      "",
      "Class cls = String.class;",
      "方法二：如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：",
      "",
      "String s = \"Hello\";",
      "Class cls = s.getClass();",
      "方法三：如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：",
      "",
      "Class cls = Class.forName(\"java.lang.String\");",
      "因为Class实例在JVM中是唯一的，所以，上述方法获取的Class实例是同一个实例。可以用==比较两个Class实例：",
      "",
      "Class cls1 = String.class;",
      "",
      "String s = \"Hello\";",
      "Class cls2 = s.getClass();",
      "",
      "boolean sameClass = cls1 == cls2; // true",
      "注意一下Class实例比较和instanceof的差别：",
      "",
      "Integer n = new Integer(123);",
      "",
      "boolean b1 = n instanceof Integer; // true，因为n是Integer类型",
      "boolean b2 = n instanceof Number; // true，因为n是Number类型的子类",
      "",
      "boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class",
      "boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class"
    ]
  },
  "jv-Field": {
    "prefix": "jv-Field",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        Class stdClass = Student.class;",
      "        // 获取public字段\"score\":",
      "        System.out.println(stdClass.getField(\"score\"));",
      "        // 获取继承的public字段\"name\":",
      "        System.out.println(stdClass.getField(\"name\"));",
      "        // 获取private字段\"grade\":",
      "        System.out.println(stdClass.getDeclaredField(\"grade\"));",
      "    }",
      "}",
      "",
      "class Student extends Person {",
      "    public int score;",
      "    private int grade;",
      "}",
      "",
      "class Person {",
      "    public String name;",
      "}"
    ]
  },
  "jv-setAccessible": {
    "prefix": "jv-setAccessible",
    "body": [
      "上述代码先获取Class实例，再获取Field实例，然后，用Field.get(Object)获取指定实例的指定字段的值。",
      "",
      "运行代码，如果不出意外，会得到一个IllegalAccessException，这是因为name被定义为一个private字段，正常情况下，Main类无法访问Person类的private字段。要修复错误，可以将private改为public，或者，在调用Object value = f.get(p);前，先写一句：",
      "",
      "f.setAccessible(true);"
    ]
  },
  "jv-Method": {
    "prefix": "jv-Method",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        Class stdClass = Student.class;",
      "        // 获取public方法getScore，参数为String:",
      "        System.out.println(stdClass.getMethod(\"getScore\", String.class));",
      "        // 获取继承的public方法getName，无参数:",
      "        System.out.println(stdClass.getMethod(\"getName\"));",
      "        // 获取private方法getGrade，参数为int:",
      "        System.out.println(stdClass.getDeclaredMethod(\"getGrade\", int.class));",
      "    }",
      "}",
      "",
      "class Student extends Person {",
      "    public int getScore(String type) {",
      "        return 99;",
      "    }",
      "    private int getGrade(int year) {",
      "        return 1;",
      "    }",
      "}",
      "",
      "class Person {",
      "    public String getName() {",
      "        return \"Person\";",
      "    }",
      "}",
      "",
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        // String对象:",
      "        String s = \"Hello world\";",
      "        // 获取String substring(int)方法，参数为int:",
      "        Method m = String.class.getMethod(\"substring\", int.class);",
      "        // 在s对象上调用该方法并获取结果:",
      "        String r = (String) m.invoke(s, 6);",
      "        // 打印调用结果:",
      "        System.out.println(r);",
      "    }",
      "}"
    ]
  },
  "jv-调用非public方法": {
    "prefix": "jv-调用非public方法",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        Person p = new Person();",
      "        Method m = p.getClass().getDeclaredMethod(\"setName\", String.class);",
      "        m.setAccessible(true);",
      "        m.invoke(p, \"Bob\");",
      "        System.out.println(p.name);",
      "    }",
      "}",
      "",
      "class Person {",
      "    String name;",
      "    private void setName(String name) {",
      "        this.name = name;",
      "    }",
      "}"
    ]
  },
  "jv-Constructor": {
    "prefix": "jv-Constructor",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        // 获取构造方法Integer(int):",
      "        Constructor cons1 = Integer.class.getConstructor(int.class);",
      "        // 调用构造方法:",
      "        Integer n1 = (Integer) cons1.newInstance(123);",
      "        System.out.println(n1);",
      "",
      "        // 获取构造方法Integer(String)",
      "        Constructor cons2 = Integer.class.getConstructor(String.class);",
      "        Integer n2 = (Integer) cons2.newInstance(\"456\");",
      "        System.out.println(n2);",
      "    }",
      "}"
    ]
  },
  "jv-获取继承关系": {
    "prefix": "jv-获取继承关系",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        Class i = Integer.class;",
      "        Class n = i.getSuperclass();",
      "        System.out.println(n);",
      "        Class o = n.getSuperclass();",
      "        System.out.println(o);",
      "        System.out.println(o.getSuperclass());",
      "    }",
      "}",
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        Class s = Integer.class;",
      "        Class[] is = s.getInterfaces();",
      "        for (Class i : is) {",
      "            System.out.println(i);",
      "        }",
      "    }",
      "}"
    ]
  },
  "jv-动态代理": {
    "prefix": "jv-动态代理",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        InvocationHandler handler = new InvocationHandler() {",
      "            @Override",
      "            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {",
      "                System.out.println(method);",
      "                if (method.getName().equals(\"morning\")) {",
      "                    System.out.println(\"Good morning, \" + args[0]);",
      "                }",
      "                return null;",
      "            }",
      "        };",
      "        Hello hello = (Hello) Proxy.newProxyInstance(",
      "            Hello.class.getClassLoader(), // 传入ClassLoader",
      "            new Class[] { Hello.class }, // 传入要实现的接口",
      "            handler); // 传入处理调用方法的InvocationHandler",
      "        hello.morning(\"Bob\");",
      "    }",
      "}",
      "",
      "interface Hello {",
      "    void morning(String name);",
      "}"
    ]
  },
  "jv-定义注解": {
    "prefix": "jv-定义注解",
    "body": [
      "Java语言使用@interface语法来定义注解（Annotation），它的格式如下：",
      "",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。",
      "",
      "元注解",
      "有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。",
      "",
      "@Target",
      "最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：",
      "",
      "类或接口：ElementType.TYPE；",
      "字段：ElementType.FIELD；",
      "方法：ElementType.METHOD；",
      "构造方法：ElementType.CONSTRUCTOR；",
      "方法参数：ElementType.PARAMETER。",
      "例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：",
      "",
      "@Target(ElementType.METHOD)",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：",
      "",
      "@Target({",
      "    ElementType.METHOD,",
      "    ElementType.FIELD",
      "})",
      "public @interface Report {",
      "    ...",
      "}",
      "实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法。",
      "",
      "@Retention",
      "另一个重要的元注解@Retention定义了Annotation的生命周期：",
      "",
      "仅编译期：RetentionPolicy.SOURCE；",
      "仅class文件：RetentionPolicy.CLASS；",
      "运行期：RetentionPolicy.RUNTIME。",
      "如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解：",
      "",
      "@Retention(RetentionPolicy.RUNTIME)",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "@Repeatable",
      "使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。",
      "",
      "@Repeatable(Reports.class)",
      "@Target(ElementType.TYPE)",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "",
      "@Target(ElementType.TYPE)",
      "public @interface Reports {",
      "    Report[] value();",
      "}",
      "经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：",
      "",
      "@Report(type=1, level=\"debug\")",
      "@Report(type=2, level=\"warning\")",
      "public class Hello {",
      "}",
      "@Inherited",
      "使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：",
      "",
      "@Inherited",
      "@Target(ElementType.TYPE)",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "在使用的时候，如果一个类用到了@Report：",
      "",
      "@Report(type=1)",
      "public class Person {",
      "}",
      "则它的子类默认也定义了该注解：",
      "",
      "public class Student extends Person {",
      "}",
      "如何定义Annotation",
      "我们总结一下定义Annotation的步骤：",
      "",
      "第一步，用@interface定义注解：",
      "",
      "public @interface Report {",
      "}",
      "第二步，添加参数、默认值：",
      "",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。",
      "",
      "第三步，用元注解配置注解：",
      "",
      "@Target(ElementType.TYPE)",
      "@Retention(RetentionPolicy.RUNTIME)",
      "public @interface Report {",
      "    int type() default 0;",
      "    String level() default \"info\";",
      "    String value() default \"\";",
      "}",
      "其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。",
      "",
      "小结",
      "Java使用@interface定义注解：",
      "",
      "可定义多个参数和默认值，核心参数使用value名称；",
      "",
      "必须设置@Target来指定Annotation可以应用的范围；",
      "",
      "应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。"
    ]
  },
  "jv-处理注解": {
    "prefix": "jv-处理注解",
    "body": [
      "Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：",
      "",
      "SOURCE类型的注解在编译期就被丢掉了；",
      "CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；",
      "RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。",
      "如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有RUNTIME类型的注解不但要使用，还经常需要编写。",
      "",
      "因此，我们只讨论如何读取RUNTIME类型的注解。",
      "",
      "因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。",
      "",
      "Java提供的使用反射API读取Annotation的方法包括：",
      "",
      "判断某个注解是否存在于Class、Field、Method或Constructor：",
      "",
      "Class.isAnnotationPresent(Class)",
      "Field.isAnnotationPresent(Class)",
      "Method.isAnnotationPresent(Class)",
      "Constructor.isAnnotationPresent(Class)",
      "例如：",
      "",
      "// 判断@Report是否存在于Person类:",
      "Person.class.isAnnotationPresent(Report.class);",
      "使用反射API读取Annotation：",
      "",
      "Class.getAnnotation(Class)",
      "Field.getAnnotation(Class)",
      "Method.getAnnotation(Class)",
      "Constructor.getAnnotation(Class)",
      "例如：",
      "",
      "// 获取Person定义的@Report注解:",
      "Report report = Person.class.getAnnotation(Report.class);",
      "int type = report.type();",
      "String level = report.level();",
      "使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取：",
      "",
      "Class cls = Person.class;",
      "if (cls.isAnnotationPresent(Report.class)) {",
      "    Report report = cls.getAnnotation(Report.class);",
      "    ...",
      "}",
      "第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：",
      "",
      "Class cls = Person.class;",
      "Report report = cls.getAnnotation(Report.class);",
      "if (report != null) {",
      "   ...",
      "}",
      "读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：",
      "",
      "public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {",
      "}",
      "要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：",
      "",
      "// 获取Method实例:",
      "Method m = ...",
      "// 获取所有参数的Annotation:",
      "Annotation[][] annos = m.getParameterAnnotations();",
      "// 第一个参数（索引为0）的所有Annotation:",
      "Annotation[] annosOfName = annos[0];",
      "for (Annotation anno : annosOfName) {",
      "    if (anno instanceof Range) { // @Range注解",
      "        Range r = (Range) anno;",
      "    }",
      "    if (anno instanceof NotNull) { // @NotNull注解",
      "        NotNull n = (NotNull) anno;",
      "    }",
      "}",
      "使用注解",
      "注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。",
      "",
      "我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：",
      "",
      "@Retention(RetentionPolicy.RUNTIME)",
      "@Target(ElementType.FIELD)",
      "public @interface Range {",
      "    int min() default 0;",
      "    int max() default 255;",
      "}",
      "在某个JavaBean中，我们可以使用该注解：",
      "",
      "public class Person {",
      "    @Range(min=1, max=20)",
      "    public String name;",
      "",
      "    @Range(max=10)",
      "    public String city;",
      "}",
      "但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：",
      "",
      "void check(Person person) throws IllegalArgumentException, ReflectiveOperationException {",
      "    // 遍历所有Field:",
      "    for (Field field : person.getClass().getFields()) {",
      "        // 获取Field定义的@Range:",
      "        Range range = field.getAnnotation(Range.class);",
      "        // 如果@Range存在:",
      "        if (range != null) {",
      "            // 获取Field的值:",
      "            Object value = field.get(person);",
      "            // 如果值是String:",
      "            if (value instanceof String) {",
      "                String s = (String) value;",
      "                // 判断值是否满足@Range的min/max:",
      "                if (s.length() < range.min() || s.length() > range.max()) {",
      "                    throw new IllegalArgumentException(\"Invalid field: \" + field.getName());",
      "                }",
      "            }",
      "        }",
      "    }",
      "}",
      "这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。"
    ]
  },
  "jv-EnumMap": {
    "prefix": "jv-EnumMap",
    "body": [
      "因为HashMap是一种通过对key计算hashCode()，通过空间换时间的方式，直接定位到value所在的内部数组的索引，因此，查找效率非常高。",
      "",
      "如果作为key的对象是enum类型，那么，还可以使用Java集合库提供的一种EnumMap，它在内部以一个非常紧凑的数组存储value，并且根据enum类型的key直接定位到内部数组的索引，并不需要计算hashCode()，不但效率最高，而且没有额外的空间浪费。",
      "",
      "我们以DayOfWeek这个枚举类型为例，为它做一个“翻译”功能：",
      "",
      "import java.time.DayOfWeek;",
      "import java.util.*;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        Map<DayOfWeek, String> map = new EnumMap<>(DayOfWeek.class);",
      "        map.put(DayOfWeek.MONDAY, \"星期一\");",
      "        map.put(DayOfWeek.TUESDAY, \"星期二\");",
      "        map.put(DayOfWeek.WEDNESDAY, \"星期三\");",
      "        map.put(DayOfWeek.THURSDAY, \"星期四\");",
      "        map.put(DayOfWeek.FRIDAY, \"星期五\");",
      "        map.put(DayOfWeek.SATURDAY, \"星期六\");",
      "        map.put(DayOfWeek.SUNDAY, \"星期日\");",
      "        System.out.println(map);",
      "        System.out.println(map.get(DayOfWeek.MONDAY));",
      "    }",
      "}",
      "",
      " Run"
    ]
  },
  "jv-Queue": {
    "prefix": "jv-Queue",
    "body": [
      "队列（Queue）是一种经常使用的集合。Queue实际上是实现了一个先进先出（FIFO：First In First Out）的有序表。它和List的区别在于，List可以在任意位置添加和删除元素，而Queue只有两个操作：",
      "",
      "把元素添加到队列末尾；",
      "从队列头部取出元素。",
      "超市的收银台就是一个队列：",
      "",
      "queue",
      "",
      "在Java的标准库中，队列接口Queue定义了以下几个方法：",
      "",
      "int size()：获取队列长度；",
      "boolean add(E)/boolean offer(E)：添加元素到队尾；",
      "E remove()/E poll()：获取队首元素并从队列中删除；",
      "E element()/E peek()：获取队首元素但并不从队列中删除。",
      "对于具体的实现类，有的Queue有最大队列长度限制，有的Queue没有。注意到添加、删除和获取队列元素总是有两个方法，这是因为在添加或获取元素失败时，这两个方法的行为是不同的。我们用一个表格总结如下：",
      "",
      "throw Exception	返回false或null",
      "添加元素到队尾	add(E e)	boolean offer(E e)",
      "取队首元素并删除	E remove()	E poll()",
      "取队首元素但不删除	E element()	E peek()",
      "举个栗子，假设我们有一个队列，对它做一个添加操作，如果调用add()方法，当添加失败时（可能超过了队列的容量），它会抛出异常：",
      "",
      "Queue<String> q = ...",
      "try {",
      "    q.add(\"Apple\");",
      "    System.out.println(\"添加成功\");",
      "} catch(IllegalStateException e) {",
      "    System.out.println(\"添加失败\");",
      "}",
      "如果我们调用offer()方法来添加元素，当添加失败时，它不会抛异常，而是返回false：",
      "",
      "Queue<String> q = ...",
      "if (q.offer(\"Apple\")) {",
      "    System.out.println(\"添加成功\");",
      "} else {",
      "    System.out.println(\"添加失败\");",
      "}",
      "当我们需要从Queue中取出队首元素时，如果当前Queue是一个空队列，调用remove()方法，它会抛出异常：",
      "",
      "Queue<String> q = ...",
      "try {",
      "    String s = q.remove();",
      "    System.out.println(\"获取成功\");",
      "} catch(IllegalStateException e) {",
      "    System.out.println(\"获取失败\");",
      "}",
      "如果我们调用poll()方法来取出队首元素，当获取失败时，它不会抛异常，而是返回null：",
      "",
      "Queue<String> q = ...",
      "String s = q.poll();",
      "if (s != null) {",
      "    System.out.println(\"获取成功\");",
      "} else {",
      "    System.out.println(\"获取失败\");",
      "}",
      "因此，两套方法可以根据需要来选择使用。",
      "",
      "注意：不要把null添加到队列中，否则poll()方法返回null时，很难确定是取到了null元素还是队列为空。",
      "",
      "接下来我们以poll()和peek()为例来说说“获取并删除”与“获取但不删除”的区别。对于Queue来说，每次调用poll()，都会获取队首元素，并且获取到的元素已经从队列中被删除了：",
      "",
      "import java.util.LinkedList;",
      "import java.util.Queue;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        Queue<String> q = new LinkedList<>();",
      "        // 添加3个元素到队列:",
      "        q.offer(\"apple\");",
      "        q.offer(\"pear\");",
      "        q.offer(\"banana\");",
      "        // 从队列取出元素:",
      "        System.out.println(q.poll()); // apple",
      "        System.out.println(q.poll()); // pear",
      "        System.out.println(q.poll()); // banana",
      "        System.out.println(q.poll()); // null,因为队列是空的",
      "    }",
      "}",
      "",
      " Run",
      "如果用peek()，因为获取队首元素时，并不会从队列中删除这个元素，所以可以反复获取：",
      "",
      "import java.util.LinkedList;",
      "import java.util.Queue;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        Queue<String> q = new LinkedList<>();",
      "        // 添加3个元素到队列:",
      "        q.offer(\"apple\");",
      "        q.offer(\"pear\");",
      "        q.offer(\"banana\");",
      "        // 队首永远都是apple，因为peek()不会删除它:",
      "        System.out.println(q.peek()); // apple",
      "        System.out.println(q.peek()); // apple",
      "        System.out.println(q.peek()); // apple",
      "    }",
      "}",
      "",
      " Run",
      "从上面的代码中，我们还可以发现，LinkedList即实现了List接口，又实现了Queue接口，但是，在使用的时候，如果我们把它当作List，就获取List的引用，如果我们把它当作Queue，就获取Queue的引用：",
      "",
      "// 这是一个List:",
      "List<String> list = new LinkedList<>();",
      "// 这是一个Queue:",
      "Queue<String> queue = new LinkedList<>();",
      "始终按照面向抽象编程的原则编写代码，可以大大提高代码的质量。",
      "",
      "小结",
      "队列Queue实现了一个先进先出（FIFO）的数据结构：",
      "",
      "通过add()/offer()方法将元素添加到队尾；",
      "通过remove()/poll()从队首获取元素并删除；",
      "通过element()/peek()从队首获取元素但不删除。",
      "要避免把null添加到队列"
    ]
  },
  "jv-File": {
    "prefix": "jv-File",
    "body": [
      "在计算机系统中，文件是非常重要的存储方式。Java的标准库java.io提供了File对象来操作文件和目录。",
      "",
      "要构造一个File对象，需要传入文件路径：",
      "",
      "import java.io.*;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        File f = new File(\"C:\\Windows\\notepad.exe\");",
      "        System.out.println(f);",
      "    }",
      "}",
      "",
      " Run",
      "构造File对象时，既可以传入绝对路径，也可以传入相对路径。绝对路径是以根目录开头的完整路径，例如：",
      "",
      "File f = new File(\"C:\\Windows\\notepad.exe\");",
      "注意Windows平台使用\\作为路径分隔符，在Java字符串中需要用\\表示一个\\。Linux平台使用/作为路径分隔符：",
      "",
      "File f = new File(\"/usr/bin/javac\");",
      "传入相对路径时，相对路径前面加上当前目录就是绝对路径：",
      "",
      "// 假设当前目录是C:\\Docs",
      "File f1 = new File(\"sub\\javac\"); // 绝对路径是C:\\Docs\\sub\\javac",
      "File f3 = new File(\".\\sub\\javac\"); // 绝对路径是C:\\Docs\\sub\\javac",
      "File f3 = new File(\"..\\sub\\javac\"); // 绝对路径是C:\\sub\\javac",
      "可以用.表示当前目录，..表示上级目录。",
      "",
      "File对象有3种形式表示的路径，一种是getPath()，返回构造方法传入的路径，一种是getAbsolutePath()，返回绝对路径，一种是getCanonicalPath，它和绝对路径类似，但是返回的是规范路径。",
      "",
      "什么是规范路径？我们看以下代码：",
      "",
      "import java.io.*;",
      "public class Main {",
      "    public static void main(String[] args) throws IOException {",
      "        File f = new File(\"..\");",
      "        System.out.println(f.getPath());",
      "        System.out.println(f.getAbsolutePath());",
      "        System.out.println(f.getCanonicalPath());",
      "    }",
      "}",
      "",
      " Run",
      "绝对路径可以表示成C:\\Windows\\System32\\..\notepad.exe，而规范路径就是把.和..转换成标准的绝对路径后的路径：C:\\Windows\notepad.exe。",
      "",
      "因为Windows和Linux的路径分隔符不同，File对象有一个静态变量用于表示当前平台的系统分隔符：",
      "",
      "System.out.println(File.separator); // 根据当前平台打印",
      "文件和目录",
      "File对象既可以表示文件，也可以表示目录。特别要注意的是，构造一个File对象，即使传入的文件或目录不存在，代码也不会出错，因为构造一个File对象，并不会导致任何磁盘操作。只有当我们调用File对象的某些方法的时候，才真正进行磁盘操作。",
      "",
      "例如，调用isFile()，判断该File对象是否是一个已存在的文件，调用isDirectory()，判断该File对象是否是一个已存在的目录：",
      "",
      "import java.io.*;",
      "public class Main {",
      "    public static void main(String[] args) throws IOException {",
      "        File f1 = new File(\"C:\\Windows\");",
      "        File f2 = new File(\"C:\\Windows\\notepad.exe\");",
      "        File f3 = new File(\"C:\\Windows\\nothing\");",
      "        System.out.println(f1.isFile());",
      "        System.out.println(f1.isDirectory());",
      "        System.out.println(f2.isFile());",
      "        System.out.println(f2.isDirectory());",
      "        System.out.println(f3.isFile());",
      "        System.out.println(f3.isDirectory());",
      "    }",
      "}",
      "",
      " Run",
      "用File对象获取到一个文件时，还可以进一步判断文件的权限和大小：",
      "",
      "boolean canRead()：是否可读；",
      "boolean canWrite()：是否可写；",
      "boolean canExecute()：是否可执行；",
      "long length()：文件字节大小。",
      "对目录而言，是否可执行表示能否列出它包含的文件和子目录。",
      "",
      "创建和删除文件",
      "当File对象表示一个文件时，可以通过createNewFile()创建一个新文件，用delete()删除该文件：",
      "",
      "File file = new File(\"/path/to/file\");",
      "if (file.createNewFile()) {",
      "    // 文件创建成功:",
      "    // TODO:",
      "    if (file.delete()) {",
      "        // 删除文件成功:",
      "    }",
      "}",
      "有些时候，程序需要读写一些临时文件，File对象提供了createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件。",
      "",
      "import java.io.*;",
      "public class Main {",
      "    public static void main(String[] args) throws IOException {",
      "        File f = File.createTempFile(\"tmp-\", \".txt\"); // 提供临时文件的前缀和后缀",
      "        f.deleteOnExit(); // JVM退出时自动删除",
      "        System.out.println(f.isFile());",
      "        System.out.println(f.getAbsolutePath());",
      "    }",
      "}",
      "",
      " Run",
      "遍历文件和目录",
      "当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名。listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录：",
      "",
      "import java.io.*;",
      "public class Main {",
      "    public static void main(String[] args) throws IOException {",
      "        File f = new File(\"C:\\Windows\");",
      "        File[] fs1 = f.listFiles(); // 列出所有文件和子目录",
      "        printFiles(fs1);",
      "        File[] fs2 = f.listFiles(new FilenameFilter() { // 仅列出.exe文件",
      "            public boolean accept(File dir, String name) {",
      "                return name.endsWith(\".exe\"); // 返回true表示接受该文件",
      "            }",
      "        });",
      "        printFiles(fs2);",
      "    }",
      "",
      "    static void printFiles(File[] files) {",
      "        System.out.println(\"==========\");",
      "        if (files != null) {",
      "            for (File f : files) {",
      "                System.out.println(f);",
      "            }",
      "        }",
      "        System.out.println(\"==========\");",
      "    }",
      "}",
      "",
      " Run",
      "和文件操作类似，File对象如果表示一个目录，可以通过以下方法创建和删除目录：",
      "",
      "boolean mkdir()：创建当前File对象表示的目录；",
      "boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来；",
      "boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功。",
      "Path",
      "Java标准库还提供了一个Path对象，它位于java.nio.file包。Path对象和File对象类似，但操作更加简单：",
      "",
      "import java.io.*;",
      "import java.nio.file.*;",
      "public class Main {",
      "    public static void main(String[] args) throws IOException {",
      "        Path p1 = Paths.get(\".\", \"project\", \"study\"); // 构造一个Path对象",
      "        System.out.println(p1);",
      "        Path p2 = p1.toAbsolutePath(); // 转换为绝对路径",
      "        System.out.println(p2);",
      "        Path p3 = p2.normalize(); // 转换为规范路径",
      "        System.out.println(p3);",
      "        File f = p3.toFile(); // 转换为File对象",
      "        System.out.println(f);",
      "        for (Path p : Paths.get(\"..\").toAbsolutePath()) { // 可以直接遍历Path",
      "            System.out.println(\"  \" + p);",
      "        }",
      "    }",
      "}",
      "",
      " Run",
      "如果需要对目录进行"
    ]
  },
  "jv-read": {
    "prefix": "jv-read",
    "body": [
      "public void readFile() throws IOException {",
      "    try (InputStream input = new FileInputStream(\"src/readme.txt\")) {",
      "        // 定义1000个字节大小的缓冲区:",
      "        byte[] buffer = new byte[1000];",
      "        int n;",
      "        while ((n = input.read(buffer)) != -1) { // 读取到缓冲区",
      "            System.out.println(\"read \" + n + \" bytes.\");",
      "        }",
      "    }",
      "}"
    ]
  },
  "jv-Date": {
    "prefix": "jv-Date",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        // 获取当前时间:",
      "        Date date = new Date();",
      "        System.out.println(date.getYear() + 1900); // 必须加上1900",
      "        System.out.println(date.getMonth() + 1); // 0~11，必须加上1",
      "        System.out.println(date.getDate()); // 1~31，不能加1",
      "        // 转换为String:",
      "        System.out.println(date.toString());",
      "        // 转换为GMT时区:",
      "        System.out.println(date.toGMTString());",
      "        // 转换为本地时区:",
      "        System.out.println(date.toLocaleString());",
      "    }",
      "}"
    ]
  },
  "jv-SimpleDateFormat": {
    "prefix": "jv-SimpleDateFormat",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        // 获取当前时间:",
      "        Date date = new Date();",
      "        var sdf = new SimpleDateFormat(\"E MMM dd, yyyy\");",
      "        System.out.println(sdf.format(date));",
      "    }",
      "}"
    ]
  },
  "jv-Calendar": {
    "prefix": "jv-Calendar",
    "body": [
      "public class Main {",
      "    public static void main(String[] args) {",
      "        // 获取当前时间:",
      "        Calendar c = Calendar.getInstance();",
      "        int y = c.get(Calendar.YEAR);",
      "        int m = 1 + c.get(Calendar.MONTH);",
      "        int d = c.get(Calendar.DAY_OF_MONTH);",
      "        int w = c.get(Calendar.DAY_OF_WEEK);",
      "        int hh = c.get(Calendar.HOUR_OF_DAY);",
      "        int mm = c.get(Calendar.MINUTE);",
      "        int ss = c.get(Calendar.SECOND);",
      "        int ms = c.get(Calendar.MILLISECOND);",
      "        System.out.println(y + \"-\" + m + \"-\" + d + \" \" + w + \" \" + hh + \":\" + mm + \":\" + ss + \".\" + ms);",
      "    }",
      "}",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        // 当前时间:",
      "        Calendar c = Calendar.getInstance();",
      "        // 清除所有:",
      "        c.clear();",
      "        // 设置2019年:",
      "        c.set(Calendar.YEAR, 2019);",
      "        // 设置9月:注意8表示9月:",
      "        c.set(Calendar.MONTH, 8);",
      "        // 设置2日:",
      "        c.set(Calendar.DATE, 2);",
      "        // 设置时间:",
      "        c.set(Calendar.HOUR_OF_DAY, 21);",
      "        c.set(Calendar.MINUTE, 22);",
      "        c.set(Calendar.SECOND, 23);",
      "        System.out.println(new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(c.getTime()));",
      "        // 2019-09-02 21:22:23",
      "    }",
      "}"
    ]
  },
  "jv-LocalDateTime": {
    "prefix": "jv-LocalDateTime",
    "body": [
      "从Java 8开始，java.time包提供了新的日期和时间API，主要涉及的类型有：",
      "",
      "本地日期和时间：LocalDateTime，LocalDate，LocalTime；",
      "带时区的日期和时间：ZonedDateTime；",
      "时刻：Instant；",
      "时区：ZoneId，ZoneOffset；",
      "时间间隔：Duration。",
      "以及一套新的用于取代SimpleDateFormat的格式化类型DateTimeFormatter。",
      "",
      "和旧的API相比，新API严格区分了时刻、本地日期、本地时间和带时区的日期时间，并且，对日期和时间进行运算更加方便。",
      "",
      "此外，新API修正了旧API不合理的常量设计：",
      "",
      "Month的范围用1~12表示1月到12月；",
      "Week的范围用1~7表示周一到周日。",
      "最后，新API的类型几乎全部是不变类型（和String类似），可以放心使用不必担心被修改。",
      "",
      "LocalDateTime",
      "我们首先来看最常用的LocalDateTime，它表示一个本地日期和时间：",
      "",
      "import java.time.*;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        LocalDate d = LocalDate.now(); // 当前日期",
      "        LocalTime t = LocalTime.now(); // 当前时间",
      "        LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间",
      "        System.out.println(d); // 严格按照ISO 8601格式打印",
      "        System.out.println(t); // 严格按照ISO 8601格式打印",
      "        System.out.println(dt); // 严格按照ISO 8601格式打印",
      "    }",
      "}",
      "",
      " Run",
      "本地日期和时间通过now()获取到的总是以当前默认时区返回的，和旧API不同，LocalDateTime、LocalDate和LocalTime默认严格按照ISO 8601规定的日期和时间格式进行打印。",
      "",
      "上述代码其实有一个小问题，在获取3个类型的时候，由于执行一行代码总会消耗一点时间，因此，3个类型的日期和时间很可能对不上（时间的毫秒数基本上不同）。为了保证获取到同一时刻的日期和时间，可以改写如下：",
      "",
      "LocalDateTime dt = LocalDateTime.now(); // 当前日期和时间",
      "LocalDate d = dt.toLocalDate(); // 转换到当前日期",
      "LocalTime t = dt.toLocalTime(); // 转换到当前时间",
      "反过来，通过指定的日期和时间创建LocalDateTime可以通过of()方法：",
      "",
      "// 指定日期和时间:",
      "LocalDate d2 = LocalDate.of(2019, 11, 30); // 2019-11-30, 注意11=11月",
      "LocalTime t2 = LocalTime.of(15, 16, 17); // 15:16:17",
      "LocalDateTime dt2 = LocalDateTime.of(2019, 11, 30, 15, 16, 17);",
      "LocalDateTime dt3 = LocalDateTime.of(d2, t2);",
      "因为严格按照ISO 8601的格式，因此，将字符串转换为LocalDateTime就可以传入标准格式：",
      "",
      "LocalDateTime dt = LocalDateTime.parse(\"2019-11-19T15:16:17\");",
      "LocalDate d = LocalDate.parse(\"2019-11-19\");",
      "LocalTime t = LocalTime.parse(\"15:16:17\");",
      "注意ISO 8601规定的日期和时间分隔符是T。标准格式如下：",
      "",
      "日期：yyyy-MM-dd",
      "时间：HH:mm:ss",
      "带毫秒的时间：HH:mm:ss.SSS",
      "日期和时间：yyyy-MM-dd'T'HH:mm:ss",
      "带毫秒的日期和时间：yyyy-MM-dd'T'HH:mm:ss.SSS",
      "DateTimeFormatter",
      "如果要自定义输出的格式，或者要把一个非ISO 8601格式的字符串解析成LocalDateTime，可以使用新的DateTimeFormatter：",
      "",
      "import java.time.*;",
      "import java.time.format.*;",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        // 自定义格式化:",
      "        DateTimeFormatter dtf = DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\");",
      "        System.out.println(dtf.format(LocalDateTime.now()));",
      "",
      "        // 用自定义格式解析:",
      "        LocalDateTime dt2 = LocalDateTime.parse(\"2019/11/30 15:16:17\", dtf);",
      "        System.out.println(dt2);",
      "    }",
      "}",
      "",
      " Run"
    ]
  },
  "jv-ReentrantLock": {
    "prefix": "jv-ReentrantLock",
    "body": [
      "public class Counter {",
      "    private final Lock lock = new ReentrantLock();",
      "    private int count;",
      "",
      "    public void add(int n) {",
      "        lock.lock();",
      "        try {",
      "            count += n;",
      "        } finally {",
      "            lock.unlock();",
      "        }",
      "    }",
      "}"
    ]
  },
  "jv-Condition-ReentrantLock": {
    "prefix": "jv-Condition-ReentrantLock",
    "body": [
      "class TaskQueue {",
      "    private final Lock lock = new ReentrantLock();",
      "    private final Condition condition = lock.newCondition();",
      "    private Queue<String> queue = new LinkedList<>();",
      "",
      "    public void addTask(String s) {",
      "        lock.lock();",
      "        try {",
      "            queue.add(s);",
      "            condition.signalAll();",
      "        } finally {",
      "            lock.unlock();",
      "        }",
      "    }",
      "",
      "    public String getTask() {",
      "        lock.lock();",
      "        try {",
      "            while (queue.isEmpty()) {",
      "                condition.await();",
      "            }",
      "            return queue.remove();",
      "        } finally {",
      "            lock.unlock();",
      "        }",
      "    }",
      "}"
    ]
  },
  "jv-ReadWriteLock": {
    "prefix": "jv-ReadWriteLock",
    "body": [
      "public class Counter {",
      "    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();",
      "    private final Lock rlock = rwlock.readLock();",
      "    private final Lock wlock = rwlock.writeLock();",
      "    private int[] counts = new int[10];",
      "",
      "    public void inc(int index) {",
      "        wlock.lock(); // 加写锁",
      "        try {",
      "            counts[index] += 1;",
      "        } finally {",
      "            wlock.unlock(); // 释放写锁",
      "        }",
      "    }",
      "",
      "    public int[] get() {",
      "        rlock.lock(); // 加读锁",
      "        try {",
      "            return Arrays.copyOf(counts, counts.length);",
      "        } finally {",
      "            rlock.unlock(); // 释放读锁",
      "        }",
      "    }"
    ]
  },
  "jv-StampedLock": {
    "prefix": "jv-StampedLock",
    "body": [
      "前面介绍的ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。",
      "",
      "如果我们深入分析ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。",
      "",
      "要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。",
      "",
      "StampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。",
      "",
      "乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。",
      "",
      "我们来看例子：",
      "",
      "public class Point {",
      "    private final StampedLock stampedLock = new StampedLock();",
      "",
      "    private double x;",
      "    private double y;",
      "",
      "    public void move(double deltaX, double deltaY) {",
      "        long stamp = stampedLock.writeLock(); // 获取写锁",
      "        try {",
      "            x += deltaX;",
      "            y += deltaY;",
      "        } finally {",
      "            stampedLock.unlockWrite(stamp); // 释放写锁",
      "        }",
      "    }",
      "",
      "    public double distanceFromOrigin() {",
      "        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁",
      "        // 注意下面两行代码不是原子操作",
      "        // 假设x,y = (100,200)",
      "        double currentX = x;",
      "        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)",
      "        double currentY = y;",
      "        // 此处已读取到y，如果没有写入，读取是正确的(100,200)",
      "        // 如果有写入，读取是错误的(100,400)",
      "        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生",
      "            stamp = stampedLock.readLock(); // 获取一个悲观读锁",
      "            try {",
      "                currentX = x;",
      "                currentY = y;",
      "            } finally {",
      "                stampedLock.unlockRead(stamp); // 释放悲观读锁",
      "            }",
      "        }",
      "        return Math.sqrt(currentX * currentX + currentY * currentY);",
      "    }",
      "}",
      "和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过tryOptimisticRead()获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过validate()去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。",
      "",
      "可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。",
      "",
      "StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。",
      "",
      "小结",
      "StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；",
      "",
      "StampedLock是不可重入锁。"
    ]
  },
  "jv-Concurrent集合": {
    "prefix": "jv-Concurrent集合",
    "body": [
      "使用这些并发集合与使用非线程安全的集合类完全相同。我们以ConcurrentHashMap为例：",
      "",
      "Map<String, String> map = new ConcurrentHashMap<>();",
      "// 在不同的线程读写:",
      "map.put(\"A\", \"1\");",
      "map.put(\"B\", \"2\");",
      "map.get(\"A\", \"1\");",
      "因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：",
      "",
      "Map<String, String> map = new HashMap<>();",
      "改为：",
      "",
      "Map<String, String> map = new ConcurrentHashMap<>();",
      "就可以了。",
      "",
      "java.util.Collections工具类还提供了一个旧的线程安全集合转换器，可以这么用：",
      "",
      "Map unsafeMap = new HashMap();",
      "Map threadSafeMap = Collections.synchronizedMap(unsafeMap);",
      "但是它实际上是用一个包装类包装了非线程安全的Map，然后对所有读写方法都用synchronized加锁，这样获得的线程安全集合的性能比java.util.concurrent集合要低很多，所以不推荐使用"
    ]
  },
  "jv-Atomic": {
    "prefix": "jv-Atomic",
    "body": [
      "Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。",
      "",
      "我们以AtomicInteger为例，它提供的主要操作有：",
      "",
      "增加值并返回新值：int addAndGet(int delta)",
      "加1后返回新值：int incrementAndGet()",
      "获取当前值：int get()",
      "用CAS方式设置：int compareAndSet(int expect, int update)",
      "Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。",
      "",
      "如果我们自己通过CAS编写incrementAndGet()，它大概长这样：",
      "",
      "public int incrementAndGet(AtomicInteger var) {",
      "    int prev, next;",
      "    do {",
      "        prev = var.get();",
      "        next = prev + 1;",
      "    } while ( ! var.compareAndSet(prev, next));",
      "    return next;",
      "}",
      "CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do ... while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。",
      "",
      "我们利用AtomicLong可以编写一个多线程安全的全局唯一ID生成器：",
      "",
      "class IdGenerator {",
      "    AtomicLong var = new AtomicLong(0);",
      "",
      "    public long getNextId() {",
      "        return var.incrementAndGet();",
      "    }",
      "}",
      "通常情况下，我们并不需要直接用do ... while循环调用compareAndSet实现复杂的并发操作，而是用incrementAndGet()这样的封装好的方法，因此，使用起来非常简单。",
      "",
      "在高度竞争的情况下，还可以使用Java 8提供的LongAdder和LongAccumulator。",
      "",
      "小结",
      "使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程：",
      "",
      "原子操作实现了无锁的线程安全；",
      "",
      "适用于计数器，累加器等。"
    ]
  },
  "jv-Executors": {
    "prefix": "jv-Executors",
    "body": [
      "Java标准库提供了ExecutorService接口表示线程池，它的典型用法如下：",
      "",
      "// 创建固定大小的线程池:",
      "ExecutorService executor = Executors.newFixedThreadPool(3);",
      "// 提交任务:",
      "executor.submit(task1);",
      "executor.submit(task2);",
      "executor.submit(task3);",
      "executor.submit(task4);",
      "executor.submit(task5);",
      "因为ExecutorService只是接口，Java标准库提供的几个常用实现类有：",
      "",
      "FixedThreadPool：线程数固定的线程池；",
      "CachedThreadPool：线程数根据任务动态调整的线程池；",
      "SingleThreadExecutor：仅单线程执行的线程池。",
      "创建这些线程池的方法都被封装到Executors这个类中。我们以FixedThreadPool为例，看看线程池的执行逻辑：",
      "",
      "// thread-pool",
      "import java.util.concurrent.*;",
      "",
      "public class Main {",
      "    public static void main(String[] args) {",
      "        // 创建一个固定大小的线程池:",
      "        ExecutorService es = Executors.newFixedThreadPool(4);",
      "        for (int i = 0; i < 6; i++) {",
      "            es.submit(new Task(\"\" + i));",
      "        }",
      "        // 关闭线程池:",
      "        es.shutdown();",
      "    }",
      "}",
      "",
      "class Task implements Runnable {",
      "    private final String name;",
      "",
      "    public Task(String name) {",
      "        this.name = name;",
      "    }",
      "",
      "    @Override",
      "    public void run() {",
      "        System.out.println(\"start task \" + name);",
      "        try {",
      "            Thread.sleep(1000);",
      "        } catch (InterruptedException e) {",
      "        }",
      "        System.out.println(\"end task \" + name);",
      "    }",
      "}",
      "",
      " Run",
      "我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。",
      "",
      "线程池在程序结束的时候要关闭。使用shutdown()方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。shutdownNow()会立刻停止正在执行的任务，awaitTermination()则会等待指定的时间让线程池关闭。",
      "",
      "如果我们把线程池改为CachedThreadPool，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。"
    ]
  },
  "jv-Future": {
    "prefix": "jv-Future",
    "body": [
      "在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现Runnable接口，就可以让线程池去执行：",
      "",
      "class Task implements Runnable {",
      "    public String result;",
      "",
      "    public void run() {",
      "        this.result = longTimeCalculation(); ",
      "    }",
      "}",
      "Runnable接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个Callable接口，和Runnable接口比，它多了一个返回值：",
      "",
      "class Task implements Callable<String> {",
      "    public String call() throws Exception {",
      "        return longTimeCalculation(); ",
      "    }",
      "}",
      "并且Callable接口是一个泛型接口，可以返回指定类型的结果。",
      "",
      "现在的问题是，如何获得异步执行的结果？",
      "",
      "如果仔细看ExecutorService.submit()方法，可以看到，它返回了一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：",
      "",
      "ExecutorService executor = Executors.newFixedThreadPool(4); ",
      "// 定义任务:",
      "Callable<String> task = new Task();",
      "// 提交任务并获得Future:",
      "Future<String> future = executor.submit(task);",
      "// 从Future获取异步执行返回的结果:",
      "String result = future.get(); // 可能阻塞",
      "当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。",
      "",
      "一个Future<V>接口表示一个未来可能会返回的结果，它定义的方法有：",
      "",
      "get()：获取结果（可能会等待）",
      "get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；",
      "cancel(boolean mayInterruptIfRunning)：取消当前任务；",
      "isDone()：判断任务是否已完成"
    ]
  },
  "jv-CompletableFuture": {
    "prefix": "jv-CompletableFuture",
    "body": [
      "使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。",
      "",
      "从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。",
      "",
      "我们以获取股票价格为例，看看如何使用CompletableFuture：",
      "",
      "// CompletableFuture",
      "import java.util.concurrent.CompletableFuture;",
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        // 创建异步执行任务:",
      "        CompletableFuture<Double> cf = CompletableFuture.supplyAsync(Main::fetchPrice);",
      "        // 如果执行成功:",
      "        cf.thenAccept((result) -> {",
      "            System.out.println(\"price: \" + result);",
      "        });",
      "        // 如果执行异常:",
      "        cf.exceptionally((e) -> {",
      "            e.printStackTrace();",
      "            return null;",
      "        });",
      "        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:",
      "        Thread.sleep(200);",
      "    }",
      "",
      "    static Double fetchPrice() {",
      "        try {",
      "            Thread.sleep(100);",
      "        } catch (InterruptedException e) {",
      "        }",
      "        if (Math.random() < 0.3) {",
      "            throw new RuntimeException(\"fetch price failed!\");",
      "        }",
      "        return 5 + Math.random() * 20;",
      "    }",
      "}",
      "",
      " Run",
      "创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象：",
      "",
      "public interface Supplier<T> {",
      "    T get();",
      "}",
      "这里我们用lambda语法简化了一下，直接传入Main::fetchPrice，因为Main.fetchPrice()静态方法的签名符合Supplier接口的定义（除了方法名外）。",
      "",
      "紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象：",
      "",
      "public interface Consumer<T> {",
      "    void accept(T t);",
      "}",
      "异常时，CompletableFuture会调用Function对象：",
      "",
      "public interface Function<T, R> {",
      "    R apply(T t);",
      "}",
      "这里我们都用lambda语法简化了代码。",
      "",
      "可见CompletableFuture的优点是：",
      "",
      "异步任务结束时，会自动回调某个对象的方法；",
      "异步任务出错时，会自动回调某个对象的方法；",
      "主线程设置好回调后，不再关心异步任务的执行。",
      "如果只是实现了异步回调机制，我们还看不出CompletableFuture相比Future的优势。CompletableFuture更强大的功能是，多个CompletableFuture可以串行执行，例如，定义两个CompletableFuture，第一个CompletableFuture根据证券名称查询证券代码，第二个CompletableFuture根据证券代码查询证券价格，这两个CompletableFuture实现串行操作如下：",
      "",
      "// CompletableFuture",
      "import java.util.concurrent.CompletableFuture;",
      "public class Main {",
      "    public static void main(String[] args) throws Exception {",
      "        // 第一个任务:",
      "        CompletableFuture<String> cfQuery = CompletableFuture.supplyAsync(() -> {",
      "            return queryCode(\"中国石油\");",
      "        });",
      "        // cfQuery成功后继续执行下一个任务:",
      "        CompletableFuture<Double> cfFetch = cfQuery.thenApplyAsync((code) -> {",
      "            return fetchPrice(code);",
      "        });",
      "        // cfFetch成功后打印结果:",
      "        cfFetch.thenAccept((result) -> {",
      "            System.out.println(\"price: \" + result);",
      "        });",
      "        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:",
      "        Thread.sleep(2000);",
      "    }",
      "",
      "    static String queryCode(String name) {",
      "        try {",
      "            Thread.sleep(100);",
      "        } catch (InterruptedException e) {",
      "        }",
      "        return \"601857\";",
      "    }",
      "",
      "    static Double fetchPrice(String code) {",
      "        try {",
      "            Thread.sleep(100);",
      "        } catch (InterruptedException e) {",
      "        }",
      "        return 5 + Math.random() * 20;",
      "    }",
      "}",
      ""
    ]
  },
  "jv-ThreadLocal": {
    "prefix": "jv-ThreadLocal",
    "body": [
      "Java标准库提供了一个特殊的ThreadLocal，它可以在一个线程中传递同一个对象。",
      "",
      "ThreadLocal实例通常总是以静态字段初始化如下：",
      "",
      "static ThreadLocal<User> threadLocalUser = new ThreadLocal<>();",
      "它的典型使用方式如下：",
      "",
      "void processUser(user) {",
      "    try {",
      "        threadLocalUser.set(user);",
      "        step1();",
      "        step2();",
      "    } finally {",
      "        threadLocalUser.remove();",
      "    }",
      "}",
      "通过设置一个User实例关联到ThreadLocal中，在移除之前，所有方法都可以随时获取到该User实例：",
      "",
      "void step1() {",
      "    User u = threadLocalUser.get();",
      "    log();",
      "    printUser();",
      "}",
      "",
      "void log() {",
      "    User u = threadLocalUser.get();",
      "    println(u.name);",
      "}",
      "",
      "void step2() {",
      "    User u = threadLocalUser.get();",
      "    checkUser(u.id);",
      "}",
      "注意到普通的方法调用一定是同一个线程执行的，所以，step1()、step2()以及log()方法内，threadLocalUser.get()获取的User对象是同一个实例。",
      "",
      "实际上，可以把ThreadLocal看成一个全局Map<Thread, Object>：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：",
      "",
      "Object threadLocalValue = threadLocalMap.get(Thread.currentThread());",
      "因此，ThreadLocal相当于给每个线程都开辟了一个独立的存储空间，各个线程的ThreadLocal关联的实例互不干扰。",
      "",
      "最后，特别注意ThreadLocal一定要在finally中清除：",
      "",
      "try {",
      "    threadLocalUser.set(user);",
      "    ...",
      "} finally {",
      "    threadLocalUser.remove();",
      "}"
    ]
  },
  "jv-ServerSocket": {
    "prefix": "jv-ServerSocket",
    "body": [
      "服务器端",
      "要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了ServerSocket来实现对指定IP和指定端口的监听。ServerSocket的典型实现代码如下：",
      "",
      "public class Server {",
      "    public static void main(String[] args) throws IOException {",
      "        ServerSocket ss = new ServerSocket(6666); // 监听指定端口",
      "        System.out.println(\"server is running...\");",
      "        for (;;) {",
      "            Socket sock = ss.accept();",
      "            System.out.println(\"connected from \" + sock.getRemoteSocketAddress());",
      "            Thread t = new Handler(sock);",
      "            t.start();",
      "        }",
      "    }",
      "}",
      "",
      "class Handler extends Thread {",
      "    Socket sock;",
      "",
      "    public Handler(Socket sock) {",
      "        this.sock = sock;",
      "    }",
      "",
      "    @Override",
      "    public void run() {",
      "        try (InputStream input = this.sock.getInputStream()) {",
      "            try (OutputStream output = this.sock.getOutputStream()) {",
      "                handle(input, output);",
      "            }",
      "        } catch (Exception e) {",
      "            try {",
      "                this.sock.close();",
      "            } catch (IOException ioe) {",
      "            }",
      "            System.out.println(\"client disconnected.\");",
      "        }",
      "    }",
      "",
      "    private void handle(InputStream input, OutputStream output) throws IOException {",
      "        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));",
      "        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));",
      "        writer.write(\"hello\n\");",
      "        writer.flush();",
      "        for (;;) {",
      "            String s = reader.readLine();",
      "            if (s.equals(\"bye\")) {",
      "                writer.write(\"bye\n\");",
      "                writer.flush();",
      "                break;",
      "            }",
      "            writer.write(\"ok: \" + s + \"\n\");",
      "            writer.flush();",
      "        }",
      "    }",
      "}",
      "服务器端通过代码：",
      "",
      "ServerSocket ss = new ServerSocket(6666);",
      "在指定端口6666监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。",
      "",
      "如果ServerSocket监听成功，我们就使用一个无限循环来处理客户端的连接：",
      "",
      "for (;;) {",
      "    Socket sock = ss.accept();",
      "    Thread t = new Handler(sock);",
      "    t.start();",
      "}",
      "注意到代码ss.accept()表示每当有新的客户端连接进来后，就返回一个Socket实例，这个Socket实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的Socket创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。",
      "",
      "我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。",
      "",
      "如果没有客户端连接进来，accept()方法会阻塞并一直等待。如果有多个客户端同时连接进来，ServerSocket会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用accept()就可以获取新的连接。",
      "",
      "客户端",
      "相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：",
      "",
      "public class Client {",
      "    public static void main(String[] args) throws IOException {",
      "        Socket sock = new Socket(\"localhost\", 6666); // 连接指定服务器和端口",
      "        try (InputStream input = sock.getInputStream()) {",
      "            try (OutputStream output = sock.getOutputStream()) {",
      "                handle(input, output);",
      "            }",
      "        }",
      "        sock.close();",
      "        System.out.println(\"disconnected.\");",
      "    }",
      "",
      "    private static void handle(InputStream input, OutputStream output) throws IOException {",
      "        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));",
      "        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));",
      "        Scanner scanner = new Scanner(System.in);",
      "        System.out.println(\"[server] \" + reader.readLine());",
      "        for (;;) {",
      "            System.out.print(\">>> \"); // 打印提示",
      "            String s = scanner.nextLine(); // 读取一行输入",
      "            writer.write(s);",
      "            writer.newLine();",
      "            writer.flush();",
      "            String resp = reader.readLine();",
      "            System.out.println(\"<<< \" + resp);",
      "            if (resp.equals(\"bye\")) {",
      "                break;",
      "            }",
      "        }",
      "    }",
      "}",
      "客户端程序通过：",
      "",
      "Socket sock = new Socket(\"localhost\", 6666);",
      "连接到服务器端，注意上述代码的服务器地址是\"localhost\"，表示本机地址，端口号是6666。如果连接成功，将返回一个Socket实例，用于后续通信。"
    ]
  },
  "jv-DatagramSocket": {
    "prefix": "jv-DatagramSocket",
    "body": [
      "服务器端",
      "在服务器端，使用UDP也需要监听指定的端口。Java提供了DatagramSocket来实现这个功能，代码如下：",
      "",
      "DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口",
      "for (;;) { // 无限循环",
      "    // 数据缓冲区:",
      "    byte[] buffer = new byte[1024];",
      "    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);",
      "    ds.receive(packet); // 收取一个UDP数据包",
      "    // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度",
      "    // 将其按UTF-8编码转换为String:",
      "    String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);",
      "    // 发送数据:",
      "    byte[] data = \"ACK\".getBytes(StandardCharsets.UTF_8);",
      "    packet.setData(data);",
      "    ds.send(packet);",
      "}",
      "服务器端首先使用如下语句在指定的端口监听UDP数据包：",
      "",
      "DatagramSocket ds = new DatagramSocket(6666);",
      "如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：",
      "",
      "for (;;) {",
      "    ...",
      "}",
      "要接收一个UDP数据包，需要准备一个byte[]缓冲区，并通过DatagramPacket实现接收：",
      "",
      "byte[] buffer = new byte[1024];",
      "DatagramPacket packet = new DatagramPacket(buffer, buffer.length);",
      "ds.receive(packet);",
      "假设我们收取到的是一个String，那么，通过DatagramPacket返回的packet.getOffset()和packet.getLength()确定数据在缓冲区的起止位置：",
      "",
      "String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);",
      "当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。",
      "",
      "发送UDP包也是通过DatagramPacket实现的，发送代码非常简单：",
      "",
      "byte[] data = ...",
      "packet.setData(data);",
      "ds.send(packet);",
      "客户端",
      "和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：",
      "",
      "DatagramSocket ds = new DatagramSocket();",
      "ds.setSoTimeout(1000);",
      "ds.connect(InetAddress.getByName(\"localhost\"), 6666); // 连接指定服务器和端口",
      "// 发送:",
      "byte[] data = \"Hello\".getBytes();",
      "DatagramPacket packet = new DatagramPacket(data, data.length);",
      "ds.send(packet);",
      "// 接收:",
      "byte[] buffer = new byte[1024];",
      "packet = new DatagramPacket(buffer, buffer.length);",
      "ds.receive(packet);",
      "String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());",
      "ds.disconnect();"
    ]
  },
  "jv-iterator.remove": {
    "prefix": "jv-iterator.remove",
    "body": [
      "【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator",
      "方式，如果并发操作，需要对 Iterator 对象加锁。",
      "正例：",
      "Iterator<String> iterator = list.iterator();",
      "while (iterator.hasNext()) {",
      "String item = iterator.next();",
      "if (删除元素的条件) {",
      "iterator.remove();",
      "}",
      "}",
      "反例：",
      "List<String> list = new ArrayList<String>();",
      "list.add(\"1\");",
      "list.add(\"2\");",
      "for (String item : list) {",
      "if (\"1\".equals(item)) {",
      "list.remove(item);",
      "}",
      "} "
    ]
  },
  "jv-Comparator": {
    "prefix": "jv-Comparator",
    "body": [
      "【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，",
      "Collections.sort 会报 IllegalArgumentException 异常。",
      "说明：三个条件如下",
      "1） x，y 的比较结果和 y，x 的比较结果相反。",
      "阿里巴巴 Java 开发手册",
      " ——禁止用于商业用途，违者必究—— 11 /35",
      "2） x>y，y>z，则 x>z。",
      "3） x=y，则 x，z 比较结果和 y，z 比较结果相同。",
      "反例：下例中没有处理相等的情况，实际使用中可能会出现异常：",
      "new Comparator<Student>() {",
      "@Override",
      "public int compare(Student o1, Student o2) {",
      "return o1.getId() > o2.getId() ? 1 : -1;",
      "}",
      "};"
    ]
  },
  "jv-SimpleDateFormat-ThreadLocal": {
    "prefix": "jv-SimpleDateFormat-ThreadLocal",
    "body": [
      " 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为",
      "static，必须加锁，或者使用 DateUtils 工具类。",
      "正例：注意线程安全，使用 DateUtils。亦推荐如下处理：",
      "private static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {",
      "@Override",
      "protected DateFormat initialValue() {",
      "return new SimpleDateFormat(\"yyyy-MM-dd\");",
      "}",
      "};",
      "说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，",
      "DateTimeFormatter 代替 SimpleDateFormat，官方给出的解释：simple beautiful strong",
      "immutable thread-safe。"
    ]
  },
  "jv-ThreadLocalRandom": {
    "prefix": "jv-ThreadLocalRandom",
    "body": [
      "【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一",
      "seed 导致的性能下降。",
      "说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。",
      "正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保",
      "证每个线程持有一个实例。"
    ]
  },
  "jv-volatile": {
    "prefix": "jv-volatile",
    "body": [
      "【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优",
      "化问题隐患(可参考 The \"Double-Checked Locking is Broken\" Declaration)，推荐解",
      "决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。",
      "反例：",
      "class Singleton {",
      "private Helper helper = null;",
      "public Helper getHelper() {",
      "if (helper == null) synchronized(this) {",
      "if (helper == null)",
      "helper = new Helper();",
      "}",
      "return helper;",
      "}",
      "// other methods and fields...",
      "} "
    ]
  },
  "jv-AtomicInteger": {
    "prefix": "jv-AtomicInteger",
    "body": [
      "【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，",
      "但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：",
      "AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推",
      "荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。"
    ]
  },
  "jv-equals": {
    "prefix": "jv-equals",
    "body": [
      "  @Override",
      "59    public boolean equals(Object o) {",
      "60        if (this == o) {",
      "61            return true;",
      "62        }",
      "63        if (o == null || o.getClass() != Song.class) {",
      "64            return false;",
      "65        }",
      "66",
      "67        Song that = (Song) o;",
      "68",
      "69        return mSongId == that.getSongId();",
      "70    }",
      "71",
      "72    @Override",
      "73    public int hashCode() {",
      "74        return Long.hashCode(mSongId);",
      "75    }"
    ]
  },
  "jv-RandomAccessFile": {
    "prefix": "jv-RandomAccessFile",
    "body": [
      "public class Test {  ",
      "",
      "    public static void main(String[] args) throws Exception {  ",
      "        // 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件  ",
      "        RandomAccessFile raf = new RandomAccessFile(\"D://abc.txt\", \"rw\");  ",
      "        raf.setLength(1024*1024); // 预分配 1M 的文件空间  ",
      "        raf.close();  ",
      "",
      "        // 所要写入的文件内容  ",
      "        String s1 = \"第一个字符串\";  ",
      "        String s2 = \"第二个字符串\";  ",
      "        String s3 = \"第三个字符串\";  ",
      "        String s4 = \"第四个字符串\";  ",
      "        String s5 = \"第五个字符串\";  ",
      "",
      "        // 利用多线程同时写入一个文件  ",
      "        new FileWriteThread(1024*1,s1.getBytes()).start(); // 从文件的1024字节之后开始写入数据  ",
      "        new FileWriteThread(1024*2,s2.getBytes()).start(); // 从文件的2048字节之后开始写入数据  ",
      "        new FileWriteThread(1024*3,s3.getBytes()).start(); // 从文件的3072字节之后开始写入数据  ",
      "        new FileWriteThread(1024*4,s4.getBytes()).start(); // 从文件的4096字节之后开始写入数据  ",
      "        new FileWriteThread(1024*5,s5.getBytes()).start(); // 从文件的5120字节之后开始写入数据  ",
      "    }  ",
      "",
      "    // 利用线程在文件的指定位置写入指定数据  ",
      "    static class FileWriteThread extends Thread{  ",
      "        private int skip;  ",
      "        private byte[] content;  ",
      "",
      "        public FileWriteThread(int skip,byte[] content){  ",
      "            this.skip = skip;  ",
      "            this.content = content;  ",
      "        }  ",
      "",
      "        public void run(){  ",
      "            RandomAccessFile raf = null;  ",
      "            try {  ",
      "                raf = new RandomAccessFile(\"D://abc.txt\", \"rw\");  ",
      "                raf.seek(skip);  ",
      "                raf.write(content);  ",
      "            } catch (FileNotFoundException e) {  ",
      "                e.printStackTrace();  ",
      "            } catch (IOException e) {  ",
      "                // TODO Auto-generated catch block  ",
      "                e.printStackTrace();  ",
      "            } finally {  ",
      "                try {  ",
      "                    raf.close();  ",
      "                } catch (Exception e) {  ",
      "                }  ",
      "            }  ",
      "        }  ",
      "    }  ",
      "",
      "}"
    ]
  },
  "jv-File2": {
    "prefix": "jv-File2",
    "body": [
      ".File类构造函数",
      "构造函数",
      "//构造函数File(String pathname)",
      "File f1 =new File(\"c:\\abc\\1.txt\");",
      "//File(String parent,String child)",
      "File f2 =new File(\"c:\\abc\",\"2.txt\");",
      "//File(File parent,String child)",
      "File f3 =new File(\"c:\"+File.separator+\"abc\");//separator 跨平台分隔符",
      "File f4 =new File(f3,\"3.txt\");",
		"System.out.println(f1);//c:\abc\1.txt",
      "路径分隔符：",
      "windows： \"/\" \"\" 都可以",
      "linux/unix： \"/\"",
      "注意:如果windows选择用\"\"做分割符的话,那么请记得替换成\"\\",因为Java中\"\"代表转义字符",
      "所以推荐都使用\"/\"，也可以直接使用代码File.separator，表示跨平台分隔符。",
      "路径：",
      "相对路径：",
      "./表示当前路径",
      "../表示上一级路径",
      "其中当前路径：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性 user.dir 指定，通常是 Java 虚拟机的调用目录。”",
      "绝对路径：",
      "绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件。博客",
      "03.创建与删除方法",
      "如下所示",
      "//如果文件存在返回false，否则返回true并且创建文件 ",
      "boolean createNewFile();",
      "//创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。只会创建最后一级目录，如果上级目录不存在就抛异常。",
      "boolean mkdir();",
      "//创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。创建多级目录，创建路径中所有不存在的目录",
      "boolean mkdirs()    ;",
      "//如果文件存在返回true并且删除文件，否则返回false",
      "boolean delete();",
      "//在虚拟机终止时，删除File对象所表示的文件或目录。",
      "void deleteOnExit();",
      "04.File判断方法",
      "如下所示",
      "boolean canExecute()    ;//判断文件是否可执行",
      "boolean canRead();//判断文件是否可读",
      "boolean canWrite();//判断文件是否可写",
      "boolean exists();//判断文件是否存在",
      "boolean isDirectory();//判断是否是目录",
      "boolean isFile();//判断是否是文件",
      "boolean isHidden();//判断是否是隐藏文件或隐藏目录",
      "boolean isAbsolute();//判断是否是绝对路径 文件不存在也能判断",
      "05.File获取方法",
      "如下所示",
      "String getName();//返回文件或者是目录的名称",
      "String getPath();//返回路径",
      "String getAbsolutePath();//返回绝对路径",
      "String getParent();//返回父目录，如果没有父目录则返回null",
      "long lastModified();//返回最后一次修改的时间",
      "long length();//返回文件的长度",
      "File[] listRoots();// 列出所有的根目录（Window中就是所有系统的盘符）",
      "String[] list() ;//返回一个字符串数组，给定路径下的文件或目录名称字符串",
      "String[] list(FilenameFilter filter);//返回满足过滤器要求的一个字符串数组",
      "File[]  listFiles();//返回一个文件对象数组，给定路径下文件或目录",
      "File[] listFiles(FilenameFilter filter);//返回满足过滤器要求的一个文件对象数组",
      "其中包含了一个重要的接口FileNameFilter",
      "该接口是个文件过滤器，包含了一个accept(File dir,String name)方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。",
      "// 文件过滤",
      "File[] files = file.listFiles(new FilenameFilter() {",
      "    @Override",
      "    public boolean accept(File file, String filename) {",
      "        return filename.endsWith(\".mp3\");",
      "    }",
      "});",
      "file目录下的所有子文件如果满足后缀是.mp3的条件的文件都会被过滤出来。",
    ]
  },
  "jv-deadLock": {
    "prefix": "jv-deadLock",
    "body": [
      "产生死锁代码",
      "代码如下所示",
      "这种方法将直接导致死锁",
      "private final Object obj1 = new Object();",
      "private final Object obj2 = new Object();",
      "private void test1() {",
      "    new Thread(){",
      "        @Override",
      "        public void run() {",
      "            synchronized (obj1){",
      "                try {",
      "                    System.out.println(\"yc---Thread1 obj1\");",
      "                    Thread.sleep(1000);",
      "                } catch (InterruptedException e) {",
      "                    e.printStackTrace();",
      "                }",
      "                synchronized (obj2){",
      "                    System.out.println(\"yc---Thread1 obj2\");",
      "                }",
      "            }",
      "        }",
      "    }.start();",
      "    new Thread(){",
      "        @Override",
      "        public void run() {",
      "            synchronized (obj2){",
      "                System.out.println(\"yc---Thread2 obj2\");",
      "                synchronized (obj1){",
      "                    System.out.println(\"yc---Thread2 obj1\");",
      "                }",
      "            }",
      "        }",
      "    }.start();",
      "}",
      "",
      "//打印结果：",
      "10-18 17:11:34.255 30427-30478/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj1",
      "10-18 17:11:34.257 30427-30479/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj2",
      "接下来去掉上面代码中的Thread.sleep(1000)代码",
      "注意去掉了这行代码后，开始时可以正常打印日志，多次触发test1()方法后，发现最终也会出现死锁问题。",
      "private final Object obj1 = new Object();",
      "private final Object obj2 = new Object();",
      "private void test1() {",
      "    new Thread(){",
      "        @Override",
      "        public void run() {",
      "            synchronized (obj1){",
      "                System.out.println(\"yc---Thread1 obj1\");",
      "                synchronized (obj2){",
      "                    System.out.println(\"yc---Thread1 obj2\");",
      "                }",
      "            }",
      "        }",
      "    }.start();",
      "    new Thread(){",
      "        @Override",
      "        public void run() {",
      "            synchronized (obj2){",
      "                System.out.println(\"yc---Thread2 obj2\");",
      "                synchronized (obj1){",
      "                    System.out.println(\"yc---Thread2 obj1\");",
      "                }",
      "            }",
      "        }",
      "    }.start();",
      "}",
      "",
      "//打印日志",
      "10-18 17:35:44.662 4341-4412/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj1",
      "10-18 17:35:44.662 4341-4412/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj2",
      "10-18 17:35:44.663 4341-4413/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj2",
      "10-18 17:35:44.663 4341-4413/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj1",
      "10-18 17:35:45.967 4341-4417/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj1",
      "10-18 17:35:45.968 4341-4417/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj2",
      "10-18 17:35:45.968 4341-4418/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj2",
      "10-18 17:35:45.968 4341-4418/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj1",
      "10-18 17:35:46.643 4341-4422/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj1",
      "10-18 17:35:46.643 4341-4422/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj2",
      "10-18 17:35:46.647 4341-4423/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj2",
      "10-18 17:35:46.647 4341-4423/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj1",
      "10-18 17:35:46.913 4341-4424/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj1",
      "10-18 17:35:46.913 4341-4424/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj2",
      "10-18 17:35:46.913 4341-4425/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj2",
      "10-18 17:35:46.914 4341-4425/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj1",
      "10-18 17:35:47.117 4341-4426/com.yc.cn.ycbaseadapter I/System.out: yc---Thread1 obj1",
      "10-18 17:35:47.118 4341-4427/com.yc.cn.ycbaseadapter I/System.out: yc---Thread2 obj2",
      "1.3 死锁发生的场景",
      "死锁不仅仅是在线程之间会发生，存在资源独占的进程之间同样也可能出现死锁。大多是聚焦在多线程场景中的死锁，指两个或多个线程之间，由于互相持有对方需要的锁，而永久处于阻塞的状态。",
      "2.Java中导致死锁的原因",
      "2.1 造成死锁原因",
      "在申请锁时发生了交叉闭环申请。即线程在获得了锁1并且没有释放的情况下去申请锁2，这时，另一个线程已经获得了锁2，在释放锁2之前又要先获得锁1，因此闭环发生，陷入死锁循环。",
      "image",
      "2.2 死锁的危害",
      "从上面死锁代码案例可以知道，当发生死锁的时候，导致彼此一直处于等待之中，而导致代码无法执行下去。只能重启，后果比较严重！",
      "在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。系统发生死锁现象不仅浪费大量的系统资源，甚至导致整个系统崩溃，带来灾难性后果。",
      "3.出现死锁需要满足条件",
      "3.1 死锁问题条件",
      "互斥条件：一个资源每次只能被一个线程使用。",
      "请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。",
      "不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。",
      "循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。",
      "3.2 如何预防死锁",
      "死锁发生时的四个必要条件，只要破坏这四个必要条件中的任意一个条件，死锁就不会发生。这就为我们解决死锁问题提供了可能。一般地，解决死锁的方法分为死锁的预防，避免，检测[定位死锁的位置]与恢复三种（注意：死锁的检测与恢复是一个方法）。 锁的预防是保证系统不进入死锁状态的一种策略。它的基本思想是要求进程申请资源时遵循某种协议，从而打破产生死锁的四个必要条件中的一个或几个，保证系统不会进入死锁状态。",
      "打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并无实用价值。",
      "打破不可抢占条件。即允许进程强行从占有者那里夺取某些资源。就是说，当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。",
      "打破占有且申请条件。可以实行资源预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。但是，这种策略也有如下缺点：",
      "在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源。这是由于进程在执行时是动态的，不可预测的；",
      "资源利用率低。无论所分资源何时用到，一个进程只有在占有所需的全部资源后才能执行。即使有些资源最后才被该进程用到一次，但该进程在生存期间却一直占有它们，造成长期占着不用的状况。这显然是一种极大的资源浪费；",
      "降低了进程的并发性。因为资源有限，又加上存在浪费，能分配到所需全部资源的进程个数就必然少了。",
      "打破循环等待条件，实行资源有序分配策略。采用这种策略，即把资源事先分类编号，按号分配，使进程在申请，占用资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占用了小号资源，才能申请大号资源，就不会产生环路，从而预防了死锁。这种策略与前面的策略相比，资源的利用率和系统吞吐量都有很大提高，但是也存在以下缺点：",
      "限制了进程对资源的请求，同时给系统中所有资源合理编号也是件困难事，并增加了系统开销；",
      "为了遵循按编号申请的次序，暂不使用的资源也需要提前申请，从而增加了进程对资源的占用时间。",
      "4.死锁诊断步骤",
      "4.1 如何定位死锁",
      "定位死锁最常用的工具就是利用jstack等工具获取线程栈，然后定位相互之间的依赖关系，进而找到死锁。如果是比较明显的死锁，往往jstack工具就能直接定位，类似JConsole甚至可以在图形界面进行有限的死锁检测。",
      "如果程序运行时发生了死锁，绝大多数情况下都是无法在线解决的，只能重启、修正程序本身问题。所以，代码开发阶段相互审查，或者利用工具进行预防性排查，也是很重要的。",
      "1.首先，可以使用 jps 或者系统的 ps 命令、任务管理器等工具，确定进程 ID。",
      "2.调用 jstack 获取线程栈：jstack your-pid",
      "3.然后看看日志，思考怎么用studio将日志打印出来呢？",
      "5.死锁修复解决方案",
      "5.1 死锁修复方案",
      "如果在死锁检查时发现了死锁情况，那么就要努力消除死锁，使系统从死锁状态中恢复过来。消除死锁的几种方式：",
      "1.最简单、最常用的方法就是进行系统的重新启动，不过这种方法代价很大，它意味着在这之前所有的进程已经完成的计算工作都将付之东流，包括参与死锁的那些进程，以及未参与死锁的进程；",
      "2.撤消进程，剥夺资源。终止参与死锁的进程，收回它们占有的资源，从而解除死锁。这时又分两种情况：一次性撤消参与死锁的全部进程，剥夺全部资源；或者逐步撤消参与死锁的进程，逐步收回死锁进程占有的资源。一般来说，选择逐步撤消的进程时要按照一定的原则进行，目的是撤消那些代价最小的进程，比如按进程的优先级确定进程的代价；考虑进程运行时的代价和与此进程相关的外部作业的代价等因素；",
      "3.进程回退策略，即让参与死锁的进程回退到没有发生死锁前某一点处，并由此点处继续执行，以求再次执行时不再发生死锁。虽然这是个较理想的办法，但是操作起来系统开销极大，要有堆栈这样的机构记录进程的每一步变化，以便今后的回退，有时这是无法做到的。",
      "6.手写死锁代码",
      "死锁的简单代码",
      "思路是创建两个字符串a和b，再创建两个线程A和B，让每个线程都用synchronized锁住字符串（A先锁a，再去锁b；B先锁b，再锁a），如果A锁住a，B锁住b，A就没办法锁住b，B也没办法锁住a，这时就陷入了死锁。",
      "打印结果：可以看到，Lock1获取obj1，Lock2获取obj2，但是它们都没有办法再获取另外一个obj，因为它们都在等待对方先释放锁，这时就是死锁。",
      "public class DeadLock {",
      "    public static String obj1 = \"obj1\";",
      "    public static String obj2 = \"obj2\";",
      "    public static void main(String[] args){",
      "        Thread a = new Thread(new Lock1());",
      "        Thread b = new Thread(new Lock2());",
      "        a.start();",
      "        b.start();",
      "    }    ",
      "}",
      "class Lock1 implements Runnable{",
      "    @Override",
      "    public void run(){",
      "        try{",
      "            System.out.println(\"Lock1 running\");",
      "            while(true){",
      "                synchronized(DeadLock.obj1){",
      "                    System.out.println(\"Lock1 lock obj1\");",
      "                    Thread.sleep(3000);//获取obj1后先等一会儿，让Lock2有足够的时间锁住obj2",
      "                    synchronized(DeadLock.obj2){",
      "                        System.out.println(\"Lock1 lock obj2\");",
      "                    }",
      "                }",
      "            }",
      "        }catch(Exception e){",
      "            e.printStackTrace();",
      "        }",
      "    }",
      "}",
      "class Lock2 implements Runnable{",
      "    @Override",
      "    public void run(){",
      "        try{",
      "            System.out.println(\"Lock2 running\");",
      "            while(true){",
      "                synchronized(DeadLock.obj2){",
      "                    System.out.println(\"Lock2 lock obj2\");",
      "                    Thread.sleep(3000);",
      "                    synchronized(DeadLock.obj1){",
      "                        System.out.println(\"Lock2 lock obj1\");",
      "                    }",
      "                }",
      "            }",
      "        }catch(Exception e){",
      "            e.printStackTrace();",
      "        }",
      "    }",
      "}",
      "如果我们只运行Lock1呢？修改一下main函数，把线程b注释掉。",
    ]
  },
  "jv-ThreadPoolExecutor": {
    "prefix": "jv-ThreadPoolExecutor",
    "body": [
      "ExecutorService service = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue<>());",
    ]
  },
  "jv-transient": {
    "prefix": "jv-transient",
    "body": [
      ".transient的作用",
      "我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。",
      "然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。",
      "总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。",
      "02.transient案例",
      "示例code如下：",
      "",
      "/**",
      " * @description 使用transient关键字不序列化某个变量",
      " *        注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致",
      " */",
      "public class TransientTest {",
      "    ",
      "    public static void main(String[] args) {",
      "        ",
      "        User user = new User();",
      "        user.setUsername(\"Alexia\");",
      "        user.setPasswd(\"123456\");",
      "        ",
      "        System.out.println(\"read before Serializable: \");",
      "        System.out.println(\"username: \" + user.getUsername());",
      "        System.err.println(\"password: \" + user.getPasswd());",
      "        ",
      "        try {",
      "            ObjectOutputStream os = new ObjectOutputStream(",
      "                    new FileOutputStream(\"C:/user.txt\"));",
      "            os.writeObject(user); // 将User对象写进文件",
      "            os.flush();",
      "            os.close();",
      "        } catch (FileNotFoundException e) {",
      "            e.printStackTrace();",
      "        } catch (IOException e) {",
      "            e.printStackTrace();",
      "        }",
      "        try {",
      "            ObjectInputStream is = new ObjectInputStream(new FileInputStream(",
      "                    \"C:/user.txt\"));",
      "            user = (User) is.readObject(); // 从流中读取User的数据",
      "            is.close();",
      "            ",
      "            System.out.println(\"\nread after Serializable: \");",
      "            System.out.println(\"username: \" + user.getUsername());",
      "            System.err.println(\"password: \" + user.getPasswd());",
      "            ",
      "        } catch (FileNotFoundException e) {",
      "            e.printStackTrace();",
      "        } catch (IOException e) {",
      "            e.printStackTrace();",
      "        } catch (ClassNotFoundException e) {",
      "            e.printStackTrace();",
      "        }",
      "    }",
      "}",
      "",
      "class User implements Serializable {",
      "    private static final long serialVersionUID = 8294180014912103005L;  ",
      "    ",
      "    private String username;",
      "    private transient String passwd;",
      "    ",
      "    public String getUsername() {",
      "        return username;",
      "    }",
      "    ",
      "    public void setUsername(String username) {",
      "        this.username = username;",
      "    }",
      "    ",
      "    public String getPasswd() {",
      "        return passwd;",
      "    }",
      "    ",
      "    public void setPasswd(String passwd) {",
      "        this.passwd = passwd;",
      "    }",
      "",
      "}",
      "输出为：",
      "",
      "read before Serializable: ",
      "username: Alexia",
      "password: 123456",
      "",
      "read after Serializable: ",
      "username: Alexia",
      "password: null",
    ]
  },
  "jv-SoftReference": {
    "prefix": "jv-SoftReference",
    "body": [
      "MyObject aRef = new  MyObject();",
      "SoftReference aSoftRef = new SoftReference(aRef);",
      "MyObject anotherRef = (MyObject)aSoftRef.get();",
    ]
  },
  "jv-SoftReference-drawable": {
    "prefix": "jv-SoftReference-drawable",
    "body": [
      "2.4.1 正常是用来处理图片这种占用内存大的情况",
      "代码如下所示",
      "View view = findViewById(R.id.button);",
      "Bitmap bitmap = BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);",
      "Drawable drawable = new BitmapDrawable(bitmap);",
      "SoftReference<Drawable> drawableSoftReference = new SoftReference<Drawable>(drawable);",
      "if(drawableSoftReference != null) {",
      "    view.setBackground(drawableSoftReference.get());",
      "}",
    ]
  },
  "jv-WeakReference": {
    "prefix": "jv-WeakReference",
    "body": [
      "private MyHandler handler = new MyHandler(this);",
      "private static class MyHandler extends Handler{",
      "    WeakReference<FirstActivity> weakReference;",
      "    MyHandler(FirstActivity activity) {",
      "        weakReference = new WeakReference<>(activity);",
      "    }",
      "",
      "    @Override",
      "    public void handleMessage(Message msg) {",
      "        super.handleMessage(msg);",
      "        switch (msg.what){",
      "        }",
      "    }",
      "}",
    ]
  },
  "jv-equals-hashcode": {
    "prefix": "jv-",
    "body": [
      " equals与hashCode有两个注意点",
      "equals相同，则hashCode相同；而hashCode相同，equals不一定相同",
      "如果equals相同，hashCode不相同，有可能会造成上述重复值等情况，这种情况是不允许的；",
      "而hasCode相同，但是equals不一定相同，有可能是因为发生了碰撞而碰撞是有可能性发生的",
    ]
  },
  "jv-双亲委派模型工作流程": {
    "prefix": "jv-双亲委派模型工作流程",
    "body": [
      "双亲委派模型的工作流程是：",
      "如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。",
    ]
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  },
  "jv-": {
    "prefix": "jv-",
    "body": []
  }
}